warning: unused import: `std::collections::HashMap`
  --> codehud-core/src/models/view_types.rs:10:5
   |
10 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `anyhow::Context`
  --> codehud-core/src/extractors/dependencies.rs:19:5
   |
19 | use anyhow::Context;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `FileMetrics`
 --> codehud-core/src/extractors/issues.rs:6:32
  |
6 | use super::{BaseDataExtractor, FileMetrics};
  |                                ^^^^^^^^^^^

warning: unused imports: `Deserialize` and `Serialize`
  --> codehud-core/src/extractors/issues.rs:11:13
   |
11 | use serde::{Serialize, Deserialize};
   |             ^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `ExternalTool`
 --> codehud-core/src/extractors/quality.rs:4:50
  |
4 | use crate::external_tools::{ExternalToolManager, ExternalTool};
  |                                                  ^^^^^^^^^^^^

warning: unused import: `ExternalTool`
 --> codehud-core/src/extractors/security.rs:7:50
  |
7 | use crate::external_tools::{ExternalToolManager, ExternalTool};
  |                                                  ^^^^^^^^^^^^

warning: unused import: `warn`
  --> codehud-core/src/extractors/security.rs:17:22
   |
17 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused imports: `Duration` and `Instant`
  --> codehud-core/src/extractors/runtime_profiler.rs:13:17
   |
13 | use std::time::{Duration, Instant};
   |                 ^^^^^^^^  ^^^^^^^

warning: unused import: `Command`
 --> codehud-core/src/external_tools/mod.rs:7:20
  |
7 | use std::process::{Command, Stdio};
  |                    ^^^^^^^

warning: unused import: `Context`
  --> codehud-core/src/external_tools/mod.rs:11:22
   |
11 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/mypy.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/vulture.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/coverage.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/git.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/cargo_test.rs:9:22
   |
9  | use tracing::{debug, warn};
   |                      ^^^^
   |
help: if this is a test module, consider adding a `#[cfg(test)]` to the containing module
  --> codehud-core/src/external_tools/mod.rs:27:1
   |
27 | pub mod cargo_test;
   | ^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> codehud-core/src/graph/mod.rs:12:33
   |
12 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused imports: `connected_components` and `has_path_connecting`
  --> codehud-core/src/graph/mod.rs:15:22
   |
15 | use petgraph::algo::{connected_components, has_path_connecting};
   |                      ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `EdgeRef` and `IntoNodeReferences`
  --> codehud-core/src/graph/mod.rs:16:23
   |
16 | use petgraph::visit::{EdgeRef, IntoNodeReferences};
   |                       ^^^^^^^  ^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
  --> codehud-core/src/graph/mod.rs:18:22
   |
18 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `has_path_connecting`
 --> codehud-core/src/graph/analyzer.rs:6:44
  |
6 | use petgraph::algo::{connected_components, has_path_connecting};
  |                                            ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
 --> codehud-core/src/graph/analyzer.rs:8:22
  |
8 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `lazy_static::lazy_static`
  --> codehud-core/src/query_engine.rs:19:5
   |
19 | use lazy_static::lazy_static;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> codehud-core/src/analysis/view_generator.rs:8:5
  |
8 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `import_graph`
   --> codehud-core/src/extractors/dependencies.rs:474:41
    |
474 |     fn analyze_coupling_strength(&self, import_graph: &HashMap<String, HashSet<String>>, internal_imports: &HashMap<String, HashSet<Strin...
    |                                         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_import_graph`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `file_path`
   --> codehud-core/src/extractors/dependencies.rs:607:14
    |
607 |         for (file_path, imports) in import_graph {
    |              ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_file_path`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:212:9
    |
212 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:246:9
    |
246 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:274:9
    |
274 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:306:9
    |
306 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: variable does not need to be mutable
   --> codehud-core/src/extractors/quality.rs:755:25
    |
755 |                     let mut issues = extractor.detect_quality_issues(file_path, &file_analyzer, &lines);
    |                         ----^^^^^^
    |                         |
    |                         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `mat`
   --> codehud-core/src/extractors/security.rs:412:21
    |
412 |                 for mat in pattern.find_iter(line) {
    |                     ^^^ help: if this is intentional, prefix it with an underscore: `_mat`

warning: value assigned to `severity` is never read
   --> codehud-core/src/extractors/runtime_profiler.rs:257:21
    |
257 |             let mut severity = "minor";
    |                     ^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: value assigned to `impact_score` is never read
   --> codehud-core/src/extractors/runtime_profiler.rs:258:21
    |
258 |             let mut impact_score = 0.0;
    |                     ^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `end`
   --> codehud-core/src/external_tools/ripgrep.rs:165:25
    |
165 |                     let end = first_match["end"].as_u64().unwrap_or(0) as u32;
    |                         ^^^ help: if this is intentional, prefix it with an underscore: `_end`

warning: unused variable: `source`
   --> codehud-core/src/query_engine.rs:753:9
    |
753 |         source: &str
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `quality_data`
   --> codehud-core/src/analysis/mod.rs:334:37
    |
334 | ...                   quality_data: &Value,
    |                       ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_quality_data`

warning: methods `extract_function_name`, `extract_class_name`, and `extract_dependency` are never used
   --> codehud-core/src/extractors/topology.rs:443:8
    |
23  | impl TopologyExtractor {
    | ---------------------- methods in this implementation
...
443 |     fn extract_function_name(&self, line: &str) -> Option<String> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
456 |     fn extract_class_name(&self, line: &str) -> Option<String> {
    |        ^^^^^^^^^^^^^^^^^^
...
466 |     fn extract_dependency(&self, line: &str) -> Option<String> {
    |        ^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: field `codebase_path` is never read
   --> codehud-core/src/extractors/topology.rs:719:5
    |
717 | struct PythonAstAnalyzer {
    |        ----------------- field in this struct
718 |     file_path: String,
719 |     codebase_path: PathBuf,
    |     ^^^^^^^^^^^^^

warning: methods `visit_async_function_def` and `visit_import_from` are never used
   --> codehud-core/src/extractors/topology.rs:787:8
    |
726 | impl PythonAstAnalyzer {
    | ---------------------- methods in this implementation
...
787 |     fn visit_async_function_def(&mut self, node: tree_sitter::Node, source: &[u8]) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
843 |     fn visit_import_from(&mut self, node: tree_sitter::Node, source: &[u8]) {
    |        ^^^^^^^^^^^^^^^^^

warning: field `external_tools` is never read
  --> codehud-core/src/extractors/evolution.rs:63:5
   |
60 | pub struct EvolutionExtractor {
   |            ------------------ field in this struct
...
63 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/flow.rs:60:5
   |
57 | pub struct FlowExtractor {
   |            ------------- fields in this struct
...
60 |     parser: Parser,
   |     ^^^^^^
61 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/flow.rs:14:8
   |
14 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `file_path` is never read
  --> codehud-core/src/extractors/orphaned_files.rs:28:5
   |
27 | struct FileUsage {
   |        --------- field in this struct
28 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `FileUsage` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `parser` is never read
  --> codehud-core/src/extractors/orphaned_files.rs:39:5
   |
36 | pub struct OrphanedFilesExtractor {
   |            ---------------------- field in this struct
...
39 |     parser: Parser,
   |     ^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/orphaned_files.rs:11:8
   |
11 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/performance.rs:40:5
   |
37 | pub struct PerformanceExtractor {
   |            -------------------- fields in this struct
...
40 |     parser: Parser,
   |     ^^^^^^
41 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: field `codebase_path` is never read
   --> codehud-core/src/extractors/performance.rs:318:5
    |
316 | struct PerformanceAstAnalyzer {
    |        ---------------------- field in this struct
317 |     file_path: String,
318 |     codebase_path: PathBuf,
    |     ^^^^^^^^^^^^^
    |
    = note: `PerformanceAstAnalyzer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `description` is never read
   --> codehud-core/src/extractors/performance.rs:349:5
    |
345 | struct ExpensiveOperation {
    |        ------------------ field in this struct
...
349 |     description: String,
    |     ^^^^^^^^^^^
    |
    = note: `ExpensiveOperation` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `line`, `function_name`, and `has_termination_check` are never read
   --> codehud-core/src/extractors/performance.rs:354:5
    |
353 | struct RecursiveCall {
    |        ------------- fields in this struct
354 |     line: usize,
    |     ^^^^
355 |     function_name: String,
    |     ^^^^^^^^^^^^^
356 |     has_termination_check: bool,
    |     ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `RecursiveCall` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/performance.rs:12:8
   |
12 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `external_tools` is never read
  --> codehud-core/src/extractors/quality.rs:22:5
   |
18 | pub struct QualityExtractor {
   |            ---------------- field in this struct
...
22 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: field `end_line` is never read
  --> codehud-core/src/extractors/quality.rs:54:5
   |
49 | struct FunctionMetrics {
   |        --------------- field in this struct
...
54 |     end_line: usize,
   |     ^^^^^^^^
   |
   = note: `FunctionMetrics` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: fields `lines` and `end_line` are never read
  --> codehud-core/src/extractors/quality.rs:62:5
   |
59 | struct ClassMetrics {
   |        ------------ fields in this struct
...
62 |     lines: usize,
   |     ^^^^^
63 |     start_line: usize,
64 |     end_line: usize,
   |     ^^^^^^^^
   |
   = note: `ClassMetrics` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: methods `analyze_file_quality`, `run_external_tools_analysis`, and `run_external_tools` are never used
   --> codehud-core/src/extractors/quality.rs:129:14
    |
90  | impl QualityExtractor {
    | --------------------- methods in this implementation
...
129 |     async fn analyze_file_quality(&mut self, file_path: &Path) -> Result<Option<Value>> {
    |              ^^^^^^^^^^^^^^^^^^^^
...
592 |     async fn run_external_tools_analysis(&self, file_path: &Path) -> Result<Vec<Value>> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
690 |     fn run_external_tools(&self) -> HashMap<String, Value> {
    |        ^^^^^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/quality.rs:15:8
   |
15 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:34:5
   |
33 | struct SecurityVulnerability {
   |        --------------------- field in this struct
34 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `SecurityVulnerability` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:46:5
   |
45 | struct SecurityIssue {
   |        ------------- field in this struct
46 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `SecurityIssue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:56:5
   |
55 | struct DangerousFunctionUsage {
   |        ---------------------- field in this struct
56 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `DangerousFunctionUsage` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:65:5
   |
64 | struct SensitiveDataExposure {
   |        --------------------- field in this struct
65 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `SensitiveDataExposure` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:74:5
   |
73 | struct FilePermissionIssue {
   |        ------------------- field in this struct
74 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `FilePermissionIssue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `external_tools` is never read
  --> codehud-core/src/extractors/security.rs:85:5
   |
81 | pub struct SecurityExtractor {
   |            ----------------- field in this struct
...
85 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: method `get_function_severity` is never used
   --> codehud-core/src/extractors/security.rs:493:8
    |
91  | impl SecurityExtractor {
    | ---------------------- method in this implementation
...
493 |     fn get_function_severity(&self, function_name: &str) -> String {
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/security.rs:20:8
   |
20 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/testing.rs:70:5
   |
67 | pub struct TestingExtractor {
   |            ---------------- fields in this struct
...
70 |     parser: Parser,
   |     ^^^^^^
71 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/testing.rs:15:8
   |
15 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/runtime_profiler.rs:65:5
   |
62 | pub struct RuntimeProfiler {
   |            --------------- fields in this struct
...
65 |     parser: Parser,
   |     ^^^^^^
66 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/runtime_profiler.rs:16:8
   |
16 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `codebase_path` is never read
  --> codehud-core/src/external_tools/mod.rs:42:5
   |
31 | pub struct ExternalToolManager {
   |            ------------------- field in this struct
...
42 |     codebase_path: PathBuf,
   |     ^^^^^^^^^^^^^

warning: field `codebase_path` is never read
   --> codehud-core/src/external_tools/mod.rs:286:5
    |
278 | pub struct RustToolManager {
    |            --------------- field in this struct
...
286 |     codebase_path: PathBuf,
    |     ^^^^^^^^^^^^^

warning: field `metrics` is never read
   --> codehud-core/src/external_tools/bandit.rs:225:9
    |
223 | struct BanditJsonOutput {
    |        ---------------- field in this struct
224 |     pub results: Vec<BanditJsonResult>,
225 |     pub metrics: BanditMetrics,
    |         ^^^^^^^
    |
    = note: `BanditJsonOutput` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: fields `version` and `branch_coverage` are never read
   --> codehud-core/src/external_tools/coverage.rs:215:9
    |
213 | struct CoverageMeta {
    |        ------------ fields in this struct
214 |     pub timestamp: String,
215 |     pub version: String,
    |         ^^^^^^^
216 |     pub branch_coverage: Option<bool>,
    |         ^^^^^^^^^^^^^^^
    |
    = note: `CoverageMeta` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: fields `percent_covered` and `percent_covered_display` are never read
   --> codehud-core/src/external_tools/coverage.rs:230:9
    |
227 | struct CoverageFileSummary {
    |        ------------------- fields in this struct
...
230 |     pub percent_covered: f64,
    |         ^^^^^^^^^^^^^^^
...
233 |     pub percent_covered_display: Option<String>,
    |         ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `CoverageFileSummary` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: `codehud-core` (lib) generated 72 warnings (run `cargo fix --lib -p codehud-core` to apply 24 suggestions)
warning: unused imports: `LlmConfig` and `ModelType`
 --> codehud-llm/src/ffi.rs:7:13
  |
7 | use crate::{LlmConfig, ModelType, LlmResult, LlmError, MistakeType, CriticalMistake, CodeLocation};
  |             ^^^^^^^^^  ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `std::collections::HashMap`
  --> codehud-llm/src/ffi.rs:11:5
   |
11 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `GpuType` and `LlmError`
 --> codehud-llm/src/native_stub.rs:6:35
  |
6 | use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError};
  |                                   ^^^^^^^             ^^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> codehud-llm/src/native_stub.rs:9:5
  |
9 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::path::PathBuf`
  --> codehud-llm/src/native_stub.rs:10:5
   |
10 | use std::path::PathBuf;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> codehud-llm/src/native_stub.rs:11:5
   |
11 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `tokio::sync::RwLock`
  --> codehud-llm/src/native_stub.rs:12:5
   |
12 | use tokio::sync::RwLock;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `LlmConfig`
  --> codehud-llm/src/structured.rs:11:13
   |
11 | use crate::{LlmConfig, LlmResult, LlmError, ffi::PythonLlmBridge, native_stub::NativeLlmEngine};
   |             ^^^^^^^^^

warning: unused import: `json`
  --> codehud-llm/src/structured.rs:14:25
   |
14 | use serde_json::{Value, json};
   |                         ^^^^

warning: unused import: `LlmError`
 --> codehud-llm/src/critical.rs:7:24
  |
7 | use crate::{LlmResult, LlmError, ffi::PythonLlmBridge};
  |                        ^^^^^^^^

warning: unused import: `LlmError`
 --> codehud-llm/src/monitoring.rs:1:13
  |
1 | use crate::{LlmError, LlmResult};
  |             ^^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> codehud-llm/src/equivalence.rs:9:5
  |
9 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `QueryEngine`
 --> codehud-llm/src/comment_extractor.rs:9:34
  |
9 | use codehud_core::query_engine::{QueryEngine, get_query_engine, SupportedLanguage};
  |                                  ^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> codehud-llm/src/comment_extractor.rs:13:5
   |
13 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `codehud_core::query_engine::QueryEngine`
  --> codehud-llm/src/file_processor.rs:17:5
   |
17 | use codehud_core::query_engine::QueryEngine;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CleanedFileAnalysis`
 --> codehud-llm/src/extraction_fsm.rs:8:73
  |
8 | use crate::comment_extractor::{CommentExtractor, FileCommentExtraction, CleanedFileAnalysis};
  |                                                                         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> codehud-llm/src/extraction_fsm.rs:14:24
   |
14 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^

warning: unused import: `aho_corasick::AhoCorasick`
 --> codehud-llm/src/denoiser.rs:9:5
  |
9 | use aho_corasick::AhoCorasick;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ProcessorConfig`
 --> codehud-llm/src/crate_summarizer.rs:6:49
  |
6 | use crate::{LlmResult, LlmError, FileProcessor, ProcessorConfig};
  |                                                 ^^^^^^^^^^^^^^^

warning: unused variable: `python_bridge`
   --> codehud-llm/src/structured.rs:317:25
    |
317 |         if let Some(ref python_bridge) = self.python_bridge {
    |                         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_python_bridge`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `enhanced_prompt`
   --> codehud-llm/src/structured.rs:440:13
    |
440 |         let enhanced_prompt = self.build_enhanced_prompt(prompt, constraints);
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_enhanced_prompt`

warning: unused variable: `python_bridge`
   --> codehud-llm/src/structured.rs:708:25
    |
708 |         if let Some(ref python_bridge) = self.python_bridge {
    |                         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_python_bridge`

warning: unused variable: `python_bridge`
   --> codehud-llm/src/critical.rs:316:25
    |
316 |         if let Some(ref python_bridge) = self.python_bridge {
    |                         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_python_bridge`

warning: unused variable: `rule`
   --> codehud-llm/src/critical.rs:519:9
    |
519 |         rule: &DetectionRule,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_rule`

warning: unused variable: `rule`
   --> codehud-llm/src/critical.rs:652:9
    |
652 |         rule: &DetectionRule,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_rule`

warning: unused variable: `rule`
   --> codehud-llm/src/critical.rs:695:9
    |
695 |         rule: &DetectionRule,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_rule`

warning: unused variable: `code`
   --> codehud-llm/src/critical.rs:806:75
    |
806 |     async fn generate_syntax_correction(&self, mistake: &CriticalMistake, code: &str) -> Option<(String, String)> {
    |                                                                           ^^^^ help: if this is intentional, prefix it with an underscore: `_code`

warning: unused variable: `code`
   --> codehud-llm/src/critical.rs:818:77
    |
818 |     async fn generate_security_correction(&self, mistake: &CriticalMistake, code: &str) -> Option<(String, String)> {
    |                                                                             ^^^^ help: if this is intentional, prefix it with an underscore: `_code`

warning: unused variable: `code`
   --> codehud-llm/src/critical.rs:835:80
    |
835 |     async fn generate_performance_correction(&self, mistake: &CriticalMistake, code: &str) -> Option<(String, String)> {
    |                                                                                ^^^^ help: if this is intentional, prefix it with an underscore: `_code`

warning: unused variable: `duration`
   --> codehud-llm/src/file_processor.rs:537:13
    |
537 |         let duration = start_time.elapsed();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_duration`

warning: unused variable: `extraction`
   --> codehud-llm/src/extraction_fsm.rs:313:28
    |
313 |                 file_path, extraction, summary
    |                            ^^^^^^^^^^ help: try ignoring the field: `extraction: _`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:313:40
    |
313 |                 file_path, extraction, summary
    |                                        ^^^^^^^ help: try ignoring the field: `summary: _`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:363:56
    |
363 |              ExtractionEvent::ProjectSummaryComplete { summary }) => {
    |                                                        ^^^^^^^ help: try ignoring the field: `summary: _`

warning: unused variable: `discovered_crates`
   --> codehud-llm/src/extraction_fsm.rs:382:55
    |
382 |              ExtractionEvent::CrateGroupingComplete { discovered_crates }) => {
    |                                                       ^^^^^^^^^^^^^^^^^ help: try ignoring the field: `discovered_crates: _`

warning: unused variable: `project_path`
   --> codehud-llm/src/extraction_fsm.rs:383:21
    |
383 |                 let project_path = match &*state {
    |                     ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_path`

warning: unused variable: `extraction`
   --> codehud-llm/src/extraction_fsm.rs:474:17
    |
474 |             Ok((extraction, summary)) => {
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_extraction`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:474:29
    |
474 |             Ok((extraction, summary)) => {
    |                             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_summary`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:804:16
    |
804 |             Ok(summary) => {
    |                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_summary`

warning: unused variable: `index`
    --> codehud-llm/src/extraction_fsm.rs:1365:14
     |
1365 |         for (index, crate_info) in discovered_crates.iter().enumerate() {
     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_index`

warning: unused variable: `index`
    --> codehud-llm/src/extraction_fsm.rs:1395:14
     |
1395 |         for (index, crate_info) in discovered_crates.iter().enumerate() {
     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_index`

warning: unused variable: `index`
    --> codehud-llm/src/extraction_fsm.rs:1430:14
     |
1430 |         for (index, crate_info) in discovered_crates.iter().enumerate() {
     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_index`

warning: variable `total_tokens` is assigned to, but never used
    --> codehud-llm/src/extraction_fsm.rs:1483:17
     |
1483 |         let mut total_tokens = 0;
     |                 ^^^^^^^^^^^^
     |
     = note: consider using `_total_tokens` instead

warning: unused variable: `project_summary`
    --> codehud-llm/src/extraction_fsm.rs:1524:13
     |
1524 |         let project_summary = ProjectSummary {
     |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_summary`

warning: unused variable: `discovered_crates`
    --> codehud-llm/src/extraction_fsm.rs:2137:68
     |
2137 |     async fn generate_final_summary(&self, project_path: &PathBuf, discovered_crates: &[CrateInfo]) -> LlmResult<()> {
     |                                                                    ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_discovered_crates`

warning: variable `total_tokens` is assigned to, but never used
    --> codehud-llm/src/extraction_fsm.rs:2164:17
     |
2164 |         let mut total_tokens = 0;
     |                 ^^^^^^^^^^^^
     |
     = note: consider using `_total_tokens` instead

warning: unused variable: `subcrate_files`
   --> codehud-llm/src/crate_summarizer.rs:452:14
    |
452 |         let (subcrate_files, individual_files) = if let Some(ref subcrates) = subcrate_summaries {
    |              ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_subcrate_files`

warning: unused import: `std::io::Write`
  --> codehud-llm/src/extraction_fsm.rs:17:5
   |
17 | use std::io::Write;
   |     ^^^^^^^^^^^^^^

warning: unused variable: `memory`
   --> codehud-llm/src/conversation.rs:650:13
    |
650 |         let memory = ProjectAnalysisMemory::new();
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_memory`

warning: unused variable: `project_id`
   --> codehud-llm/src/conversation.rs:676:13
    |
676 |         let project_id = format!("project:{}", project_path);
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_id`

warning: unused variable: `project_path`
   --> codehud-llm/src/conversation.rs:682:45
    |
682 |     pub fn update_project_memory(&mut self, project_path: &str, crate_summary: &CrateSummary) -> LlmResult<()> {
    |                                             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_path`

warning: unused variable: `language`
   --> codehud-llm/src/comment_extractor.rs:362:9
    |
362 |         language: &str,
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_language`

warning: unused variable: `file_path`
   --> codehud-llm/src/comment_extractor.rs:393:9
    |
393 |         file_path: &Path,
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_file_path`

warning: unused variable: `end_byte`
   --> codehud-llm/src/comment_extractor.rs:655:70
    |
655 |     fn extract_code_context(&self, content: &str, start_byte: usize, end_byte: usize) -> Option<CodeContext> {
    |                                                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_end_byte`

warning: multiple fields are never read
  --> codehud-llm/src/ffi.rs:20:5
   |
18 | pub struct PythonLlmBridge {
   |            --------------- fields in this struct
19 |     /// Python interpreter instance
20 |     python: Python<'static>,
   |     ^^^^^^
...
24 |     pytorch_pipeline: PyObject,
   |     ^^^^^^^^^^^^^^^^
...
34 |     self_verification: PyObject,
   |     ^^^^^^^^^^^^^^^^^
35 |     /// Python continuous test monitor module
36 |     test_monitor: PyObject,
   |     ^^^^^^^^^^^^
37 |     /// Python behavior analysis module
38 |     behavior_analysis: PyObject,
   |     ^^^^^^^^^^^^^^^^^
...
42 |     guardrails: PyObject,
   |     ^^^^^^^^^^
43 |     /// Python OpenHands bridge module
44 |     openhands_bridge: PyObject,
   |     ^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: methods `get_call_wrapper`, `safe_python_call`, and `safe_python_call_async` are never used
   --> codehud-llm/src/ffi.rs:847:8
    |
845 | impl PythonLlmBridge {
    | -------------------- methods in this implementation
846 |     /// Get the Python call wrapper for this bridge
847 |     fn get_call_wrapper(&self) -> PythonCallWrapper {
    |        ^^^^^^^^^^^^^^^^
...
852 |     fn safe_python_call<F, R>(&self, method_name: &str, f: F) -> LlmResult<R>
    |        ^^^^^^^^^^^^^^^^
...
861 |     async fn safe_python_call_async<F, R>(&self, method_name: &str, f: F) -> LlmResult<R>
    |              ^^^^^^^^^^^^^^^^^^^^^^

warning: multiple fields are never read
   --> codehud-llm/src/ollama.rs:200:5
    |
199 | struct OllamaResponse {
    |        -------------- fields in this struct
200 |     model: String,
    |     ^^^^^
201 |     created_at: String,
    |     ^^^^^^^^^^
202 |     response: String,
203 |     done: bool,
    |     ^^^^
...
207 |     total_duration: Option<u64>,
    |     ^^^^^^^^^^^^^^
208 |     #[serde(skip_serializing_if = "Option::is_none")]
209 |     load_duration: Option<u64>,
    |     ^^^^^^^^^^^^^
210 |     #[serde(skip_serializing_if = "Option::is_none")]
211 |     prompt_eval_count: Option<i32>,
    |     ^^^^^^^^^^^^^^^^^
212 |     #[serde(skip_serializing_if = "Option::is_none")]
213 |     eval_count: Option<i32>,
    |     ^^^^^^^^^^
    |
    = note: `OllamaResponse` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `native_engine` is never read
  --> codehud-llm/src/structured.rs:67:5
   |
61 | pub struct StructuredCodeGenerator {
   |            ----------------------- field in this struct
...
67 |     native_engine: Option<NativeLlmEngine>,
   |     ^^^^^^^^^^^^^

warning: methods `parse_comment_from_highlight`, `parse_comment_from_capture`, `fallback_comment_extraction`, and `determine_comment_type` are never used
   --> codehud-llm/src/comment_extractor.rs:461:8
    |
173 | impl CommentExtractor {
    | --------------------- methods in this implementation
...
461 |     fn parse_comment_from_highlight(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
499 |     fn parse_comment_from_capture(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
510 |     fn fallback_comment_extraction(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
638 |     fn determine_comment_type(&self, raw_comment: &str) -> CommentType {
    |        ^^^^^^^^^^^^^^^^^^^^^^

warning: fields `llm_pipeline`, `constitutional_ai`, `conversation_tracker`, and `llm_monitor` are never read
   --> codehud-llm/src/file_processor.rs:247:5
    |
243 | pub struct FileProcessor {
    |            ------------- fields in this struct
...
247 |     llm_pipeline: Arc<OllamaPipeline>,
    |     ^^^^^^^^^^^^
...
251 |     constitutional_ai: Arc<ConstitutionalAI>,
    |     ^^^^^^^^^^^^^^^^^
252 |     /// Conversation tracker for context management
253 |     conversation_tracker: Arc<ConversationTracker>,
    |     ^^^^^^^^^^^^^^^^^^^^
254 |     /// LLM performance monitor
255 |     llm_monitor: Arc<LlmMonitor>,
    |     ^^^^^^^^^^^

warning: field `patterns` is never read
   --> codehud-llm/src/extraction_fsm.rs:203:5
    |
195 | struct ProjectContext {
    |        -------------- field in this struct
...
203 |     patterns: Vec<String>,
    |     ^^^^^^^^
    |
    = note: `ProjectContext` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `process_single_project_file`, `generate_comprehensive_project_summary`, `generate_comprehensive_project_summary_from_files`, and `process_crate_phase2_subcrates` are never used
    --> codehud-llm/src/extraction_fsm.rs:627:14
     |
224  | impl CommentExtractionFSM {
     | ------------------------- methods in this implementation
...
627  |     async fn process_single_project_file(&self, file_path: PathBuf) -> LlmResult<()> {
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
872  |     async fn generate_comprehensive_project_summary(&self, all_extractions: &[FileCommentExtraction]) -> LlmResult<String> {
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
905  |     async fn generate_comprehensive_project_summary_from_files(&self, file_summaries: &[(String, String)]) -> LlmResult<String> {
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
1931 |     async fn process_crate_phase2_subcrates(&self, project_path: &PathBuf, crate_info: &CrateInfo) -> LlmResult<()> {
     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: field `denoiser` is never read
  --> codehud-llm/src/crate_summarizer.rs:96:5
   |
92 | pub struct CrateSummarizer {
   |            --------------- field in this struct
...
96 |     denoiser: LlmContextDenoiser,
   |     ^^^^^^^^

warning: methods `build_context_aware_prompt` and `build_reduced_context_prompt` are never used
   --> codehud-llm/src/crate_summarizer.rs:659:8
    |
329 | impl CrateSummarizer {
    | -------------------- methods in this implementation
...
659 |     fn build_context_aware_prompt(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
733 |     fn build_reduced_context_prompt(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: fields `name` and `all_files` are never read
    --> codehud-llm/src/crate_summarizer.rs:1251:5
     |
1250 | struct SubcrateNode {
     |        ------------ fields in this struct
1251 |     name: String,
     |     ^^^^
1252 |     direct_files: Vec<CleanedFileData>,
1253 |     all_files: Vec<CleanedFileData>,
     |     ^^^^^^^^^
     |
     = note: `SubcrateNode` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: unused import: `Context`
 --> codehud-viz/src/lib.rs:8:14
  |
8 | use anyhow::{Context, Result};
  |              ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `Axis`, `Cell`, `Chart`, `Clear`, `Dataset`, `Line`, `Row`, `Span`, `Table`, `Terminal`, `Text`, and `symbols`
  --> codehud-viz/src/lib.rs:19:5
   |
19 |     symbols,
   |     ^^^^^^^
20 |     text::{Line, Span, Text},
   |            ^^^^  ^^^^  ^^^^
21 |     widgets::{
22 |         Axis, Block, Borders, Chart, Dataset, Gauge, List, ListItem,
   |         ^^^^                  ^^^^^  ^^^^^^^
23 |         Paragraph, BarChart, Clear, Table, Row, Cell, Wrap
   |                              ^^^^^  ^^^^^  ^^^  ^^^^
24 |     },
25 |     Frame, Terminal,
   |            ^^^^^^^^

warning: unused import: `Path`
  --> codehud-viz/src/lib.rs:30:12
   |
30 |     path::{Path, PathBuf},
   |            ^^^^

warning: unused import: `std::collections::HashMap`
  --> codehud-viz/src/call_graph.rs:13:5
   |
13 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `LinesWithEndings`, `Style as SyntectStyle`, `as_24_bit_terminal_escaped`, and `easy::HighlightLines`
  --> codehud-viz/src/lib.rs:36:5
   |
36 |     easy::HighlightLines,
   |     ^^^^^^^^^^^^^^^^^^^^
37 |     highlighting::{ThemeSet, Style as SyntectStyle},
   |                              ^^^^^^^^^^^^^^^^^^^^^
38 |     parsing::SyntaxSet,
39 |     util::{as_24_bit_terminal_escaped, LinesWithEndings},
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^

warning: unused import: `backend::Backend`
  --> codehud-viz/src/lib.rs:16:5
   |
16 |     backend::Backend,
   |     ^^^^^^^^^^^^^^^^

warning: unused variable: `graph_analysis`
   --> codehud-viz/src/lib.rs:926:25
    |
926 |             if let Some(graph_analysis) = data.get("graph_analysis") {
    |                         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_graph_analysis`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `idx`
    --> codehud-viz/src/lib.rs:1149:30
     |
1149 |                         for (idx, issue) in issues_array.iter().enumerate().take(self.config.max_list_items / tool_names.len()) {
     |                              ^^^ help: if this is intentional, prefix it with an underscore: `_idx`

warning: unused variable: `nodes_array`
    --> codehud-viz/src/lib.rs:1319:34
     |
1319 |                     if let (Some(nodes_array), Some(edges_array)) = (nodes.as_array(), edges.as_array()) {
     |                                  ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_nodes_array`

warning: unused variable: `semantic_complexity`
    --> codehud-viz/src/lib.rs:2918:104
     |
2918 | ..._by_type, highlights_summary, semantic_complexity, language_features } = &view.content {
     |                                  ^^^^^^^^^^^^^^^^^^^ help: try ignoring the field: `semantic_complexity: _`

warning: fields `syntax_set` and `theme_set` are never read
  --> codehud-viz/src/lib.rs:45:5
   |
43 | pub struct VisualizationEngine {
   |            ------------------- fields in this struct
44 |     config: VizConfig,
45 |     syntax_set: SyntaxSet,
   |     ^^^^^^^^^^
46 |     theme_set: ThemeSet,
   |     ^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: method `get_risk_color` is never used
    --> codehud-viz/src/lib.rs:3292:8
     |
291  | impl VisualizationEngine {
     | ------------------------ method in this implementation
...
3292 |     fn get_risk_color(&self, risk_level: &str) -> Style {
     |        ^^^^^^^^^^^^^^

warning: unused import: `runtime_profiler::RuntimeProfiler`
  --> codehud-analysis/src/pipeline.rs:19:9
   |
19 |         runtime_profiler::RuntimeProfiler,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: field `config` is never read
  --> codehud-analysis/src/pipeline.rs:35:5
   |
34 | pub struct DirectAnalysisPipeline {
   |            ---------------------- field in this struct
35 |     config: CoreConfig,
   |     ^^^^^^
   |
   = note: `DirectAnalysisPipeline` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: `codehud-llm` (lib) generated 64 warnings (run `cargo fix --lib -p codehud-llm` to apply 19 suggestions)
warning: `codehud-viz` (lib) generated 12 warnings (run `cargo fix --lib -p codehud-viz` to apply 5 suggestions)
warning: `codehud-analysis` (lib) generated 2 warnings (run `cargo fix --lib -p codehud-analysis` to apply 1 suggestion)
warning: unused imports: `CommentExtractor`, `GpuType`, `LlmConfig`, `ModelType`, and `ScanResult`
  --> codehud-cli/src/llm.rs:10:37
   |
10 |     FileProcessor, ProcessorConfig, CommentExtractor, ExtractionConfig,
   |                                     ^^^^^^^^^^^^^^^^
11 |     LlmConfig, OllamaConfig, ModelType, GpuType,
   |     ^^^^^^^^^                ^^^^^^^^^  ^^^^^^^
12 |     CommentExtractionFSM, CommentExtractionCLI, ExtractionState, ScanResult,
   |                                                                  ^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `skip_system_summary`
   --> codehud-cli/src/llm.rs:264:5
    |
264 |     skip_system_summary: bool,
    |     ^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_skip_system_summary`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `extensions`
   --> codehud-cli/src/llm.rs:265:5
    |
265 |     extensions: Vec<String>,
    |     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_extensions`

warning: unused variable: `cli`
   --> codehud-cli/src/llm.rs:352:5
    |
352 |     cli: &Cli,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_cli`

warning: unused variable: `cli`
   --> codehud-cli/src/llm.rs:374:5
    |
374 |     cli: &Cli,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_cli`

warning: unused variable: `cli`
   --> codehud-cli/src/llm.rs:402:5
    |
402 |     cli: &Cli,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_cli`

warning: unused variable: `session`
   --> codehud-cli/src/llm.rs:404:5
    |
404 |     session: Option<PathBuf>,
    |     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_session`

warning: unused variable: `max_tokens`
   --> codehud-cli/src/llm.rs:406:5
    |
406 |     max_tokens: u32,
    |     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_tokens`

warning: `codehud-cli` (bin "codehud-llm") generated 8 warnings (run `cargo fix --bin "codehud-llm"` to apply 1 suggestion)
    Finished `release` profile [optimized] target(s) in 0.21s
     Running `target/release/codehud-llm scan-project '/home/travers/Desktop/CodeHUD (copy)/Rust_copy'`
🚀 CodeHUD LLM - Project Scanner
🤖 Backend: ollama
🔍 FSM DEBUG: ProjectSelected event received for: /home/travers/Desktop/CodeHUD (copy)/Rust_copy
🔍 FSM DEBUG: Current state: Discriminant(0)
🔍 🔍 🔍 CRATE DISCOVERY STARTING: /home/travers/Desktop/CodeHUD (copy)/Rust_copy
🔍 🔍 🔍 CRATE DISCOVERY STARTING: /home/travers/Desktop/CodeHUD (copy)/Rust_copy
🔍 DEBUG: Searching for Cargo.toml files in: /home/travers/Desktop/CodeHUD (copy)/Rust_copy
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/Cargo.toml
📦 Discovered crate: codehud-tui at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/Cargo.toml
📦 Discovered crate: codehud-viz at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/Cargo.toml
📦 Discovered crate: codehud-cli at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/test_project_hierarchical/codehud-tui/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/test_project_hierarchical/codehud-viz/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/test_project_hierarchical/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime/Cargo.toml
📦 Discovered crate: codehud-realtime at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/Cargo.toml
📦 Discovered crate: codehud-core at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/ruby/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/c/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/rust/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/php/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/typescript/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/python/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/c-sharp/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/swift/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/cpp/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/kotlin/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/javascript/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/java/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/tree-sitter-grammars/go/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/Cargo.toml
📦 Discovered crate: codehud-gui at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/Cargo.toml
📦 Discovered crate: codehud-utils at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/Cargo.toml
📦 Discovered crate: codehud-transform at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/Cargo.toml
⚠️  Failed to parse /home/travers/Desktop/CodeHUD (copy)/Rust_copy/Cargo.toml: Configuration error: No [package] section in Cargo.toml
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/Cargo.toml
📦 Discovered crate: codehud-analysis at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/Cargo.toml
📦 Discovered crate: codehud-llm at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm
🔍 DEBUG: Found Cargo.toml at: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/test_hierarchical/Cargo.toml
📦 Found 10 crates for hierarchical analysis
  - codehud-analysis (Analysis pipeline and rendering system - Zero degradation from Python)
  - codehud-cli (Command-line interfaces (4 CLI systems) - Zero degradation from Python)
  - codehud-core (Core analysis engine with 11+ extractors - Zero degradation from Python)
  - codehud-gui (No description)
  - codehud-llm (LLM integration (29+ components) - Zero degradation from Python)
  - codehud-realtime (Real-time monitoring and file watching - Zero degradation from Python)
  - codehud-transform (Code transformation and refactoring engine - Zero degradation from Python)
  - codehud-tui (Terminal user interface with Textual compatibility - Zero degradation from Python)
  - codehud-utils (Utility functions with Python compatibility - Zero degradation from Python)
  - codehud-viz (Visualization system (10+ view types) - Zero degradation from Python)
🧠 Starting hierarchical crate processing...
🖥️  Spawned progress window with gnome-terminal

📝 PHASE 1: Extracting comments and generating file summaries for all crates...

🔍 DEBUG: Crate path for codehud-analysis: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis
🔍 Processing 3 files from crate codehud-analysis
🔍 DEBUG: First 5 files discovered for crate codehud-analysis:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/lib.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/health_score.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/pipeline.rs
🔍 Loading Rust Imports query: 1261 chars
✅ Successfully compiled Rust Imports query
🔍 Loading Rust Functions query: 289 chars
✅ Successfully compiled Rust Functions query
🔍 Loading Rust Calls query: 571 chars
✅ Successfully compiled Rust Calls query
🔍 Loading Rust Complexity query: 1116 chars
✅ Successfully compiled Rust Complexity query
🔍 Loading Rust Highlights query: 3489 chars
❌ Failed to compile Highlights query for Rust: Query error at 112:2. Invalid node type gen
[2m2025-10-04T00:18:52.128552Z[0m [33m WARN[0m Failed to compile Highlights query for Rust: Query error at 112:2. Invalid node type gen
🔍 Loading Rust Tags query: 1194 chars
✅ Successfully compiled Rust Tags query
⚠️ No query file found for Rust References
🔍 Loading Rust Comments query: 194 chars
✅ Successfully compiled Rust Comments query
🔍 Loading Python Imports query: 1434 chars
❌ Failed to compile Imports query for Python: Query error at 34:3. Impossible pattern:
  name: (wildcard_import)) @wildcard_import
  ^
[2m2025-10-04T00:18:52.133768Z[0m [33m WARN[0m Failed to compile Imports query for Python: Query error at 34:3. Impossible pattern:
  name: (wildcard_import)) @wildcard_import
  ^
🔍 Loading Python Functions query: 673 chars
✅ Successfully compiled Python Functions query
🔍 Loading Python Calls query: 355 chars
✅ Successfully compiled Python Calls query
🔍 Loading Python Complexity query: 639 chars
✅ Successfully compiled Python Complexity query
🔍 Loading Python Highlights query: 1957 chars
✅ Successfully compiled Python Highlights query
🔍 Loading Python Tags query: 350 chars
✅ Successfully compiled Python Tags query
⚠️ No query file found for Python References
🔍 Loading Python Comments query: 399 chars
✅ Successfully compiled Python Comments query
⚠️ No query file found for JavaScript Imports
⚠️ No query file found for JavaScript Functions
⚠️ No query file found for JavaScript Calls
⚠️ No query file found for JavaScript Complexity
🔍 Loading JavaScript Highlights query: 2739 chars
✅ Successfully compiled JavaScript Highlights query
🔍 Loading JavaScript Tags query: 2218 chars
✅ Successfully compiled JavaScript Tags query
⚠️ No query file found for JavaScript References
🔍 Loading JavaScript Comments query: 54 chars
✅ Successfully compiled JavaScript Comments query
⚠️ No query file found for TypeScript Imports
⚠️ No query file found for TypeScript Functions
⚠️ No query file found for TypeScript Calls
⚠️ No query file found for TypeScript Complexity
🔍 Loading TypeScript Highlights query: 515 chars
✅ Successfully compiled TypeScript Highlights query
🔍 Loading TypeScript Tags query: 573 chars
✅ Successfully compiled TypeScript Tags query
⚠️ No query file found for TypeScript References
🔍 Loading TypeScript Comments query: 54 chars
✅ Successfully compiled TypeScript Comments query
⚠️ No query file found for Java Imports
⚠️ No query file found for Java Functions
⚠️ No query file found for Java Calls
⚠️ No query file found for Java Complexity
🔍 Loading Java Highlights query: 2064 chars
✅ Successfully compiled Java Highlights query
🔍 Loading Java Tags query: 499 chars
✅ Successfully compiled Java Tags query
⚠️ No query file found for Java References
🔍 Loading Java Comments query: 78 chars
✅ Successfully compiled Java Comments query
📋 Query Engine Initialized:
   Loaded 5 parsers
   Loaded 21 queries
   - JavaScript Tags query loaded
   - Java Highlights query loaded
   - JavaScript Highlights query loaded
   - JavaScript Comments query loaded
   - Rust Tags query loaded
   - Rust Comments query loaded
   - Python Comments query loaded
   - Python Functions query loaded
   - TypeScript Tags query loaded
   - Python Tags query loaded
   - Python Highlights query loaded
   - Rust Functions query loaded
   - TypeScript Highlights query loaded
   - TypeScript Comments query loaded
   - Rust Complexity query loaded
   - Rust Imports query loaded
   - Java Comments query loaded
   - Python Complexity query loaded
   - Python Calls query loaded
   - Rust Calls query loaded
   - Java Tags query loaded
🧠 Running narrator on 3 files in batch...
🔍 DEBUG: Found 4 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/lib.rs
🔍 DEBUG: Bullet text length: 445 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/lib.rs
🔍 DEBUG: Found 13 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/health_score.rs
🔍 DEBUG: Bullet text length: 542 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/health_score.rs
🔍 DEBUG: Found 38 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/pipeline.rs
🔍 DEBUG: Bullet text length: 1758 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/pipeline.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 3 total files (3 from codehud-analysis)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-analysis...
🤖 Analyzing 3 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (3 files)...
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (1/3) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/lib.rs
Language: rust
Comments found: 6

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Analysis - Pipeline and Rendering System
Line 3: ! This crate provides the analysis pipeline and rendering system for CodeHUD,
Line 4: ! implementing both direct and legacy analysis modes with comprehensive
Line 5: ! markdown export capabilities.
Line 12: Re-export main types for convenience
Line 19: Result type for analysis operations

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1020 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (2/3) - health_score.rs...🔍 DEBUG PROMPT for health_score.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/health_score.rs
Language: rust
Comments found: 40

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/health_score.rs
Language: rust
Module name: health_score

COMMENTS TO ANALYZE:
Line 1: ! Health Score Calculation - Exact Python Algorithm Implementation
Line 3: ! This module implements the health score calculation system to match
Line 4: ! Python algorithms exactly as required by zero-degradation plan.
Line 10: Health score calculator matching Python HealthScoreCalculator
Line 19: Complete health score result matching Python structure
Line 32: Complexity metrics for health calculation
Line 44: Issue severity levels matching Python classification
Line 54: Security vulnerability types
Line 64: Performance hotspot data
Line 76: Default weights matching Python implementation
Line 87: Create new health score calculator with custom weights
Line 102: Calculate complete health score from analysis data
Line 107: Extract metrics from analysis data
Line 113: Calculate individual scores using exact Python algorithms
Line 119: Calculate weighted overall score (exact Python formula)
Line 127: Create score breakdown
Line 134: Count critical issues
Line 144: Generate recommendations based on scores
Line 165: Calculate functionality score (exact Python algorithm)
Line 195: Calculate maintainability score (exact Python algorithm)
Line 202: Cyclomatic complexity penalty (Python thresholds)
Line 209: Cognitive complexity penalty
Line 214: Function length penalty
Line 219: Maximum function complexity penalty
Line 227: Calculate security score (exact Python algorithm)
Line 253: Calculate performance score (exact Python algorithm)
Line 265: Penalty based on complexity and execution frequency
Line 269: Additional penalty for high memory usage
Line 278: Extract complexity metrics from analysis data
Line 314: Extract issues from analysis data
Line 324: Combine all issue types
Line 346: Extract vulnerabilities from analysis data
Line 382: Extract performance hotspots from analysis data
Line 416: Generate health recommendations based on scores
Line 466: No issues should give perfect score
Line 470: Critical issues should heavily penalize
Line 483: Low complexity should give high score
Line 497: High complexity should penalize
Line 509: Should be heavily penalized

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2789 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (3/3) - pipeline.rs...🔍 DEBUG PROMPT for pipeline.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/pipeline.rs
Language: rust
Comments found: 55

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis/src/pipeline.rs
Language: rust
Module name: pipeline

COMMENTS TO ANALYZE:
Line 1: ! Direct Analysis Pipeline - Core orchestration matching Python direct_pipeline.py
Line 3: ! This module implements the direct analysis pipeline that coordinates
Line 4: ! all extractors and produces comprehensive analysis results with zero degradation
Line 5: ! from the Python implementation.
Line 32: Direct analysis pipeline orchestrating all extractors
Line 42: Analysis result from the direct pipeline
Line 57: Metadata about the analysis execution
Line 68: Performance metrics for individual extractors
Line 78: System information during analysis
Line 90: Create a new direct analysis pipeline
Line 101: Initialize all extractors as enabled by default
Line 118: 5 minutes default
Line 119: Match Python default
Line 123: Configure which extractors to run
Line 125: Disable all extractors first
Line 130: Enable specified extractors
Line 138: Set execution timeout
Line 144: Enable or disable parallel execution
Line 150: Run the direct analysis pipeline
Line 182: Run extractors based on configuration
Line 189: Calculate health score using extracted data (Python-compatible)
Line 193: Default fallback score
Line 203: Calculate final metrics
Line 217: Run extractors in parallel for maximum performance
Line 225: Spawn tasks for each enabled extractor
Line 275: Run extractors sequentially for debugging and reliability
Line 315: Run a single extractor and measure performance
Line 361: This is handled by a different system, return empty for now
Line 365: Use the enhanced query engine for tree-sitter analysis
Line 370: Convert serde_json::Value to HashMap
Line 383: Return empty result on failure
Line 389: Return empty result on failure
Line 401: TODO: Track this in extractors
Line 416: Create initial analysis metadata
Line 441: Calculate analysis coverage percentage
Line 453: Get current memory usage in bytes (placeholder implementation)
Line 455: TODO: Implement actual memory usage tracking
Line 459: Get total system memory in GB (placeholder implementation)
Line 461: TODO: Implement actual system memory detection
Line 465: Get available system memory in GB (placeholder implementation)
Line 467: TODO: Implement actual available memory detection
Line 471: Get disk space in GB for the given path (placeholder implementation)
Line 473: TODO: Implement actual disk space detection
Line 478: Export analysis results to various formats
Line 482: Export analysis results to JSON
Line 488: Export analysis results to YAML
Line 494: Export analysis results to comprehensive markdown report
Line 548: Errors and Warnings
Line 565: Detailed Results (summary of each view)
Line 570: Extract summary information from each view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3327 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (3/3) - Complete!
✅ Phase 2 complete: 3 files analyzed with enhanced context
📄 File summaries updated: 3 total files (3 from codehud-analysis)
📄 Analysis metadata updated: 1 crates processed
🔍 DEBUG: Crate path for codehud-cli: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli
🔍 Processing 4 files from crate codehud-cli
🔍 DEBUG: First 5 files discovered for crate codehud-cli:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/main.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/llm.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/direct.rs
  4. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/data.rs
🧠 Running narrator on 4 files in batch...
🔍 DEBUG: Found 65 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/main.rs
🔍 DEBUG: Bullet text length: 2203 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/main.rs
🔍 DEBUG: Found 19 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/llm.rs
🔍 DEBUG: Bullet text length: 861 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/llm.rs
🔍 DEBUG: Found 18 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/direct.rs
🔍 DEBUG: Bullet text length: 814 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/direct.rs
🔍 DEBUG: Found 19 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/data.rs
🔍 DEBUG: Bullet text length: 777 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/data.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 7 total files (4 from codehud-cli)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-cli...
🤖 Analyzing 4 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (4 files)...
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (1/4) - main.rs...🔍 DEBUG PROMPT for main.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/main.rs
Language: rust
Comments found: 141

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/main.rs
Language: rust
Module name: main

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Main CLI Entry Point
Line 3: ! Main entry point providing unified interface with 7+ commands matching Python exactly
Line 21: Run comprehensive codebase analysis with visualization
Line 23: Path to codebase to analyze
Line 26: View type for analysis output
Line 30: Analysis pipeline to use
Line 34: Output file path for results
Line 38: Focus on specific entity (file, class, function)
Line 42: Configuration file path
Line 46: Enable debug mode
Line 50: Files to analyze (glob patterns)
Line 55: Export visualizations to text files (no TUI required)
Line 57: Path to codebase to analyze
Line 60: Output directory for visualization files
Line 64: View types to export (comma-separated: quality,security,topology,dependencies)
Line 69: Launch interactive LLM interface for AI-powered analysis
Line 71: Path to codebase
Line 74: LLM backend to use
Line 78: Model to use for analysis
Line 82: Enable GPU acceleration
Line 86: Session file for conversation persistence
Line 91: Launch graphical user interface
Line 93: Path to codebase
Line 96: Initial view to display
Line 100: Window geometry (WIDTHxHEIGHT+X+Y)
Line 104: Enable fullscreen mode
Line 109: Generate call graph visualization
Line 111: Path to codebase to analyze (optional - uses sample data if not provided)
Line 113: Output format (text, terminal, or both)
Line 118: Interactive file editing with AI assistance
Line 120: Path to codebase
Line 123: File to edit
Line 126: Description of changes to make
Line 129: Backup before editing
Line 133: Editor to use
Line 138: Issues inspection and management
Line 140: Path to codebase
Line 143: Issue category to focus on
Line 151: Auto-fix issues where possible
Line 155: Generate issue report
Line 160: Developer notes and fix tracking
Line 162: Path to codebase
Line 165: Add new note
Line 169: List all notes
Line 182: Full comprehensive analysis with all views
Line 184: Path to codebase
Line 187: Output directory for all reports
Line 191: Include performance profiling
Line 195: Generate only specified views (comma-separated)
Line 199: Skip cache and force fresh analysis
Line 205: Use the Pipeline type from codehud-core instead of defining our own
Line 207: Extract real call graph data from codebase using Tree-sitter query engine
Line 229: Get query engine instance
Line 232: Track all function definitions with line ranges
Line 235: Track all function calls with their locations
Line 236: file -> calls
Line 238: Known stdlib/external patterns to filter out
Line 257: Walk through all source files
Line 265: Only process Rust and Python files for now
Line 272: Extract function definitions with line ranges
Line 293: Extract function calls with line numbers
Line 302: Filter out obvious stdlib/external calls
Line 324: Build qualified name index for fast lookup
Line 330: Match calls to their containing functions using line numbers
Line 334: Get functions defined in this file
Line 341: Find which function contains this call by line number
Line 347: Try to resolve callee to a known internal function
Line 349: Both caller and callee are known internal functions
Line 363: Extract a clean module name from a file path
Line 369: Handle special cases
Line 371: Try to get the parent directory name for context
Line 375: Remove "codehud-" prefix
Line 414: Generate specific view
Line 422: Save to output file if specified
Line 431: Run comprehensive analysis for other views or fallback
Line 452: Generate view-specific output
Line 456: Save to output file if specified
Line 459: Focus mode - output specific view
Line 462: Full mode - output complete analysis
Line 524: Save to file
Line 624: Resolve file path relative to codebase if needed
Line 636: Create backup if requested
Line 645: Show description if provided
Line 650: Run analysis on the file first
Line 653: Run quality analysis on the specific file
Line 658: Extract metrics for this specific file
Line 693: Run analysis again to show changes
Line 746: Run security and quality analysis to find issues
Line 755: Extract issues from analysis results
Line 758: Extract security issues
Line 765: Filter by category if specified
Line 772: Filter by severity if specified
Line 784: Extract quality issues
Line 791: Filter by category if specified
Line 798: Filter by severity if specified
Line 812: Group issues by category and severity
Line 831: Display detailed issues
Line 894: Notes file path
Line 897: Load existing notes
Line 906: Add new note
Line 923: List all notes
Line 977: Show summary by default
Line 984: Group by category
Line 1020: Create output directory
Line 1026: Determine which views to generate
Line 1041: Default: all available views
Line 1049: Run comprehensive analysis first
Line 1055: Save main analysis results
Line 1060: Generate each view
Line 1068: Save view data
Line 1077: Generate summary report
Line 1093: Generate human-readable summary
Line 1160: Export visualizations to text and JSON files
Line 1167: Create output directory
Line 1170: Parse view types
Line 1192: Run analysis for each view type
Line 1214: Run analysis for a specific view type and export results
Line 1216: Use the existing direct pipeline with default config
Line 1222: Convert to core AnalysisResult for viz engine
Line 1225: Set view data from pipeline result
Line 1229: Create viz engine
Line 1236: Export as JSON
Line 1242: Export as readable text
Line 1249: Show summary in terminal
Line 1255: Format visualization as readable text
Line 1313: Show visualization summary in terminal

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6150 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (2/4) - llm.rs...🔍 DEBUG PROMPT for llm.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/llm.rs
Language: rust
Comments found: 83

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/llm.rs
Language: rust
Module name: llm

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD LLM CLI - LLM-Powered Features
Line 3: ! Interactive LLM interface for AI-powered code analysis, bug fixing,
Line 4: ! and development assistance. Matches Python cli_llm.py exactly.
Line 22: Subcommand to execute
Line 26: LLM backend to use
Line 30: Model name to use for analysis
Line 34: Enable GPU acceleration
Line 38: Temperature for LLM responses (0.0-2.0)
Line 42: Configuration file path
Line 46: Enable debug mode
Line 53: Extract and analyze comments for codebase understanding
Line 55: Path to the codebase directory to analyze
Line 58: Output directory for analysis files
Line 62: Skip system summary generation (faster for large codebases)
Line 66: Focus on specific file extensions
Line 70: Use cached comment extraction if available
Line 74: Maximum tokens per file analysis
Line 78: Maximum tokens for system summary
Line 83: Interactive comment exploration mode
Line 85: Path to the codebase directory to explore
Line 88: Start with specific file or directory
Line 93: Generate documentation from comment analysis
Line 95: Path to the codebase directory
Line 98: Template for documentation generation
Line 102: Output format (markdown, html, json)
Line 106: Output file for generated documentation
Line 111: Interactive LLM session (legacy mode)
Line 113: Path to the codebase directory to analyze
Line 116: Session file for conversation persistence
Line 120: Initial view context for the LLM
Line 124: Maximum tokens for responses
Line 128: Enable constitutional AI guardrails
Line 132: Enable bug fixing mode with high success rate
Line 136: Enable code generation mode
Line 141: Scan a single file with FSM interface
Line 143: File path to scan (will show picker if not provided)
Line 147: Scan an entire project with FSM interface
Line 149: Project directory to scan (will show picker if not provided)
Line 152: Use structural insights only mode (ultra token-efficient)
Line 168: Local Ollama backend (recommended)
Line 172: OpenHands external integration
Line 196: Validate temperature range
Line 259: Handle comment analysis command (implements the three-phase workflow)
Line 278: Create processor configuration
Line 302: Create Ollama configuration
Line 305: Create file processor
Line 311: Process the codebase
Line 350: Handle interactive comment exploration
Line 368: TODO: Implement interactive exploration
Line 372: Handle documentation generation
Line 396: TODO: Implement documentation generation
Line 400: Handle interactive LLM session (legacy mode)
Line 424: TODO: Implement interactive session
Line 428: Validate codebase path
Line 441: Handle single file scan command using FSM
Line 449: Create processor configuration
Line 466: Single file mode
Line 473: Create Ollama configuration
Line 476: Create FSM (scan file doesn't use insights_only mode)
Line 483: Create CLI interface
Line 486: Execute scan file command
Line 489: Check if we need file picker
Line 501: If we have a file path, process it directly
Line 503: Process the file directly
Line 542: Handle project scan command using FSM
Line 554: Create processor configuration for project scanning
Line 558: Slightly smaller per file for project mode
Line 559: Larger system summary for projects
Line 571: Sequential for project context accumulation
Line 578: Create Ollama configuration
Line 588: Create CLI interface
Line 591: Execute scan project command - the FSM handles everything through events
Line 594: Wait for the FSM to complete hierarchical processing
Line 609: Exit cleanly after completion
Line 617: Still processing, wait a bit and check again
Line 644: Valid temperatures should work

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4266 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (3/4) - direct.rs...🔍 DEBUG PROMPT for direct.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/direct.rs
Language: rust
Comments found: 34

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/direct.rs
Language: rust
Module name: direct

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Direct CLI - Direct Analysis Pipeline
Line 3: ! Enhanced CLI supporting both direct extraction and legacy CLI analysis,
Line 4: ! matching Python cli_direct.py exactly.
Line 19: Path to the codebase directory to analyze (optional - interactive picker if not provided)
Line 22: Path to CodeHUD configuration file
Line 26: Focus on specific entity (file, function, or class)
Line 30: Initial view to display
Line 34: Analysis pipeline to use
Line 38: Enable debug mode
Line 46: Fast AST-based analysis (recommended)
Line 48: CLI tool-based analysis (comprehensive but slower)
Line 50: Automatically choose best pipeline
Line 59: Auto maps to Hybrid
Line 82: Handle missing codebase path - launch interactive picker
Line 97: TODO: Implement interactive directory picker
Line 142: TODO: Implement focus functionality
Line 145: TODO: Launch the polymorphic HUD interface
Line 152: Run the direct analysis pipeline
Line 156: Create core configuration
Line 159: Configure based on CLI arguments
Line 161: Limit for debug mode
Line 164: Configure specific view if requested
Line 172: Create and configure pipeline
Line 208: Export to JSON
Line 214: Export to Markdown
Line 221: Display view-specific information
Line 225: Extract key metrics from each view
Line 246: Show focus information if applicable
Line 249: TODO: Implement focus-specific analysis

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2028 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (4/4) - data.rs...🔍 DEBUG PROMPT for data.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/data.rs
Language: rust
Comments found: 47

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli/src/data.rs
Language: rust
Module name: data

COMMENTS TO ANALYZE:
Line 1: ! Data Analysis CLI - Data export and manipulation interface
Line 3: ! This module provides command-line interfaces for data analysis operations
Line 4: ! matching Python cli_data.py functionality exactly.
Line 13: Main entry point for data CLI
Line 38: Build the CLI command structure
Line 185: Handle export command
Line 197: Create output path if not specified
Line 207: TODO: Implement actual export logic matching Python behavior
Line 208: This would involve:
Line 209: 1. Loading analysis data from input
Line 210: 2. Filtering by specified views if provided
Line 211: 3. Converting to target format
Line 212: 4. Optionally compressing
Line 213: 5. Writing to output
Line 228: Write export data
Line 232: TODO: Implement compression
Line 244: TODO: Implement CSV export
Line 249: TODO: Implement Parquet export
Line 262: Handle import command
Line 272: TODO: Implement actual import logic matching Python behavior
Line 273: This would involve:
Line 274: 1. Reading data from source in specified format
Line 275: 2. Validating data structure
Line 276: 3. Converting to internal format
Line 277: 4. Optionally merging with existing analysis
Line 283: Handle convert command
Line 294: TODO: Implement actual conversion logic
Line 295: This would involve:
Line 296: 1. Reading data in source format
Line 297: 2. Converting to internal representation
Line 298: 3. Writing in target format
Line 304: Handle validate command
Line 314: TODO: Implement actual validation logic
Line 315: This would involve:
Line 316: 1. Reading the file
Line 317: 2. Checking basic structure
Line 318: 3. Validating against schema if provided
Line 319: 4. Reporting validation results
Line 329: Handle merge command
Line 339: TODO: Implement actual merge logic
Line 340: This would involve:
Line 341: 1. Reading all input files
Line 342: 2. Applying merge strategy
Line 343: 3. Resolving conflicts
Line 344: 4. Writing merged result

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2579 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (4/4) - Complete!
✅ Phase 2 complete: 4 files analyzed with enhanced context
📄 File summaries updated: 7 total files (4 from codehud-cli)
📄 Analysis metadata updated: 2 crates processed
🔍 DEBUG: Crate path for codehud-core: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core
🔍 Processing 52 files from crate codehud-core
🔍 DEBUG: First 5 files discovered for crate codehud-core:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/semantic_nodes.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/mod.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs
  4. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/view_types.rs
  5. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/dependencies.rs
🧠 Running narrator on 52 files in batch...
🔍 DEBUG: Found 13 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/semantic_nodes.rs
🔍 DEBUG: Bullet text length: 404 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/semantic_nodes.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/mod.rs
🔍 DEBUG: Bullet text length: 413 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/mod.rs
🔍 DEBUG: Found 10 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs
🔍 DEBUG: Bullet text length: 330 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs
🔍 DEBUG: Found 10 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/view_types.rs
🔍 DEBUG: Bullet text length: 317 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/view_types.rs
🔍 DEBUG: Found 28 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/dependencies.rs
🔍 DEBUG: Bullet text length: 1211 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/dependencies.rs
🔍 DEBUG: Found 52 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/runtime_profiler.rs
🔍 DEBUG: Bullet text length: 2206 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/runtime_profiler.rs
🔍 DEBUG: Found 37 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/topology.rs
🔍 DEBUG: Bullet text length: 1681 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/topology.rs
🔍 DEBUG: Found 28 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs
🔍 DEBUG: Bullet text length: 1204 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs
🔍 DEBUG: Found 42 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs
🔍 DEBUG: Bullet text length: 1876 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs
🔍 DEBUG: Found 29 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs
🔍 DEBUG: Bullet text length: 1148 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs
🔍 DEBUG: Found 29 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs
🔍 DEBUG: Bullet text length: 1106 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs
🔍 DEBUG: Found 33 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/quality.rs
🔍 DEBUG: Bullet text length: 1442 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/quality.rs
🔍 DEBUG: Found 30 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/testing.rs
🔍 DEBUG: Bullet text length: 1194 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/testing.rs
🔍 DEBUG: Found 28 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs
🔍 DEBUG: Bullet text length: 1220 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs
🔍 DEBUG: Found 21 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/issues.rs
🔍 DEBUG: Bullet text length: 964 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/issues.rs
🔍 DEBUG: Found 36 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs
🔍 DEBUG: Bullet text length: 1403 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs
🔍 DEBUG: Found 7 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/lib.rs
🔍 DEBUG: Bullet text length: 853 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/lib.rs
🔍 DEBUG: Found 4 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_security.rs
🔍 DEBUG: Bullet text length: 228 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_security.rs
🔍 DEBUG: Found 4 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs
🔍 DEBUG: Bullet text length: 225 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs
🔍 DEBUG: Found 4 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_dependencies.rs
🔍 DEBUG: Bullet text length: 240 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_dependencies.rs
🔍 DEBUG: Found 4 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs
🔍 DEBUG: Bullet text length: 376 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/complexity_thresholds.rs
🔍 DEBUG: Bullet text length: 138 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/complexity_thresholds.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/health_score_thresholds.rs
🔍 DEBUG: Bullet text length: 138 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/health_score_thresholds.rs
🔍 DEBUG: Found 23 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms.rs
🔍 DEBUG: Bullet text length: 1067 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms.rs
🔍 DEBUG: Found 13 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/metrics.rs
🔍 DEBUG: Bullet text length: 418 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/metrics.rs
🔍 DEBUG: Found 14 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms_minimal.rs
🔍 DEBUG: Bullet text length: 632 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms_minimal.rs
🔍 DEBUG: Found 8 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/edges.rs
🔍 DEBUG: Bullet text length: 252 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/edges.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/nodes.rs
🔍 DEBUG: Bullet text length: 184 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/nodes.rs
🔍 DEBUG: Found 26 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/mod.rs
🔍 DEBUG: Bullet text length: 1239 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/mod.rs
🔍 DEBUG: Found 28 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/analyzer.rs
🔍 DEBUG: Bullet text length: 1625 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/analyzer.rs
🔍 DEBUG: Found 26 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/query_engine.rs
🔍 DEBUG: Bullet text length: 1101 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/query_engine.rs
🔍 DEBUG: Found 17 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs
🔍 DEBUG: Bullet text length: 587 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs
🔍 DEBUG: Found 24 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs
🔍 DEBUG: Bullet text length: 806 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs
🔍 DEBUG: Found 21 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs
🔍 DEBUG: Bullet text length: 914 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs
🔍 DEBUG: Found 19 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/coverage.rs
🔍 DEBUG: Bullet text length: 747 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/coverage.rs
🔍 DEBUG: Found 24 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/radon.rs
🔍 DEBUG: Bullet text length: 1036 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/radon.rs
🔍 DEBUG: Found 29 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs
🔍 DEBUG: Bullet text length: 1137 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs
🔍 DEBUG: Found 18 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mypy.rs
🔍 DEBUG: Bullet text length: 703 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mypy.rs
🔍 DEBUG: Found 31 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mod.rs
🔍 DEBUG: Bullet text length: 1225 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mod.rs
🔍 DEBUG: Found 26 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_audit.rs
🔍 DEBUG: Bullet text length: 987 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_audit.rs
🔍 DEBUG: Found 21 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs
🔍 DEBUG: Bullet text length: 885 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs
🔍 DEBUG: Found 19 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/vulture.rs
🔍 DEBUG: Bullet text length: 720 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/vulture.rs
🔍 DEBUG: Found 25 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ripgrep.rs
🔍 DEBUG: Bullet text length: 1180 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ripgrep.rs
🔍 DEBUG: Found 23 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/bandit.rs
🔍 DEBUG: Bullet text length: 920 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/bandit.rs
🔍 DEBUG: Found 21 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/clippy.rs
🔍 DEBUG: Bullet text length: 708 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/clippy.rs
🔍 DEBUG: Found 20 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/git.rs
🔍 DEBUG: Bullet text length: 886 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/git.rs
🔍 DEBUG: Found 30 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/cache/mod.rs
🔍 DEBUG: Bullet text length: 1196 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/cache/mod.rs
🔍 DEBUG: Found 7 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/view_generator.rs
🔍 DEBUG: Bullet text length: 321 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/view_generator.rs
🔍 DEBUG: Found 37 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/mod.rs
🔍 DEBUG: Bullet text length: 2167 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/mod.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/health_calculator.rs
🔍 DEBUG: Bullet text length: 240 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/health_calculator.rs
🔍 DEBUG: Found 8 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/pipeline.rs
🔍 DEBUG: Bullet text length: 365 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/pipeline.rs
🔍 DEBUG: Found 1 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/benches/extraction_benchmarks.rs
🔍 DEBUG: Bullet text length: 92 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/benches/extraction_benchmarks.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 59 total files (52 from codehud-core)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-core...
🤖 Analyzing 52 files with enhanced context and improved token limits...
📦 Processing batch 1/11 (5 files)...
🤖 Analyzing: [░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   1% (1/52) - semantic_nodes.rs...🔍 DEBUG PROMPT for semantic_nodes.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/semantic_nodes.rs
Language: rust
Comments found: 43

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/semantic_nodes.rs
Language: rust
Module name: semantic_nodes

COMMENTS TO ANALYZE:
Line 1: ! Semantic node models for code analysis and graph construction.
Line 3: ! This module provides data structures for representing code elements
Line 4: ! and their relationships in a semantic graph structure.
Line 10: Function signature with comprehensive semantic information.
Line 12: This struct exactly matches the Python FunctionSignature dataclass
Line 13: to ensure complete compatibility in function analysis.
Line 29: Extensions for CodeHUD integration
Line 37: Create a new function signature with required fields
Line 65: Check if function has side effects
Line 70: Check if function is a property/getter based on decorators
Line 75: Get function signature as string (Python-like format)
Line 79: Add regular arguments
Line 101: Class definition with inheritance and semantic analysis.
Line 103: This struct exactly matches the Python ClassDefinition dataclass
Line 104: to ensure complete compatibility in class analysis.
Line 117: Extensions for CodeHUD
Line 124: Create a new class definition with required fields
Line 146: Check if class inherits from a specific base class
Line 151: Check if class is abstract based on methods or decorators
Line 157: Get total lines of code for the class
Line 163: Universal semantic code node for graph construction.
Line 165: This struct exactly matches the Python SemanticNode dataclass
Line 166: to ensure complete compatibility in semantic analysis.
Line 170: function, class, import, variable, call
Line 175: full qualified path
Line 181: Create a new semantic node
Line 204: Add a relationship to another node
Line 212: Get relationships of a specific type
Line 217: Add metadata entry
Line 222: Check if node is a function
Line 227: Check if node is a class
Line 232: Get the module name from file path
Line 234: Convert file path to module-like name
Line 242: Collection of analysis graphs.
Line 244: This struct represents the graph bundle used throughout CodeHUD
Line 245: for storing various types of analysis graphs.
Line 248: Note: In Rust we'll use petgraph::Graph instead of NetworkX
Line 249: but maintain the same logical structure
Line 261: Create a new empty graph bundle
Line 274: Check if bundle is empty
Line 284: Get total number of nodes across all graphs

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2942 characters
🤖 Analyzing: [█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   3% (2/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/mod.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Data models module for CodeHUD core
Line 3: ! This module contains all data structures used for representing
Line 4: ! code analysis results, semantic information, and visualization data.

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 868 characters
🤖 Analyzing: [██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   5% (3/52) - analysis_result.rs...🔍 DEBUG PROMPT for analysis_result.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs
Language: rust
Comments found: 36

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs
Language: rust
Module name: analysis_result

COMMENTS TO ANALYZE:
Line 1: ! Analysis Result Model
Line 3: ! Complete analysis result structure matching Python implementation exactly
Line 9: Complete analysis result for a codebase - matches Python AnalysisResult exactly
Line 12: Path to the analyzed codebase
Line 14: Number of files that were analyzed
Line 16: Timestamp when analysis was performed
Line 18: Duration of analysis in seconds
Line 21: Core analysis data
Line 22: Overall code metrics
Line 24: Overall health score (0.0 to 100.0)
Line 26: Critical issues that need immediate attention
Line 28: Recommendations for focus areas
Line 31: Direct extraction data (new pipeline)
Line 32: Extracted view data organized by view type
Line 35: Optional detailed data (for legacy pipeline Phase 2+)
Line 36: Parsed file data (optional for legacy pipeline)
Line 38: Graph data (optional for legacy pipeline)
Line 40: Static analysis results (optional for legacy pipeline)
Line 44: Code metrics structure matching Python implementation
Line 47: Total lines of code
Line 49: Lines of executable code (excluding comments/whitespace)
Line 51: Number of functions
Line 53: Number of classes
Line 55: Number of files
Line 57: Average cyclomatic complexity
Line 59: Maximum cyclomatic complexity found
Line 61: Technical debt ratio
Line 63: Code coverage percentage (if available)
Line 87: Create a new analysis result
Line 105: Add a critical issue to the analysis result
Line 110: Add a focus recommendation
Line 115: Set extracted view data for a specific view type
Line 120: Get view data for a specific view type
Line 125: Check if analysis has critical issues
Line 130: Get severity distribution of issues

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2348 characters
🤖 Analyzing: [███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   7% (4/52) - view_types.rs...🔍 DEBUG PROMPT for view_types.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/view_types.rs
Language: rust
Comments found: 19

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/view_types.rs
Language: rust
Module name: view_types

COMMENTS TO ANALYZE:
Line 1: ! Core data models for CodeHUD analysis and visualization.
Line 3: ! This module provides the fundamental data structures used throughout CodeHUD
Line 4: ! for representing code analysis results, visualization types, and semantic information.
Line 6: ! This is a 1:1 translation from Python src/codehud/core/models.py
Line 7: ! to ensure zero degradation in data model behavior.
Line 13: Available visualization view types.
Line 15: This enum exactly matches the Python ViewType enum to ensure
Line 16: complete compatibility across all visualization systems.
Line 28: New view type
Line 29: LLM fix tracking
Line 30: Enhanced tree-sitter semantic analysis
Line 34: Get all available view types
Line 51: Get the string representation matching Python behavior
Line 68: Parse from string, matching Python behavior exactly
Line 86: Get display name for UI
Line 103: Check if this view supports focus functionality
Line 132: Test all view types round-trip correctly
Line 142: Ensure exact string matching with Python enum values
Line 186: Ensure we have all 10 view types from Python

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1780 characters
🤖 Analyzing: [████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   9% (5/52) - dependencies.rs...🔍 DEBUG PROMPT for dependencies.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/dependencies.rs
Language: rust
Comments found: 40

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/dependencies.rs
Language: rust
Module name: dependencies

COMMENTS TO ANALYZE:
Line 1: ! Dependencies Data Extractor - Automatic dependency analysis using tree-sitter queries
Line 3: ! This module extracts comprehensive dependency analysis including:
Line 4: ! - Automatic language detection and parsing
Line 5: ! - Query-based import extraction
Line 6: ! - Dependency graph construction with petgraph
Line 7: ! - Circular dependency detection
Line 8: ! - Coupling metrics calculation
Line 9: ! - Cross-language analysis support
Line 43: "import" or "from_import"
Line 101: Check if this file is supported by our query engine
Line 125: Check if file is supported by query engine
Line 130: Use query engine for automatic analysis
Line 137: Extract import information from query results
Line 144: Convert query results to our format
Line 153: Create import detail
Line 164: Categorize as from_import if it has an item
Line 171: Calculate metrics using the extracted data
Line 305: Old manual AST analyzer removed - now using query engine automatically
Line 311: Get all source files
Line 317: Create a mutable copy for analysis - query engine handles languages automatically
Line 323: Analyze each file
Line 331: Build dependency graph
Line 337: Note: Graph analysis now handled by query engine
Line 339: Categorize as internal vs external
Line 351: Note: from_imports graph analysis now handled by query engine
Line 363: Detect circular dependencies
Line 366: Calculate dependency metrics
Line 369: Analyze coupling strength
Line 372: Graph analysis now integrated with query engine
Line 381: External dependencies analysis
Line 387: Most influential files
Line 498: Sort strong couplings by strength
Line 524: Sort by count
Line 528: Standard library modules
Line 594: Sort by cluster size

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2417 characters
📦 Processing batch 2/11 (5 files)...
🤖 Analyzing: [█████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  11% (6/52) - runtime_profiler.rs...🔍 DEBUG PROMPT for runtime_profiler.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/runtime_profiler.rs
Language: rust
Comments found: 33

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/runtime_profiler.rs
Language: rust
Module name: runtime_profiler

COMMENTS TO ANALYZE:
Line 1: ! Runtime Profiler Data Extractor - Analyzes runtime performance and execution patterns
Line 35: "critical", "major", "minor"
Line 59: "high", "medium", "low"
Line 161: Analyze function complexity as a proxy for runtime cost
Line 172: Default, would be updated with actual profiling
Line 181: Recursively process child nodes
Line 193: Count control flow statements
Line 201: Count function calls (potential performance impact)
Line 204: Count list comprehensions and generators
Line 213: Base time in milliseconds
Line 215: Heuristics for execution time based on code patterns
Line 234: Base memory in MB
Line 236: Heuristics for memory usage
Line 245: Large data operations
Line 260: High execution time bottlenecks
Line 287: High memory usage bottlenecks
Line 316: Sort by impact score (highest first)
Line 331: Estimate resource operations based on function analysis
Line 362: Pattern 1: High-memory functions
Line 381: Pattern 2: CPU-intensive functions
Line 400: Pattern 3: IO-bound operations
Line 423: Try to run Python profiling tools if available
Line 462: Analyze runtime metrics
Line 468: Analyze resource usage
Line 471: Identify execution patterns
Line 474: Try actual profiling

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3121 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  13% (7/52) - topology.rs...🔍 DEBUG PROMPT for topology.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/topology.rs
Language: rust
Comments found: 82

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/topology.rs
Language: rust
Module name: topology

COMMENTS TO ANALYZE:
Line 1: ! Topology Data Extractor
Line 3: ! Extracts codebase topology information including file structure,
Line 4: ! classes, functions, and architectural overview.
Line 6: ! This is a zero-degradation Rust translation of topology_extractor.py
Line 17: Extract codebase topology and architecture data
Line 24: Create a new topology extractor
Line 48: Analyze a single file (Python _analyze_file equivalent)
Line 59: Check if this is a test file
Line 65: Python-specific analysis using tree-sitter
Line 90: Basic analysis for other file types
Line 99: Analyze Python file using tree-sitter AST (Python _analyze_python_file equivalent)
Line 106: Initialize tree-sitter parser for Python
Line 112: Parse the file
Line 128: Analyze JavaScript/TypeScript file using regex-based parsing
Line 136: Function detection patterns
Line 146: Class detection pattern
Line 220: Extract JavaScript function parameters
Line 235: Extract JavaScript return type from TypeScript annotations
Line 248: Extract JavaScript extends clause
Line 260: Analyze Rust file using regex-based parsing
Line 264: Structs/enums in Rust
Line 268: Function detection patterns
Line 276: Struct/enum detection patterns (treating as classes)
Line 314: Detect structs/enums as classes
Line 329: Detect use statements/dependencies
Line 357: Extract Rust function parameters
Line 365: Extract parameter name before colon
Line 379: Extract Rust return type
Line 388: Handle single line functions
Line 398: Extract Rust derive traits as base classes
Line 413: Calculate basic complexity based on control flow keywords
Line 425: Minimum complexity of 1
Line 430: Check if a file is a test file based on naming conventions
Line 442: Extract function name from a function definition line
Line 444: Simple pattern: "def function_name(" or "async def function_name("
Line 455: Extract class name from a class definition line
Line 457: Simple pattern: "class ClassName:" or "class ClassName("
Line 465: Extract dependency from import statement
Line 474: from module import ...
Line 483: Calculate summary statistics (Python _calculate_summary equivalent)
Line 492: Calculate language distribution
Line 500: Calculate complexity distribution
Line 520: Analyze project structure (Python _analyze_project_structure equivalent)
Line 530: Count files per directory
Line 546: Calculate coupling metrics (Python _calculate_coupling equivalent)
Line 557: Find most coupled files
Line 581: Get all source files
Line 584: Analyze each file
Line 593: Collect classes and functions
Line 614: Calculate summary statistics
Line 617: Analyze project structure
Line 620: Calculate coupling metrics
Line 623: Convert to the expected format
Line 649: Data structures matching Python implementation
Line 716: Tree-sitter AST analyzer for Python files (equivalent to PythonASTAnalyzer in Python)
Line 756: Recursively visit children
Line 777: Basic complexity, will be updated by complexity analysis
Line 780: TODO: Extract return type annotation
Line 815: Extract base classes
Line 821: Extract methods (will be updated when we visit function definitions)
Line 826: Will be populated by function visitor
Line 837: Extract the root module name
Line 846: Extract the root module name

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5111 characters
🤖 Analyzing: [███████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  15% (8/52) - performance.rs...🔍 DEBUG PROMPT for performance.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs
Language: rust
Comments found: 24

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs
Language: rust
Module name: performance

COMMENTS TO ANALYZE:
Line 144: Complex functions with high performance impact
Line 182: File I/O operations without proper handling
Line 230: Large string concatenations
Line 243: List comprehensions vs loops
Line 275: Penalize complex functions
Line 282: Penalize nested loops
Line 289: Penalize expensive operations
Line 292: Penalize recursive calls without termination checks
Line 381: Visit child nodes
Line 394: Calculate complexity and lines
Line 442: Detect expensive operations
Line 466: Check for recursive calls
Line 482: Add complexity for control structures
Line 519: Simple check for .append() calls within the loop
Line 525: Simple heuristic: look for repeated expensive function calls
Line 528: Count occurrences of potentially expensive operations
Line 562: Simplified check - in a real implementation, would analyze surrounding context

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2739 characters
🤖 Analyzing: [████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  17% (9/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs
Language: rust
Comments found: 28

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Data extractors for CodeHUD analysis
Line 3: ! This module provides the 11+ data extractors that match the Python
Line 4: ! implementation exactly for zero degradation compatibility.
Line 12: Base trait for all CodeHUD data extractors
Line 14: Matches the Python BaseDataExtractor abstract class exactly
Line 16: Extract raw data for this analysis type
Line 19: Get extractor type name
Line 22: Get codebase path
Line 25: Get extraction timestamp
Line 28: Get common metadata for all extractors
Line 42: Extract data and include metadata (Python extract_with_metadata equivalent)
Line 63: Get source files matching given extensions (Python _get_source_files equivalent)
Line 83: Skip if any parent directory is excluded
Line 94: Check file extension
Line 106: Calculate basic metrics for a file (Python _calculate_file_metrics equivalent)
Line 161: Result of data extraction with metadata
Line 170: Metadata for data extraction
Line 186: File metrics structure matching Python implementation
Line 198: Get Python files excluding backup and cache directories
Line 199: Static method equivalent from Python BaseDataExtractor
Line 215: Skip if any parent directory is excluded
Line 226: Check for .py extension
Line 235: Module declarations for individual extractors
Line 248: Re-export the main extractors for convenience
Line 271: Create some test files
Line 285: Create excluded directory with Python file
Line 290: Create regular Python file

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3335 characters
🤖 Analyzing: [█████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  19% (10/52) - flow.rs...🔍 DEBUG PROMPT for flow.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs
Language: rust
Comments found: 22

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs
Language: rust
Module name: flow

COMMENTS TO ANALYZE:
Line 1: ! Flow Data Extractor - Analyzes data flow patterns in Python codebases
Line 20: function, variable, class, module
Line 32: assignment, function_call, parameter, return_value
Line 188: Recursively process child nodes
Line 349: Pattern 1: Deep nested function calls
Line 361: Pattern 2: Circular data dependencies
Line 373: Pattern 3: Unused variables
Line 397: Threshold for deep nesting
Line 407: Simplified circular dependency detection
Line 418: Simple cycle detection using DFS
Line 421: Get file path from edges involving this node
Line 456: Count variable usage
Line 463: Find variables used only once (likely unused)
Line 478: Group nodes by variable name and file
Line 486: Analyze lifecycle for each variable
Line 503: Determine scope depth (simplified)
Line 537: Analyze data flow
Line 543: Analyze variable lifecycles

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2722 characters
📦 Processing batch 3/11 (5 files)...
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  21% (11/52) - orphaned_files.rs...🔍 DEBUG PROMPT for orphaned_files.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d
- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs
Language: rust
Comments found: 30

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs
Language: rust
Module name: orphaned_files

COMMENTS TO ANALYZE:
Line 91: Initialize all files
Line 104: Analyze imports for each file
Line 109: Check if file has main function
Line 116: Map imports to actual files
Line 121: Add to usage tracking
Line 158: Extract the module path from use declaration
Line 170: Visit child nodes
Line 179: Try to match import to actual file
Line 187: Check if import matches directory structure
Line 205: Check if file is likely an entry point based on naming conventions
Line 219: Check if file has executable permissions (Unix-like systems)
Line 227: On non-Unix systems, check for shebang or entry point patterns
Line 243: Threshold for considering a file orphaned
Line 265: Sort by confidence score (highest first)
Line 274: No imports from other files
Line 279: Not an entry point
Line 289: Reduce confidence for special file types
Line 291: Tests might not be imported but are still needed
Line 295: Config files often aren't imported
Line 299: Documentation files aren't imported
Line 302: Small files might be utilities
Line 304: Files smaller than 1KB
Line 385: Less than 5 meaningful lines
Line 403: Analyze file usage patterns
Line 406: Identify orphaned files
Line 416: Calculate file usage statistics

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4180 characters
🤖 Analyzing: [███████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  23% (12/52) - quality.rs...🔍 DEBUG PROMPT for quality.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d
- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/quality.rs
Language: rust
Comments found: 88

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/quality.rs
Language: rust
Module name: quality

COMMENTS TO ANALYZE:
Line 1: ! Quality Data Extractor - Code quality metrics and health scores
Line 137: Basic line analysis
Line 153: Run external tools analysis on this file
Line 223: Count methods in class
Line 248: Recursively analyze children
Line 305: Analyze Rust-specific quality patterns
Line 307: Count unsafe blocks (negative impact on quality)
Line 309: Unsafe code increases complexity
Line 311: Count Result<T, E> usage (positive pattern)
Line 314: Count Option<T> usage (positive pattern)
Line 317: Count unwrap() usage (negative pattern - should use proper error handling)
Line 320: Count expect() usage (better than unwrap but still not ideal)
Line 323: Count ? operator usage (positive pattern for error handling)
Line 326: Count lifetime annotations (indicates complex borrowing)
Line 329: Count trait implementations (positive pattern)
Line 332: Store Rust-specific metrics
Line 346: Enhanced complexity algorithm for Rust including Rust-specific patterns
Line 352: Average function complexity (base algorithm)
Line 356: Penalize high individual complexities (exact Python formula)
Line 361: Nesting depth penalty (exact Python formula)
Line 368: Rust-specific complexity adjustments
Line 372: Unsafe blocks significantly increase complexity
Line 375: Excessive unwrap() calls increase complexity (should use proper error handling)
Line 378: Lifetime annotations indicate borrowing complexity
Line 381: Positive adjustments for good Rust patterns (reduce complexity score)
Line 382: ? operator is good
Line 383: Good error handling
Line 390: Final complexity score (enhanced for Rust)
Line 395: CRITICAL: Exact Python maintainability algorithm for zero-degradation compliance
Line 397: Base score from lines of code (exact Python formula)
Line 400: Complexity penalty (exact Python formula)
Line 403: Comment bonus (exact Python formula)
Line 406: Function size penalty (exact Python formula)
Line 411: Calculate final score (exact Python formula)
Line 414: Return score clamped to 0-100 range (exact Python behavior)
Line 524: CRITICAL: Exact Python algorithm implementation for zero-degradation compliance
Line 527: Weight different factors (exact Python values)
Line 533: Calculate component scores exactly as Python
Line 539: Complexity score (inverted - lower is better, exact Python formula)
Line 546: Issues score (inverted - fewer is better, exact Python formula)
Line 553: Documentation score (exact Python formula)
Line 558: Cap at 100
Line 560: Calculate weighted score (exact Python formula)
Line 566: Determine grade and status (exact Python thresholds)
Line 580: Round to 1 decimal place like Python
Line 595: CRITICAL: Only analyze Rust files with external tools
Line 601: Run ruff analysis - CRITICAL for zero-degradation compliance
Line 623: Ruff failed, log but continue
Line 628: Run pylint analysis - CRITICAL for zero-degradation compliance
Line 651: Pylint failed, log but continue
Line 656: TODO: Run bandit security analysis - CRITICAL for zero-degradation compliance
Line 657: Temporarily disabled to get basic ruff/pylint working first
Line 658: match self.external_tools.bandit_integration.analyze_file(file_path).await { Ok(bandit_result) => { for issue in bandit_result.issues { issues.push(json!({ "type": "security_issue", "severity": issue.issue_severity.to_lowercase(), "confidence": issue.issue_confidence.to_lowercase(), "message": issue.issue_text, "line": issue.line_number, "tool": "bandit", "test_id": issue.test_id, "test_name": issue.test_name, "code": issue.code, "file": issue.filename })); } } Err(e) => { // Bandit failed, log but continue println!("Bandit analysis failed for {}: {}", file_path.display(), e); } }
Line 683: TODO: Add mypy type checking integration
Line 684: TODO: Add radon complexity analysis integration
Line 693: Run ruff analysis
Line 694: External tool integration placeholder - actual integration will be async
Line 698: Run other tools as they become available
Line 707: Get all source files
Line 710: Analyze each file
Line 714: Create a mutable copy for analysis
Line 727: For now, skip async external tool analysis to avoid runtime issues
Line 728: TODO: Refactor BaseDataExtractor trait to support async methods
Line 741: Calculate comment ratio for the analyzer (exact Python formula)
Line 750: Analyze Rust-specific patterns
Line 757: Add external tool analysis - CRITICAL for zero-degradation compliance
Line 760: TODO: External tool integration per file - requires async trait support
Line 761: For now, skip file-level external tool integration to avoid runtime conflicts
Line 762: External tools are run at the codebase level instead
Line 785: Add Rust-specific metrics if available
Line 798: Calculate Rust quality score
Line 802: Penalize unsafe code heavily
Line 805: Penalize unwrap() usage
Line 808: Slightly penalize expect() usage (better than unwrap but not ideal)
Line 811: Reward good error handling patterns
Line 815: Neutral for lifetime annotations (complexity but necessary)
Line 816: Reward trait implementations (good design)
Line 847: Generate summary statistics
Line 850: Calculate health score using exact Python algorithm
Line 853: TODO: External tool integration at codebase level - requires async pipeline support
Line 854: For now, provide placeholder results with structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8253 characters
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (13/52) - testing.rs...🔍 DEBUG PROMPT for testing.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d
- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/testing.rs
Language: rust
Comments found: 23

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/testing.rs
Language: rust
Module name: testing

COMMENTS TO ANALYZE:
Line 1: ! Testing Data Extractor - Analyzes test coverage, patterns, and quality
Line 51: "good", "warning", "error"
Line 216: Check for decorators
Line 251: Check for mock usage
Line 260: Recursively process child nodes
Line 281: Try to get coverage from pytest-cov or coverage.py
Line 308: No branches = 100% coverage
Line 340: Pattern 1: Tests without assertions
Line 357: Pattern 2: Large test files
Line 374: Pattern 3: Good use of mocks
Line 391: Pattern 4: Parametrized tests
Line 422: Skip test files themselves
Line 427: Check if it's a main module or important file
Line 469: Simplified detection for slow/flaky tests
Line 472: Heuristic for potentially slow tests
Line 478: Many skipped tests might indicate flakiness
Line 509: Analyze test files
Line 517: Get test coverage

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3762 characters
🤖 Analyzing: [█████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  26% (14/52) - evolution.rs...🔍 DEBUG PROMPT for evolution.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d
- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs
Language: rust
Comments found: 31

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs
Language: rust
Module name: evolution

COMMENTS TO ANALYZE:
Line 1: ! Evolution Data Extractor - Analyzes code evolution patterns and version history
Line 21: commits per month
Line 25: "increasing", "decreasing", "stable"
Line 34: "weekdays", "weekends", "late_night", etc.
Line 35: "small", "medium", "large"
Line 122: Analyze each file's evolution
Line 129: Analyze overall commit patterns
Line 134: Extract author metrics from file evolutions
Line 168: Get git log for this file
Line 197: Get line statistics
Line 200: Calculate primary author (most commits)
Line 212: Calculate commit frequency (commits per month)
Line 235: Calculate stability score (lower is more stable)
Line 238: Determine complexity trend (simplified)
Line 313: Analyze commit size based on message
Line 322: Analyze time patterns (simplified)
Line 331: Create patterns based on analysis
Line 361: Calculate risk score based on multiple factors
Line 366: Bug proneness heuristic (high change frequency + multiple authors)
Line 377: Overall risk score calculation
Line 382: Threshold for hotspot
Line 394: Sort by risk score (highest first)
Line 403: Code churn metrics
Line 424: Overall health score
Line 447: Analyze git history
Line 453: Calculate project health metrics

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4172 characters
🤖 Analyzing: [██████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  28% (15/52) - issues.rs...🔍 DEBUG PROMPT for issues.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: The file provides semantic node models and functionalities for code analysis and graph construction. It defines various structs that represent different types of code elements (functions, classes) alo
- mod.rs: This file acts as the data models module for CodeHUD core, representing code analysis results, semantic information, and visualization data. It contains all necessary data structures that are used in 
- analysis_result.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/models/analysis_result.rs in Rust language is an implementation of a data structure named Analysis Result Model that matches th
- view_types.rs: This file provides a comprehensive set of data models and enumerations for CodeHUD analysis, visualization, and semantic information representation. It is designed to ensure seamless compatibility acr
- dependencies.rs: This file provides a comprehensive module for automatic dependency analysis in Rust projects, using tree-sitter queries and petgraph library. It detects imports, calculates metrics, detects circular d
- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/issues.rs
Language: rust
Comments found: 16

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/issues.rs
Language: rust
Module name: issues

COMMENTS TO ANALYZE:
Line 1: ! Issues Data Extractor
Line 3: ! Categorizes and analyzes code issues using external tools
Line 4: ! like pylint, ruff, bandit, and other static analysis tools.
Line 42: Run external tools using async runtime since extract_data is not async
Line 46: Run all external tools in parallel for efficiency
Line 53: Run in parallel and collect results, handling errors gracefully
Line 62: Calculate total issues across all tools
Line 74: Create comprehensive issue summary with real data
Line 111: Run pylint and parse output to JSON
Line 129: Fallback: create structured data from stderr text
Line 150: Run ruff and parse output to JSON
Line 188: Run bandit for security analysis
Line 206: Extract results from bandit's JSON structure
Line 234: Run mypy for type checking
Line 250: MyPy outputs one JSON object per line

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3796 characters
📦 Processing batch 4/11 (5 files)...
🤖 Analyzing: [███████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  30% (16/52) - security.rs...🔍 DEBUG PROMPT for security.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat
- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs
Language: rust
Comments found: 37

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs
Language: rust
Module name: security

COMMENTS TO ANALYZE:
Line 1: ! Security Data Extractor - Security vulnerabilities and potential security issues
Line 3: ! This module extracts security vulnerabilities using both AST analysis and bandit integration
Line 4: ! to maintain zero-degradation compliance with the Python implementation.
Line 105: Initialize security patterns - match Python exactly
Line 194: Pattern-based analysis - match Python's line-by-line approach
Line 254: Recursively analyze children
Line 269: Check for dangerous functions - match Python exactly (only eval, exec, compile, __import__)
Line 279: Python sets all these to high
Line 285: Check for subprocess calls with shell=True - more precise matching
Line 305: Check for pickle.loads usage
Line 319: Check for yaml.load usage
Line 341: Check for sensitive data patterns - match Python line-by-line logic
Line 365: Check for insecure imports
Line 397: Check sensitive patterns - match Python exactly
Line 410: Check file permission patterns
Line 424: Additional security checks - match Python's _check_additional_security_issues
Line 435: Check for use of HTTP instead of HTTPS
Line 448: Check for potential XSS vulnerabilities
Line 469: Check for potential directory traversal
Line 530: Weight by severity - match Python exactly
Line 543: Calculate score (0-100, higher is more risky)
Line 544: Normalize based on number of files analyzed - match Python algorithm
Line 554: Determine risk level - match Python thresholds
Line 568: Round to 1 decimal place
Line 641: For Rust, we focus on different security patterns than Python
Line 644: Analyze each file for Rust-specific security issues
Line 652: Check for unsafe blocks
Line 666: Check for unwrap() calls
Line 680: Check for expect() calls
Line 711: Get all source files
Line 714: Analyze each file
Line 722: Create a mutable copy for analysis
Line 740: Collect all issues from this file
Line 767: Combine all issues for analysis
Line 772: Run Rust-specific security analysis
Line 775: Recalculate analysis with bandit results included

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4975 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  32% (17/52) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat
- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/lib.rs
Language: rust
Comments found: 38

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Core - Analysis Engine and Data Structures
Line 3: ! This crate provides the core analysis engine for CodeHUD, including:
Line 4: ! - Data models and semantic structures
Line 5: ! - Analysis extractors and algorithms
Line 6: ! - Graph analysis and pattern detection
Line 7: ! - Caching and performance optimization
Line 9: ! This is a zero-degradation Rust translation of the Python CodeHUD core,
Line 10: ! designed to maintain 100% compatibility while achieving 60%+ performance improvements.
Line 20: Common in large dependency trees
Line 21: Often necessary for clarity
Line 34: Re-export commonly used types for convenience
Line 45: Re-export Pipeline for easy access (commented out to avoid name conflict)
Line 46: pub use Pipeline;
Line 48: Result type used throughout CodeHUD core
Line 51: Error types for CodeHUD core operations
Line 54: I/O operation failed
Line 74: External tool error
Line 86: JSON serialization error
Line 91: Analysis pipeline types matching Python implementation exactly
Line 95: Direct analysis pipeline (fast, modern approach)
Line 97: Legacy analysis pipeline (compatibility with older Python behavior)
Line 99: Hybrid pipeline (combines direct and legacy modes)
Line 126: Global configuration for CodeHUD core
Line 129: Maximum number of files to analyze
Line 131: Enable parallel processing
Line 133: Number of worker threads
Line 139: File extensions to analyze
Line 141: Patterns to exclude
Line 143: Default analysis pipeline to use

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4422 characters
🤖 Analyzing: [█████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  34% (18/52) - test_security.rs...🔍 DEBUG PROMPT for test_security.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat
- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_security.rs
Language: rust
Comments found: 5

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_security.rs
Language: rust
Module name: test_security

COMMENTS TO ANALYZE:
Line 25: Print risk assessment
Line 31: Print file count and issues
Line 65: Print bandit results

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3066 characters
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  36% (19/52) - test_quality.rs...🔍 DEBUG PROMPT for test_quality.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat
- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs
Language: rust
Comments found: 5

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs
Language: rust
Module name: test_quality

COMMENTS TO ANALYZE:
Line 25: Print health score
Line 30: Print file count and issues
Line 38: Show first few issues as examples
Line 44: Print external tool results

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3110 characters
🤖 Analyzing: [███████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  38% (20/52) - test_dependencies.rs...🔍 DEBUG PROMPT for test_dependencies.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: The file runtime_profiler in the CodeHUD project is designed to analyze and profile the runtime performance of code snippets or entire programs, providing insights into execution patterns, complexity,
- topology.rs: This file, topology.rs in Rust language, serves the purpose of extracting and analyzing codebase topology information including file structure, classes, functions, and architectural overview from vari
- performance.rs: The file at /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/performance.rs serves as a performance analysis tool for Rust code, providing insights into potential performance
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/mod.rs in the Rust language is a key module for CodeHUD analysis, providing data extractors that closely mimic Pytho
- flow.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/flow.rs in Rust language serves as a data flow analyzer for Python codebases. It's designed to identify specific pat
- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_dependencies.rs
Language: rust
Comments found: 5

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_dependencies.rs
Language: rust
Module name: test_dependencies

COMMENTS TO ANALYZE:
Line 25: Print dependency metrics
Line 31: Print coupling analysis
Line 37: Print file count and dependencies

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3090 characters
📦 Processing batch 5/11 (5 files)...
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (21/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a
- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Constants module for CodeHUD core
Line 3: ! This module contains all threshold values, configuration constants,
Line 4: ! and other static values used throughout the analysis engine.

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3154 characters
🤖 Analyzing: [█████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  42% (22/52) - complexity_thresholds.rs...🔍 DEBUG PROMPT for complexity_thresholds.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a
- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/complexity_thresholds.rs
Language: rust
Comments found: 61

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/complexity_thresholds.rs
Language: rust
Module name: complexity_thresholds

COMMENTS TO ANALYZE:
Line 1: ! Complexity Analysis Thresholds
Line 3: ! Constants for measuring and categorizing code complexity metrics.
Line 4: ! These thresholds help identify overly complex code that may need refactoring.
Line 6: ! This is a 1:1 translation from Python src/codehud/constants/complexity_thresholds.py
Line 7: ! to ensure zero degradation in complexity analysis behavior.
Line 11: General code complexity thresholds
Line 16: Base complexity thresholds
Line 17: Low complexity threshold
Line 18: Moderate complexity threshold
Line 19: High complexity threshold
Line 20: Excessive complexity threshold
Line 21: Critical complexity threshold
Line 24: Function complexity warning
Line 25: Function complexity critical
Line 28: Class complexity warning
Line 29: Class complexity critical
Line 31: Get complexity status description
Line 34: `complexity` - The complexity score to evaluate
Line 37: A string describing the complexity level
Line 48: Determine if code needs refactoring based on complexity
Line 51: `complexity` - The complexity score to evaluate
Line 52: `context` - The context ("function", "class", or other)
Line 55: `true` if the code needs refactoring, `false` otherwise
Line 65: Cyclomatic complexity specific thresholds
Line 70: McCabe complexity thresholds (widely accepted industry standards)
Line 71: Simple, no branching
Line 72: Low risk, simple procedure
Line 73: Moderate risk, complex procedure
Line 74: High risk, very complex procedure
Line 75: Untestable, extremely complex
Line 78: Easy to understand and maintain
Line 79: Maintainable with effort
Line 80: Difficult to maintain
Line 83: Get risk level based on cyclomatic complexity
Line 86: `cyclomatic_complexity` - The cyclomatic complexity score
Line 89: A string describing the risk level
Line 100: Get maintainability assessment based on cyclomatic complexity
Line 103: `cyclomatic_complexity` - The cyclomatic complexity score
Line 106: A string describing the maintainability level
Line 117: Determine if complexity requires immediate attention
Line 120: `cyclomatic_complexity` - The cyclomatic complexity score
Line 123: `true` if complexity requires immediate attention
Line 181: Property-based tests to ensure mathematical equivalence with Python
Line 191: Verify status matches expected boundaries

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5304 characters
🤖 Analyzing: [██████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  44% (23/52) - health_score_thresholds.rs...🔍 DEBUG PROMPT for health_score_thresholds.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a
- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/health_score_thresholds.rs
Language: rust
Comments found: 57

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/health_score_thresholds.rs
Language: rust
Module name: health_score_thresholds

COMMENTS TO ANALYZE:
Line 1: ! Health Score and Quality Thresholds
Line 3: ! Constants for calculating and categorizing codebase health metrics.
Line 4: ! These thresholds determine the boundaries between different health levels
Line 5: ! and quality categories.
Line 7: ! This is a 1:1 translation from Python src/codehud/constants/health_score_thresholds.py
Line 8: ! to ensure zero degradation in health scoring behavior.
Line 12: Thresholds for overall codebase health scoring
Line 17: Health score percentage thresholds (0.0 to 1.0)
Line 18: Excellent health threshold
Line 19: Good health threshold
Line 20: Acceptable health threshold
Line 21: Poor health threshold
Line 23: Alternative named thresholds for readability
Line 29: Get health status description based on score
Line 32: `health_score` - The health score to evaluate (0.0 to 1.0)
Line 35: A string describing the health status with emoji
Line 45: Get color coding for health score display
Line 48: `health_score` - The health score to evaluate (0.0 to 1.0)
Line 51: A string representing the color for display
Line 61: Determine if health score requires immediate attention
Line 64: `health_score` - The health score to evaluate (0.0 to 1.0)
Line 67: `true` if the health score requires immediate attention
Line 73: Thresholds for code quality metrics
Line 78: Test coverage thresholds
Line 79: 90% coverage or above
Line 80: 80% coverage threshold
Line 81: 70% coverage threshold
Line 82: 50% minimum coverage
Line 84: Code duplication thresholds
Line 85: 5% duplication or less
Line 86: 10% duplication threshold
Line 87: 15% duplication threshold
Line 89: Documentation coverage thresholds
Line 90: 85% documentation coverage
Line 91: 70% documentation coverage
Line 92: 50% minimum documentation
Line 94: Get coverage status description
Line 97: `coverage` - The coverage ratio to evaluate (0.0 to 1.0)
Line 100: A string describing the coverage status
Line 111: Get code duplication status description
Line 114: `duplication` - The duplication ratio to evaluate (0.0 to 1.0)
Line 117: A string describing the duplication status
Line 171: Boundary tests to ensure exact Python equivalence
Line 174: Health score boundaries
Line 187: Property-based tests for mathematical equivalence
Line 199: Verify status and color alignment

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5301 characters
🤖 Analyzing: [███████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░]  46% (24/52) - algorithms.rs...🔍 DEBUG PROMPT for algorithms.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a
- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms.rs
Language: rust
Comments found: 46

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms.rs
Language: rust
Module name: algorithms

COMMENTS TO ANALYZE:
Line 1: ! Graph algorithms for CodeHUD analysis
Line 3: ! NetworkX-equivalent implementations of graph algorithms:
Line 4: ! - Centrality calculations (betweenness, closeness, degree, eigenvector, PageRank)
Line 5: ! - Cycle detection
Line 6: ! - Strongly connected components
Line 7: ! - Shortest paths
Line 8: ! - Clustering coefficients
Line 17: Centrality algorithm implementations
Line 21: Calculate degree centrality for all nodes
Line 22: Degree centrality = degree(node) / (n - 1) where n is total nodes
Line 44: Calculate betweenness centrality using Brandes' algorithm
Line 45: Measures how often a node appears on shortest paths between other nodes
Line 50: Initialize centrality to 0 for all nodes
Line 55: For each node, calculate shortest paths to all other nodes
Line 77: BFS to find shortest paths
Line 84: First time we see this node
Line 90: Shortest path to neighbor via current
Line 98: Accumulation - back-propagate dependencies
Line 111: Normalize for directed graphs
Line 122: Calculate closeness centrality
Line 123: Closeness centrality = (n-1) / sum(shortest_path_lengths)
Line 144: Calculate PageRank centrality using power iteration
Line 159: Initialize PageRank values
Line 172: Sum contributions from incoming edges
Line 185: Check for convergence
Line 204: Calculate single-source shortest path lengths using BFS
Line 232: Cycle detection algorithms
Line 236: Find all simple cycles in the graph using Johnson's algorithm
Line 241: For simplicity, we'll use a basic DFS-based approach
Line 242: In a production system, Johnson's algorithm would be more efficient
Line 252: DFS-based cycle detection helper
Line 262: Found a cycle back to start
Line 284: Network analysis algorithms
Line 288: Calculate clustering coefficient for a node
Line 312: Calculate average clustering coefficient for the entire graph
Line 327: Calculate graph density
Line 336: For directed graphs: max edges = n * (n - 1)
Line 341: Calculate average path length using BFS from all nodes
Line 372: Calculate graph diameter (longest shortest path)
Line 406: Node 2 should have highest centrality (connected to both others)
Line 424: All nodes should have similar PageRank in this symmetric case
Line 469: No edges - density should be 0
Line 474: One edge between two nodes - density should be 0.5

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5276 characters
🤖 Analyzing: [████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░]  48% (25/52) - metrics.rs...🔍 DEBUG PROMPT for metrics.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/orphaned_files.rs in the CodeHUD project is a Rust implementation of an orphaned files analyzer. It initializes all 
- quality.rs: This file, quality.rs in the CodeHUD project, serves as a quality analysis tool for Rust codebases. It provides detailed insights into code quality metrics and health scores by performing various anal
- testing.rs: The file `testing.rs` in the CodeHUD project is designed to perform comprehensive testing analysis, specifically focusing on test coverage and quality patterns. It provides a data extractor for analyz
- evolution.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/evolution.rs is a Rust implementation of an evolution data extractor for code analysis and version history. It analy
- issues.rs: This file, issues.rs in the CodeHUD project, serves as a comprehensive issue analysis tool for Rust codebases. It categorizes and analyzes code issues using external tools like pylint, ruff, bandit, a
- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/metrics.rs
Language: rust
Comments found: 47

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/metrics.rs
Language: rust
Module name: metrics

COMMENTS TO ANALYZE:
Line 1: ! Graph metrics for CodeHUD analysis
Line 3: ! Implements NetworkX-equivalent metrics calculations:
Line 4: ! - Centrality metrics (betweenness, closeness, degree, eigenvector)
Line 5: ! - Coupling metrics (afferent, efferent, instability)
Line 6: ! - Graph structural metrics
Line 12: Centrality metrics for graph nodes
Line 15: Betweenness centrality for each node
Line 17: Closeness centrality for each node
Line 19: Degree centrality for each node
Line 21: Eigenvector centrality for each node
Line 23: PageRank scores for each node
Line 28: Create empty centrality metrics
Line 39: Get the most central node by betweenness centrality
Line 47: Get the most central node by closeness centrality
Line 55: Get the highest degree node
Line 63: Get top N nodes by PageRank
Line 70: Calculate average centrality values
Line 88: Average centrality values
Line 98: Coupling metrics for measuring module dependencies
Line 101: Afferent coupling (Ca) - number of incoming dependencies
Line 103: Efferent coupling (Ce) - number of outgoing dependencies
Line 105: Instability (I) - Ce / (Ca + Ce)
Line 107: Abstractness (A) - ratio of abstract classes to total classes
Line 109: Distance from main sequence (D) - |A + I - 1|
Line 114: Create empty coupling metrics
Line 125: Calculate instability for a node
Line 139: Calculate distance from main sequence for a node
Line 148: Get most coupled nodes (highest afferent + efferent)
Line 163: Get most unstable nodes
Line 170: Calculate all coupling metrics for all nodes
Line 180: Get summary statistics
Line 199: Summary statistics for coupling metrics
Line 210: Network analysis metrics
Line 215: Average clustering coefficient
Line 217: Average path length
Line 219: Diameter of the graph
Line 221: Number of connected components
Line 223: Largest component size
Line 228: Create new network metrics
Line 240: Check if the network is sparse
Line 245: Check if the network is dense
Line 250: Get network complexity score (0-1 scale)
Line 270: Helper function to calculate average of HashMap values
Line 279: Helper function to calculate average of HashMap usize values
Line 328: Ce / (Ca + Ce) = 2 / (3 + 2)
Line 353: 0.5 = 1/2.0

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5146 characters
📦 Processing batch 6/11 (5 files)...
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (26/52) - algorithms_minimal.rs...🔍 DEBUG PROMPT for algorithms_minimal.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms_minimal.rs
Language: rust
Comments found: 36

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/algorithms_minimal.rs
Language: rust
Module name: algorithms_minimal

COMMENTS TO ANALYZE:
Line 1: ! Full graph algorithms implementation - NetworkX equivalent functionality
Line 3: ! Complete implementation of centrality metrics, cycle detection, and graph analysis
Line 4: ! with mathematical equivalence to NetworkX algorithms
Line 12: Complete centrality algorithms implementation equivalent to NetworkX
Line 16: Calculate degree centrality for all nodes (NetworkX equivalent)
Line 25: Degree centrality = degree / (n-1) where n is number of nodes
Line 41: Calculate betweenness centrality using Brandes algorithm (NetworkX equivalent)
Line 46: Initialize centrality to 0
Line 57: Brandes algorithm for betweenness centrality
Line 79: BFS to find shortest paths
Line 119: Normalize (for directed graphs, divide by (n-1)(n-2))
Line 130: Calculate closeness centrality (NetworkX equivalent)
Line 153: Single-source shortest path length calculation
Line 180: Calculate PageRank centrality with power iteration (NetworkX equivalent)
Line 194: Initialize PageRank values
Line 200: Build adjacency information
Line 223: Sum contributions from incoming edges
Line 237: Check for convergence
Line 243: Convert to string keys
Line 250: Complete cycle detection implementation using DFS and Tarjan's algorithm
Line 254: Find all cycles in a directed graph using DFS
Line 301: Found a cycle - extract it from the path
Line 317: Complete network analysis with graph metrics
Line 321: Find strongly connected components using Tarjan's algorithm
Line 334: Calculate graph density (NetworkX equivalent)
Line 343: For directed graphs: density = m / (n * (n-1))
Line 348: Calculate average clustering coefficient
Line 376: Count edges between neighbors
Line 386: Clustering coefficient = actual_edges / possible_edges
Line 391: Calculate average shortest path length
Line 419: Calculate graph diameter (longest shortest path)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4842 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  51% (27/52) - edges.rs...🔍 DEBUG PROMPT for edges.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/edges.rs
Language: rust
Comments found: 38

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/edges.rs
Language: rust
Module name: edges

COMMENTS TO ANALYZE:
Line 1: ! Graph edge definitions for CodeHUD graph analysis
Line 3: ! Defines the edge types used in different graph representations:
Line 4: ! - CallEdge: Function call relationships
Line 5: ! - DependencyEdge: Module dependency relationships
Line 6: ! - InheritanceEdge: Class inheritance relationships
Line 10: Edge representing a function call relationship
Line 13: Number of times this call is made
Line 15: Weight of this edge for graph algorithms
Line 20: Create a new call edge
Line 28: Create a call edge with custom weight
Line 36: Get the call frequency (calls per unit, normalized)
Line 42: Edge representing a module dependency relationship
Line 45: Type of import (import, from_import, etc.)
Line 47: Weight of this dependency for graph algorithms
Line 52: Create a new dependency edge
Line 60: Create a dependency edge with custom weight
Line 68: Check if this is a specific import type
Line 73: Get dependency strength (weight)
Line 79: Edge representing a class inheritance relationship
Line 82: Type of inheritance (extends, implements, etc.)
Line 84: Weight of this inheritance for graph algorithms
Line 89: Create a new inheritance edge
Line 97: Create an inheritance edge with custom weight
Line 105: Check if this is a specific inheritance type
Line 110: Get inheritance strength (weight)
Line 116: Trait for graph edges to provide common functionality
Line 118: Get the weight of this edge
Line 121: Get the edge type as string
Line 124: Check if this edge is significant (weight above threshold)
Line 160: Edge metadata for analysis
Line 163: Source file of the edge
Line 165: Target file of the edge
Line 167: Line number where relationship is defined
Line 174: Create new edge metadata
Line 184: Add line number information
Line 190: Add metadata key-value pair
Line 196: Check if files are in same directory

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4816 characters
🤖 Analyzing: [██████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░]  53% (28/52) - nodes.rs...🔍 DEBUG PROMPT for nodes.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/nodes.rs
Language: rust
Comments found: 28

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/nodes.rs
Language: rust
Module name: nodes

COMMENTS TO ANALYZE:
Line 1: ! Graph node definitions for CodeHUD graph analysis
Line 3: ! Defines the node types used in different graph representations:
Line 4: ! - CallNode: Function calls in call graphs
Line 5: ! - ModuleNode: Modules/files in dependency graphs
Line 6: ! - ClassNode: Classes in inheritance graphs
Line 10: Node representing a function in the call graph
Line 15: File path where function is defined
Line 17: Line number where function is defined
Line 22: Create a new call node
Line 31: Get the qualified function name (file::function)
Line 37: Node representing a module in the dependency graph
Line 42: File path of the module
Line 44: Whether this is an external dependency
Line 49: Create a new module node
Line 58: Check if this is an internal module
Line 63: Get module type as string
Line 73: Node representing a class in the inheritance graph
Line 78: File path where class is defined
Line 80: Line number where class is defined
Line 85: Create a new class node
Line 94: Get the qualified class name (file::class)
Line 100: Trait for graph nodes to provide common functionality
Line 102: Get the display name for this node
Line 105: Get the file path for this node
Line 108: Get the line number for this node (if applicable)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4214 characters
🤖 Analyzing: [███████████████████████████░░░░░░░░░░░░░░░░░░░░░░░]  55% (29/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/mod.rs
Language: rust
Comments found: 57

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Graph Analysis Engine - NetworkX equivalent for CodeHUD
Line 3: ! Provides zero-degradation compatibility with Python NetworkX for:
Line 4: ! - Call graph analysis
Line 5: ! - Dependency graph analysis
Line 6: ! - Inheritance graph analysis
Line 7: ! - Centrality calculations
Line 8: ! - Cycle detection
Line 9: ! - Strongly connected components
Line 10: ! - Coupling metrics
Line 26: Re-export minimal algorithms as algorithms for compatibility
Line 34: Type aliases for different graph types
Line 39: Node identifier type - using string for serialization compatibility
Line 42: Edge identifier type
Line 45: Graph analysis results combining all metrics
Line 48: Call graph centrality metrics
Line 50: Dependency graph centrality metrics
Line 52: Inheritance graph centrality metrics
Line 54: Detected cycles in all graphs
Line 56: Strongly connected components
Line 58: Coupling metrics for the codebase
Line 64: Cycle detection results
Line 67: Cycles in call graph (node names)
Line 69: Cycles in dependency graph (node names)
Line 71: Cycles in inheritance graph (node names)
Line 73: Total cycle count
Line 77: Strongly connected components analysis
Line 80: Components in call graph (node names)
Line 82: Components in dependency graph (node names)
Line 84: Components in inheritance graph (node names)
Line 86: Total component count
Line 93: Call graph stats
Line 95: Dependency graph stats
Line 97: Inheritance graph stats
Line 101: Individual graph statistics
Line 104: Number of nodes
Line 106: Number of edges
Line 108: Graph density (edges / max_possible_edges)
Line 110: Whether the graph is cyclic
Line 116: Graph builder for constructing graphs from extracted data
Line 124: Mappings between string identifiers and graph node indices
Line 127: Function name -> call graph node index
Line 129: Module name -> dependency graph node index
Line 131: Class name -> inheritance graph node index
Line 136: Create a new graph builder
Line 146: Add a function call relationship
Line 160: Add a module dependency relationship
Line 174: Add a class inheritance relationship
Line 188: Build the final graph analyzer
Line 197: Get or create a call graph node
Line 204: Will be populated later
Line 213: Get or create a dependency graph node
Line 229: Get or create an inheritance graph node
Line 298: Add same call relationship twice
Line 302: Should have 2 nodes but 2 edges

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5365 characters
🤖 Analyzing: [████████████████████████████░░░░░░░░░░░░░░░░░░░░░░]  57% (30/52) - analyzer.rs...🔍 DEBUG PROMPT for analyzer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/extractors/security.rs in the CodeHUD project serves as a security vulnerabilities and potential security issues analyzer. It u
- lib.rs: This file, `lib.rs` in the CodeHUD project, provides a core analysis engine and data structures for CodeHUD. It is designed to be a zero-degradation Rust translation of the Python CodeHUD core, aiming
- test_security.rs: The file `test_security.rs` in the CodeHUD project serves as a comprehensive security testing tool for Rust codebases. It analyzes security vulnerabilities and assesses potential risks by using extern
- test_quality.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/bin/test_quality.rs in the CodeHUD project is a Rust application designed specifically for assessing code quality and test cove
- test_dependencies.rs: This Rust file, `test_dependencies.rs`, is part of the CodeHUD project and serves a specific purpose in analyzing dependencies within codebases. The file provides functionalities for printing metrics 
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/analyzer.rs
Language: rust
Comments found: 48

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/graph/analyzer.rs
Language: rust
Module name: analyzer

COMMENTS TO ANALYZE:
Line 1: ! Graph Analyzer - Main entry point for graph analysis
Line 3: ! Orchestrates all graph analysis operations and provides NetworkX-equivalent functionality
Line 17: Main graph analyzer that orchestrates all analysis operations
Line 25: Create a new graph analyzer
Line 38: Perform complete graph analysis and return all results
Line 51: Calculate centrality metrics for call graph
Line 60: Note: Eigenvector centrality would require additional implementation
Line 61: For now, we'll use PageRank as a proxy
Line 67: Calculate centrality metrics for dependency graph
Line 80: Calculate centrality metrics for inheritance graph
Line 93: Detect cycles in all graphs (NetworkX equivalent)
Line 109: Find strongly connected components in all graphs (NetworkX equivalent)
Line 111: Use the minimal NetworkAnalysis implementation for now
Line 126: Calculate coupling metrics (NetworkX equivalent)
Line 130: Calculate coupling based on dependency graph
Line 132: Convert NodeIndex to String key
Line 135: Afferent coupling (Ca) - incoming dependencies
Line 139: Efferent coupling (Ce) - outgoing dependencies
Line 143: Calculate abstractness (simplified - would need class analysis for real implementation)
Line 144: For now, assume 0.5 as default abstractness
Line 148: Calculate derived metrics
Line 154: Calculate graph statistics
Line 163: Calculate statistics for a single graph
Line 172: For directed graphs
Line 186: Check if a graph has cycles (simplified implementation)
Line 188: Simple DFS-based cycle detection
Line 202: DFS helper for cycle detection
Line 228: Get call graph reference
Line 233: Get dependency graph reference
Line 238: Get inheritance graph reference
Line 243: Calculate network metrics for all graphs
Line 247: Call graph metrics
Line 258: Dependency graph metrics
Line 269: Inheritance graph metrics
Line 283: Calculate the size of the largest connected component
Line 308: Check if graphs have problematic patterns
Line 312: Check for problematic cycles
Line 332: Check coupling metrics
Line 349: Check graph density
Line 388: Add some relationships
Line 397: Should have calculated centrality for all graphs
Line 401: Should have detected cycles and components
Line 405: Should have calculated statistics
Line 414: Create a dependency chain
Line 422: Module C should have high afferent coupling (imported by A and B)
Line 423: Module A should have high efferent coupling (imports B and C)
Line 432: Create a dependency cycle
Line 440: Should detect the cycle as an issue

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5495 characters
📦 Processing batch 7/11 (5 files)...
🤖 Analyzing: [█████████████████████████████░░░░░░░░░░░░░░░░░░░░░]  59% (31/52) - query_engine.rs...🔍 DEBUG PROMPT for query_engine.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/query_engine.rs
Language: rust
Comments found: 104

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/query_engine.rs
Language: rust
Module name: query_engine

COMMENTS TO ANALYZE:
Line 1: ! Tree-Sitter Query Engine
Line 3: ! Automatically detects file languages and applies appropriate tree-sitter queries
Line 4: ! for code analysis. Uses established community grammars for maximum compatibility.
Line 6: ! CRITICAL FIX APPLIED (2025-01-25): Added query limits to prevent infinite loops
Line 7: ! in comment extraction that was causing system hangs:
Line 8: ! - cursor.set_match_limit(5000): Limits tree-sitter query matches per file
Line 9: ! - max_comments = 10000: Prevents infinite comment processing loops
Line 10: ! - Error handling for invalid UTF-8 text to avoid crashes
Line 11: ! This fix resolved hanging issues when processing large Rust codebases (206 files).
Line 22: Comprehensive language support using community tree-sitter grammars
Line 25: Tier 1 - Core general-purpose
Line 40: Tier 2 - Scripting / Systems
Line 49: Tier 3 - Web / Data / Markup
Line 62: Tier 4 - Build / DevOps / Config
Line 71: Language grammar registry with metadata and extension mappings
Line 83: Get tree-sitter language for this enum
Line 86: Tier 1 - Core languages
Line 92: For now, fallback to existing parsers for other languages
Line 93: TODO: Add actual parsers as we integrate more grammars
Line 98: Get comprehensive file extensions for this language
Line 148: Get all supported languages in priority order
Line 151: Tier 1 - Most important
Line 167: Detect language from file path with comprehensive extension matching
Line 171: Handle special cases first
Line 175: Special filename detection
Line 194: Get grammar metadata for this language
Line 237: TODO: Add actual grammar info for other languages
Line 250: Query types for different analysis purposes
Line 255: Function call extraction for call graph
Line 259: Community highlights.scm for semantic analysis
Line 260: Community tags.scm for symbol extraction
Line 264: Comment extraction queries
Line 286: Main query engine that handles all tree-sitter operations
Line 293: Create new query engine with all languages and queries pre-loaded
Line 300: Initialize parsers for all supported languages
Line 310: Pre-compile all queries for performance
Line 313: Debug: Print loaded queries
Line 324: Load and compile all query files
Line 351: Load query file content with comprehensive path resolution
Line 356: Priority paths for query files
Line 370: Try downloading from community repo if not found locally
Line 374: Get standardized language name for file paths
Line 417: Try to download community query patterns (future enhancement)
Line 419: TODO: Implement automatic download of community queries
Line 420: For now, return None - queries must be present locally
Line 424: Analyze a single file automatically detecting language and applying appropriate queries
Line 426: Automatically detect language
Line 430: Read file content
Line 434: Parse with appropriate language parser
Line 441: Apply all available queries for this language
Line 448: Extract imports using enhanced semantic approach
Line 458: Extract function calls
Line 468: Extract symbols using community tags.scm
Line 473: Extract semantic highlights using community highlights.scm
Line 478: Extract comments using comment-specific queries
Line 486: Extract information using a specific query type
Line 496: Query not available for this language
Line 500: Set reasonable limits to prevent infinite processing
Line 516: Process import matches using proper tree-sitter semantic approach
Line 530: Aggregate all captures by type for semantic analysis
Line 546: Process captures semantically
Line 550: Full import declarations - create detailed records
Line 561: Individual imported items
Line 626: Absolute path markers
Line 635: Other captures - store for debugging
Line 664: Process function query matches into structured data
Line 707: Process function call matches for call graph generation
Line 729: For qualified calls like module.function(), extract the full path
Line 748: Process complexity query matches into metrics
Line 771: Each match arm adds complexity
Line 791: Analyze multiple files in a directory automatically
Line 806: Update language statistics
Line 832: Process community tags.scm queries for symbol extraction
Line 870: Process community highlights.scm queries for semantic analysis
Line 913: Process comment query matches into structured comment data
Line 921: Dynamic limit based on file size - prevent infinite loops while allowing large files
Line 923: At least 50k, or 2x lines in file
Line 928: Prevent infinite processing
Line 938: Skip invalid UTF-8
Line 945: Determine comment type
Line 992: Get the global query engine instance

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 7579 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  61% (32/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs
Language: rust
Comments found: 48

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Pattern detection module for CodeHUD core
Line 3: ! This module provides pattern detection capabilities for identifying
Line 4: ! anti-patterns, code smells, architectural patterns, and security patterns.
Line 6: ! The pattern detection must produce identical results to the Python implementation
Line 7: ! to ensure zero degradation in analysis accuracy.
Line 13: Types of patterns that can be detected
Line 25: Severity levels for detected patterns
Line 35: A detected pattern with location and metadata
Line 45: 0.0 to 1.0
Line 49: Rule for pattern detection
Line 60: Pattern detector that identifies various code patterns
Line 69: Anti-pattern detection rule
Line 76: Code smell detection rule
Line 83: Architectural pattern detection rule
Line 90: Security pattern detection rule
Line 98: Create a new pattern detector with default rules
Line 108: Detect all patterns in the given code
Line 115: Detect code smells
Line 118: Detect architectural patterns
Line 121: Detect security patterns
Line 127: Detect anti-patterns in code
Line 133: Calculate line numbers (Python-compatible)
Line 154: Detect code smells
Line 180: Detect architectural patterns
Line 206: Detect security patterns
Line 232: Get line number for a byte position in the code (1-indexed like Python)
Line 237: Load anti-pattern detection rules
Line 241: God Object anti-pattern
Line 255: Long parameter list
Line 286: Load code smell detection rules
Line 290: Dead code (unused imports)
Line 335: Load architectural pattern detection rules
Line 384: Load security pattern detection rules
Line 388: SQL injection vulnerability
Line 447: Filter patterns by severity
Line 454: Filter patterns by type
Line 461: Get pattern statistics
Line 493: Statistics about detected patterns

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4724 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  63% (33/52) - cargo_test.rs...🔍 DEBUG PROMPT for cargo_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs
Language: rust
Comments found: 17

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs
Language: rust
Module name: cargo_test

COMMENTS TO ANALYZE:
Line 1: ! Cargo Test Integration - Rust test runner equivalent to pytest
Line 3: ! Provides integration with cargo test for Rust test execution and analysis
Line 11: Cargo test integration for Rust test analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 50: First, run tests in quiet mode to get basic results
Line 66: Parse test results
Line 72: Simple parsing - cargo test output format can vary
Line 75: Extract summary line: "test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"
Line 93: Individual test result lines
Line 101: Would need more parsing to extract
Line 108: Check for compilation errors that prevent tests from running
Line 112: Calculate test coverage (simplified - would need actual coverage tools)
Line 158: Cargo test analysis result
Line 172: Individual test case result
Line 176: "ok", "FAILED", "ignored"
Line 197: Create a Cargo.toml to simulate a Rust project
Line 209: Create a minimal Rust project

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3989 characters
🤖 Analyzing: [████████████████████████████████░░░░░░░░░░░░░░░░░░]  65% (34/52) - ruff.rs...🔍 DEBUG PROMPT for ruff.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs
Language: rust
Comments found: 26

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs
Language: rust
Module name: ruff

COMMENTS TO ANALYZE:
Line 1: ! Ruff Python Linter Integration
Line 3: ! Zero-degradation integration with Ruff linter matching Python static_analyzer.py behavior
Line 12: Ruff linter integration
Line 24: Analyze a single file with ruff - CRITICAL for zero-degradation compliance
Line 39: Exit code 1 is expected when issues are found
Line 47: Parse JSON output
Line 49: No issues found
Line 60: Parse ruff JSON output format
Line 68: Categorize issues by severity
Line 74: Default to info
Line 83: We don't run with --fix
Line 115: Exit code 1 is expected when issues are found
Line 123: Parse JSON output
Line 125: No issues found
Line 136: Parse ruff JSON output format
Line 144: Categorize issues by severity
Line 150: Default to info
Line 159: We don't run with --fix
Line 184: Ruff analysis result matching Python static_analyzer.py format
Line 195: Individual ruff issue/violation
Line 208: Location information for ruff issues
Line 238: Test basic functionality
Line 241: Test availability check (may or may not be installed)
Line 263: Should succeed even with empty directory
Line 273: Create a Python file with linting issues
Line 300: Should find some issues in the poorly written Python code

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4164 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  67% (35/52) - coverage.rs...🔍 DEBUG PROMPT for coverage.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/constants/mod.rs serves as a central hub for all constant values in the CodeHUD Rust project, including threshold values, confi
- complexity_thresholds.rs: This file, complexity_thresholds.rs in the CodeHUD project, provides a set of predefined thresholds for measuring and categorizing code complexity metrics. These thresholds help identify overly comple
- health_score_thresholds.rs: This file, health_score_thresholds.rs in the CodeHUD project, is a constant module for calculating and categorizing codebase health metrics. These thresholds determine the boundaries between different
- algorithms.rs: This file `algorithms.rs` serves for the implementation of graph algorithms in Rust, used primarily by CodeHUD for code analysis and evaluation purposes. The module implements several types of central
- metrics.rs: This file, `metrics.rs` in the CodeHUD project, implements a set of metrics for network analysis and code analysis. Specifically, it calculates centrality metrics like betweenness, closeness, degree, 
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/coverage.rs
Language: rust
Comments found: 12

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/coverage.rs
Language: rust
Module name: coverage

COMMENTS TO ANALYZE:
Line 1: ! Coverage.py Test Coverage Integration
Line 3: ! Zero-degradation integration with Coverage.py for test coverage analysis
Line 39: Try to get existing coverage data first
Line 45: If no existing coverage data, try to run tests with coverage
Line 74: Get JSON coverage report
Line 93: Parse coverage JSON report
Line 101: Try to run tests with coverage (common patterns)
Line 115: Test execution completed, try to get report
Line 122: If all attempts fail, return empty result
Line 181: Calculate coverage quality metrics
Line 205: Coverage.py JSON report structures
Line 292: Test availability (may or may not be installed)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3627 characters
📦 Processing batch 8/11 (5 files)...
🤖 Analyzing: [██████████████████████████████████░░░░░░░░░░░░░░░░]  69% (36/52) - radon.rs...🔍 DEBUG PROMPT for radon.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per
- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/radon.rs
Language: rust
Comments found: 17

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/radon.rs
Language: rust
Module name: radon

COMMENTS TO ANALYZE:
Line 1: ! Radon Complexity Analyzer Integration
Line 3: ! Zero-degradation integration with Radon complexity analyzer matching Python behavior
Line 39: Run cyclomatic complexity analysis
Line 42: Run maintainability index analysis
Line 45: Run halstead complexity analysis
Line 98: Show all functions
Line 110: Parse radon CC JSON output
Line 121: Parse the nested JSON structure
Line 172: Parse radon MI JSON output
Line 222: Parse radon Halstead JSON output
Line 393: Test availability (may or may not be installed)
Line 413: Create a Python file with varying complexity
Line 501: Should find some functions with varying complexity

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3592 characters
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  71% (37/52) - rustfmt.rs...🔍 DEBUG PROMPT for rustfmt.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per
- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs
Language: rust
Comments found: 12

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs
Language: rust
Module name: rustfmt

COMMENTS TO ANALYZE:
Line 1: ! Rustfmt Integration - Rust code formatter
Line 3: ! Provides integration with rustfmt for Rust code formatting analysis
Line 11: Rustfmt integration for Rust code formatting analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 28: Get all Rust files in the project
Line 95: Check each Rust file for formatting issues
Line 108: Get the diff to show what needs to be formatted
Line 170: Rustfmt analysis result
Line 182: Individual formatting issue found by rustfmt
Line 207: Create a Cargo.toml to simulate a Rust project
Line 219: Create a Rust project with poorly formatted code
Line 245: Create some Rust files

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3623 characters
🤖 Analyzing: [████████████████████████████████████░░░░░░░░░░░░░░]  73% (38/52) - mypy.rs...🔍 DEBUG PROMPT for mypy.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per
- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mypy.rs
Language: rust
Comments found: 15

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mypy.rs
Language: rust
Module name: mypy

COMMENTS TO ANALYZE:
Line 1: ! MyPy Type Checker Integration
Line 3: ! Zero-degradation integration with MyPy type checker matching Python behavior
Line 54: Combine stdout and stderr as mypy can output to both
Line 58: No issues found
Line 66: Parse mypy output line by line
Line 77: Skip lines that are not error/note messages
Line 82: Parse mypy error format: filename:line:column: error: message [error-code]
Line 122: Parse format: filename:line:column: error: message [error-code]
Line 134: Extract severity and message
Line 142: Default to error
Line 145: Extract error code if present [error-code]
Line 212: Test availability (may or may not be installed)
Line 232: Create a Python file with type issues
Line 265: Should find some type errors
Line 274: Test parsing different mypy output formats

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3737 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (39/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per
- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mod.rs
Language: rust
Comments found: 47

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! External Tool Integration System
Line 3: ! Manages integration with external code analysis tools (ruff, pylint, mypy, bandit, etc.)
Line 4: ! providing zero-degradation compatibility with Python implementation.
Line 30: External tool manager coordinating all static analysis tools
Line 46: Create new external tool manager
Line 65: Check availability of all external tools
Line 95: Check if a specific tool is available
Line 109: Get available tools
Line 119: Run all available quality analysis tools
Line 125: Run ruff if available
Line 136: Run pylint if available
Line 147: Run mypy if available
Line 158: Run bandit if available
Line 169: Run radon if available
Line 180: Run vulture if available
Line 191: Run coverage if available
Line 202: Run git analysis if available
Line 213: Run ripgrep if available
Line 227: Run security analysis with available tools
Line 233: Bandit is the primary security tool
Line 247: Get bandit integration if available
Line 257: Combined results from all quality analysis tools
Line 271: Security analysis results
Line 277: Rust-specific tool manager coordinating Rust static analysis tools
Line 290: Create new Rust tool manager
Line 306: Check availability of all Rust tools
Line 338: Check if a cargo subcommand is available
Line 355: Check if a specific tool is available
Line 369: Get available tools
Line 379: Run all available Rust quality analysis tools
Line 385: Run clippy if available
Line 396: Run rustfmt if available
Line 407: Run cargo test if available
Line 418: Run git analysis if available
Line 429: Run ripgrep if available
Line 443: Run security analysis with available Rust tools
Line 449: Cargo audit is the primary security tool for Rust
Line 464: Combined results from all Rust quality analysis tools
Line 474: Rust security analysis results
Line 480: Base trait for all external tool integrations
Line 485: Check if the tool is available
Line 488: Run the analysis
Line 491: Get the tool name
Line 494: Get the tool version
Line 508: Check tool availability
Line 511: Should not crash even if no tools are available

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5042 characters
🤖 Analyzing: [██████████████████████████████████████░░░░░░░░░░░░]  76% (40/52) - cargo_audit.rs...🔍 DEBUG PROMPT for cargo_audit.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the CodeHUD Rust project, provides a complete implementation of graph algorithms equivalent to those provided by Python's NetworkX library. It includes centraliti
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project, is a module dedicated to defining and managing graph edges used for CodeHUD's graph analysis. The edge types include Function Call (CallEdge), Module
- nodes.rs: This file, `nodes.rs` in the CodeHUD project, provides definitions for various types of nodes used in different graph representations such as call graphs, dependency graphs and inheritance graphs. The
- mod.rs: This file, `mod.rs` in the CodeHUD project, serves as a core module for graph analysis and network analysis of codebases. It provides an efficient zero-degradation compatibility with Python NetworkX l
- analyzer.rs: This Rust file, analyzer.rs in the CodeHUD project, serves as a main entry point for graph analysis and orchestrates all graph analysis operations. It provides NetworkX-equivalent functionality by per
- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_audit.rs
Language: rust
Comments found: 16

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_audit.rs
Language: rust
Module name: cargo_audit

COMMENTS TO ANALYZE:
Line 1: ! Cargo Audit Integration - Rust security scanner equivalent to bandit
Line 3: ! Provides integration with cargo audit for Rust security vulnerability scanning
Line 11: Cargo audit integration for Rust security analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 54: Don't update advisory database during analysis
Line 63: Cargo audit returns non-zero if vulnerabilities are found
Line 80: Parse cargo audit JSON output
Line 85: No vulnerabilities found
Line 151: Determine severity based on vulnerability metadata
Line 153: Simple heuristic based on keywords in title/description
Line 168: Cargo audit analysis result
Line 181: Individual vulnerability found by cargo audit
Line 195: Raw cargo audit report structure
Line 239: Create a Cargo.toml to simulate a Rust project
Line 251: Create a Cargo.toml
Line 257: This will depend on whether cargo audit is installed

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3889 characters
📦 Processing batch 9/11 (5 files)...
🤖 Analyzing: [███████████████████████████████████████░░░░░░░░░░░]  78% (41/52) - pylint.rs...🔍 DEBUG PROMPT for pylint.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-
- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs
Language: rust
Comments found: 26

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs
Language: rust
Module name: pylint

COMMENTS TO ANALYZE:
Line 1: ! Pylint Code Quality Analyzer Integration
Line 3: ! Zero-degradation integration with Pylint matching Python static_analyzer.py behavior
Line 24: Analyze a single file with pylint - CRITICAL for zero-degradation compliance
Line 30: Disable some docstring warnings for cleaner output
Line 39: Parse JSON output - pylint returns array of messages
Line 41: No issues found
Line 52: Parse pylint JSON output format
Line 61: Categorize messages by type
Line 68: Default to convention
Line 101: Disable some docstring warnings for cleaner output
Line 108: Pylint can have various exit codes, we care about the output regardless
Line 112: No issues found or no Python files
Line 116: Parse pylint JSON output
Line 131: Categorize messages by type
Line 138: Default to warning
Line 168: Extract version line from pylint output
Line 178: Pylint analysis result
Line 189: Individual pylint message
Line 234: Test availability (may or may not be installed)
Line 254: Create a Python file with various pylint issues
Line 287: Should find some convention issues at minimum

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4021 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (42/52) - vulture.rs...🔍 DEBUG PROMPT for vulture.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-
- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/vulture.rs
Language: rust
Comments found: 17

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/vulture.rs
Language: rust
Module name: vulture

COMMENTS TO ANALYZE:
Line 1: ! Vulture Dead Code Detector Integration
Line 3: ! Zero-degradation integration with Vulture dead code detector matching Python behavior
Line 41: Only report high-confidence dead code
Line 53: No dead code found
Line 57: Parse vulture output (line-based format)
Line 71: Categorize dead code by type
Line 122: Parse vulture output format: filename:line: unused item 'name' (confidence%)
Line 132: Extract item type and name from message
Line 146: Parse messages like:
Line 147: "unused function 'old_function' (100% confidence)"
Line 148: "unused variable 'unused_var' (90% confidence)"
Line 149: "unused import 'os' (80% confidence)"
Line 169: Extract name between single quotes
Line 184: Extract confidence percentage
Line 251: Test availability (may or may not be installed)
Line 271: Create a Python file with dead code
Line 335: Should find some dead code

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3824 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  82% (43/52) - ripgrep.rs...🔍 DEBUG PROMPT for ripgrep.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-
- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ripgrep.rs
Language: rust
Comments found: 43

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ripgrep.rs
Language: rust
Module name: ripgrep

COMMENTS TO ANALYZE:
Line 9: Ripgrep integration for fast text search and pattern analysis
Line 15: A match found by ripgrep
Line 18: The file path where the match was found
Line 20: Line number (1-indexed)
Line 22: Column number (1-indexed)
Line 24: The matched text
Line 26: The full line containing the match
Line 28: The pattern that was matched
Line 32: Results from ripgrep search
Line 35: List of matches found
Line 39: Whether the search was successful
Line 41: Error message if any
Line 45: Search statistics from ripgrep
Line 48: Total number of matches found
Line 50: Number of files with matches
Line 52: Number of files searched
Line 54: Search time in milliseconds
Line 59: Create a new ripgrep tool instance
Line 66: Search for a pattern in the codebase
Line 71: Search with custom options
Line 102: Add the pattern and path
Line 142: ripgrep doesn't provide this in JSON output
Line 151: Parse a ripgrep JSON match entry
Line 172: Convert to 1-indexed
Line 181: Fallback if JSON parsing fails
Line 192: Check if ripgrep is available
Line 202: Get ripgrep version
Line 218: Options for ripgrep search
Line 221: Case insensitive search
Line 223: Word boundary matching
Line 227: File type filter (e.g., "py", "js", "rs")
Line 229: Glob pattern for file filtering
Line 231: Maximum number of matches per file
Line 240: Default analysis: search for common patterns that might indicate code issues
Line 334: Case sensitive search should not find 'todo'
Line 340: Only the comment
Line 342: Case insensitive should find both
Line 362: Should find TODO, FIXME, XXX
Line 382: Should only find matches in Python files
Line 390: Test if ripgrep is available (may fail in some test environments)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4635 characters
🤖 Analyzing: [██████████████████████████████████████████░░░░░░░░]  84% (44/52) - bandit.rs...🔍 DEBUG PROMPT for bandit.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-
- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/bandit.rs
Language: rust
Comments found: 34

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/bandit.rs
Language: rust
Module name: bandit

COMMENTS TO ANALYZE:
Line 1: ! Bandit Security Analyzer Integration
Line 3: ! Zero-degradation integration with Bandit security scanner matching Python behavior
Line 23: Analyze a single file with bandit - CRITICAL for zero-degradation security compliance
Line 30: Quiet (no progress bar)
Line 38: Parse JSON output
Line 40: No issues found
Line 53: Parse bandit JSON output format
Line 64: Categorize issues by severity and confidence
Line 81: Convert to simplified format
Line 107: Analyze a directory with bandit - wrapper around analyze() for compatibility
Line 109: Since bandit always analyzes the full codebase, just call analyze()
Line 133: Quiet (no progress bar)
Line 143: Bandit returns non-zero exit code when issues are found, which is expected
Line 145: No issues found or no Python files
Line 149: Parse bandit JSON output
Line 163: Count issues by severity
Line 169: Default to low
Line 173: Convert to simplified format
Line 194: TODO: Calculate from issues
Line 195: TODO: Calculate from issues
Line 196: TODO: Calculate from issues
Line 221: Bandit JSON output structures
Line 319: Test availability (may or may not be installed)
Line 339: Create a Python file with security issues
Line 395: Should find multiple security issues in the insecure code
Line 404: Create a Python file without security issues
Line 434: Should find few or no security issues in secure code
Line 435: May still have minor issues

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4356 characters
🤖 Analyzing: [███████████████████████████████████████████░░░░░░░]  86% (45/52) - clippy.rs...🔍 DEBUG PROMPT for clippy.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: This file serves as a powerful query engine for code analysis in Rust, specifically using tree-sitter grammars and queries. It enables automated language detection, application of specific queries bas
- mod.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/pattern/mod.rs serves as the pattern detection module for the CodeHUD Rust project, providing functionalities to identify anti-
- cargo_test.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/cargo_test.rs is designed for integrating with the Cargo test runner in Rust, akin to pytest for Python. It prov
- ruff.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/ruff.rs serves as an integration between the CodeHUD Rust project and the Ruff linter, a Python static code anal
- coverage.rs: This file, coverage.rs in the CodeHUD project, is designed to integrate with Coverage.py for test coverage analysis and calculation of quality metrics. The main purpose it serves is to provide a zero-
- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/clippy.rs
Language: rust
Comments found: 14

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/clippy.rs
Language: rust
Module name: clippy

COMMENTS TO ANALYZE:
Line 1: ! Clippy Integration - Rust linter equivalent to ruff/pylint
Line 3: ! Provides integration with cargo clippy for Rust code analysis
Line 11: Clippy integration for Rust code analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 62: Exit code 101 means clippy found issues, which is fine
Line 69: Parse clippy JSON output
Line 97: Count issues by severity
Line 99: Clippy mainly produces warnings
Line 130: Clippy analysis result
Line 140: Individual clippy issue/warning
Line 152: Clippy diagnostic message format
Line 196: Create a Cargo.toml to simulate a Rust project
Line 207: Create a Cargo.toml
Line 212: This will depend on whether clippy is installed in the test environment

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3679 characters
📦 Processing batch 10/11 (5 files)...
🤖 Analyzing: [████████████████████████████████████████████░░░░░░]  88% (46/52) - git.rs...🔍 DEBUG PROMPT for git.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho
- pylint.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs serves as a powerful tool for Rust code analysis, specifically focusing on the Pylint static code anal
- vulture.rs: This file, `vulture.rs` in the CodeHUD Rust project, is designed for integration with Vulture, a dead code detector that matches Python's behavior. It provides functionalities to detect and report hig
- ripgrep.rs: The file `ripgrep.rs` in the CodeHUD Rust project serves as a versatile and powerful text search tool, specifically designed for code analysis. It's built on top of Ripgrep, an ultra-fast, high-precis
- bandit.rs: This file, `bandit.rs` in the CodeHUD Rust project, serves as an integration point for Bandit, a security vulnerability scanner that matches Python's behavior but is specifically designed for detectin
- clippy.rs: This file, clippy.rs in the CodeHUD Rust project, serves as an integration between the CodeHUD Rust project and the Clippy linter for Rust code analysis. It provides integration with cargo clippy for 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/git.rs
Language: rust
Comments found: 16

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/git.rs
Language: rust
Module name: git

COMMENTS TO ANALYZE:
Line 1: ! Git Version Control Integration
Line 3: ! Zero-degradation integration with Git for version control analysis
Line 50: Get repository statistics
Line 53: Get commit history
Line 56: Get file change statistics
Line 59: Get author statistics
Line 62: Get branch information
Line 97: Get total commits
Line 115: Get current branch
Line 129: Get repository status
Line 143: Get last commit info
Line 233: Sort by change count (most changed first)
Line 236: Limit to top 50 most changed files
Line 265: Get all branches
Line 282: Get remote info
Line 427: Test availability (git should be available on most systems)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3558 characters
🤖 Analyzing: [█████████████████████████████████████████████░░░░░]  90% (47/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho
- pylint.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs serves as a powerful tool for Rust code analysis, specifically focusing on the Pylint static code anal
- vulture.rs: This file, `vulture.rs` in the CodeHUD Rust project, is designed for integration with Vulture, a dead code detector that matches Python's behavior. It provides functionalities to detect and report hig
- ripgrep.rs: The file `ripgrep.rs` in the CodeHUD Rust project serves as a versatile and powerful text search tool, specifically designed for code analysis. It's built on top of Ripgrep, an ultra-fast, high-precis
- bandit.rs: This file, `bandit.rs` in the CodeHUD Rust project, serves as an integration point for Bandit, a security vulnerability scanner that matches Python's behavior but is specifically designed for detectin
- clippy.rs: This file, clippy.rs in the CodeHUD Rust project, serves as an integration between the CodeHUD Rust project and the Clippy linter for Rust code analysis. It provides integration with cargo clippy for 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/cache/mod.rs
Language: rust
Comments found: 40

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/cache/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Cache module for CodeHUD core
Line 3: ! This module provides intelligent caching capabilities that must exactly
Line 4: ! match the Python caching behavior for zero degradation compatibility.
Line 11: Cache key for storing analysis results
Line 21: Create a new cache key
Line 31: Generate cache key as string for storage
Line 42: Cache entry with metadata
Line 53: Create a new cache entry
Line 65: Update access statistics
Line 71: Check if cache entry is stale
Line 77: Smart cache implementation that matches Python behavior
Line 86: Create a new smart cache
Line 98: Store data in cache
Line 111: Update cache size tracking
Line 114: Evict old entries if necessary
Line 122: Retrieve data from cache
Line 137: Check if entry is stale
Line 143: Update access statistics
Line 146: Write back updated entry
Line 154: Invalidate cache entries that depend on the given file
Line 163: Check if this cache file depends on the changed file
Line 177: Evict old cache entries to free up space
Line 193: Sort by last modified time (oldest first)
Line 196: Remove oldest entries until we're under the size limit
Line 198: Keep 75% of max size
Line 209: Clear all cache entries
Line 224: Get cache statistics
Line 236: Check if stale
Line 258: Statistics about cache performance
Line 270: Tool cache for external tool results (matches Python ToolCache behavior)
Line 281: Create a new tool cache
Line 290: Store result in cache
Line 295: Evict entries if we exceed max size
Line 301: Retrieve result from cache
Line 305: Check if stale
Line 315: Remove stale entries
Line 328: Evict least recently used entry
Line 339: Clear all entries
Line 387: Store and retrieve

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4588 characters
🤖 Analyzing: [██████████████████████████████████████████████░░░░]  92% (48/52) - view_generator.rs...🔍 DEBUG PROMPT for view_generator.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho
- pylint.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs serves as a powerful tool for Rust code analysis, specifically focusing on the Pylint static code anal
- vulture.rs: This file, `vulture.rs` in the CodeHUD Rust project, is designed for integration with Vulture, a dead code detector that matches Python's behavior. It provides functionalities to detect and report hig
- ripgrep.rs: The file `ripgrep.rs` in the CodeHUD Rust project serves as a versatile and powerful text search tool, specifically designed for code analysis. It's built on top of Ripgrep, an ultra-fast, high-precis
- bandit.rs: This file, `bandit.rs` in the CodeHUD Rust project, serves as an integration point for Bandit, a security vulnerability scanner that matches Python's behavior but is specifically designed for detectin
- clippy.rs: This file, clippy.rs in the CodeHUD Rust project, serves as an integration between the CodeHUD Rust project and the Clippy linter for Rust code analysis. It provides integration with cargo clippy for 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/view_generator.rs
Language: rust
Comments found: 4

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/view_generator.rs
Language: rust
Module name: view_generator

COMMENTS TO ANALYZE:
Line 1: ! View Generator
Line 3: ! Generates formatted output for different view types
Line 17: Generate formatted view output for the specified view type
Line 34: Generate a comprehensive summary view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3160 characters
🤖 Analyzing: [███████████████████████████████████████████████░░░]  94% (49/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho
- pylint.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs serves as a powerful tool for Rust code analysis, specifically focusing on the Pylint static code anal
- vulture.rs: This file, `vulture.rs` in the CodeHUD Rust project, is designed for integration with Vulture, a dead code detector that matches Python's behavior. It provides functionalities to detect and report hig
- ripgrep.rs: The file `ripgrep.rs` in the CodeHUD Rust project serves as a versatile and powerful text search tool, specifically designed for code analysis. It's built on top of Ripgrep, an ultra-fast, high-precis
- bandit.rs: This file, `bandit.rs` in the CodeHUD Rust project, serves as an integration point for Bandit, a security vulnerability scanner that matches Python's behavior but is specifically designed for detectin
- clippy.rs: This file, clippy.rs in the CodeHUD Rust project, serves as an integration between the CodeHUD Rust project and the Clippy linter for Rust code analysis. It provides integration with cargo clippy for 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/mod.rs
Language: rust
Comments found: 26

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Analysis Pipeline
Line 3: ! Main analysis orchestration module that coordinates all extractors
Line 4: ! and generates comprehensive codebase analysis results.
Line 35: Main analysis orchestrator that coordinates all extractors
Line 65: Run comprehensive analysis using all extractors
Line 75: Run all extractors in parallel for better performance
Line 100: Store extracted data
Line 112: Calculate aggregate metrics
Line 116: Calculate health score
Line 125: Extract critical issues
Line 128: Generate focus recommendations
Line 136: Record analysis completion
Line 151: Generate specific view data
Line 248: Use the query engine to perform enhanced tree-sitter analysis
Line 252: Analyze the entire codebase using the enhanced tree-sitter system
Line 262: Extract metrics from topology data
Line 270: Extract metrics from quality data
Line 275: Calculate technical debt ratio based on health score
Line 280: Calculate executable lines (estimate: 70% of total lines)
Line 297: Extract critical quality issues
Line 313: Extract critical security issues
Line 371: Default recommendations if none specific

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4048 characters
🤖 Analyzing: [████████████████████████████████████████████████░░]  96% (50/52) - health_calculator.rs...🔍 DEBUG PROMPT for health_calculator.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file `radon.rs` in the CodeHUD Rust project is designed for integration with Radon, a complexity analyzer that matches Python's behavior. It provides functionalities to run cyclomatic complexity a
- rustfmt.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/rustfmt.rs serves as an integration between the CodeHUD Rust project and the rustfmt tool, a popular Rust code f
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project, serves as an integration point for MyPy type checker (an advanced Python static type-checker), aiming for zero-degradation compatibility with its beha
- mod.rs: This file, `mod.rs` in the CodeHUD Rust project, serves as a comprehensive external tool integration system for managing and running static analysis tools such as ruff, pylint, mypy, bandit, etc., pro
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project, serves as an integration point for the cargo-audit tool, a security vulnerability scanner for Rust. This tool is comparable to bandit for Pytho
- pylint.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs serves as a powerful tool for Rust code analysis, specifically focusing on the Pylint static code anal
- vulture.rs: This file, `vulture.rs` in the CodeHUD Rust project, is designed for integration with Vulture, a dead code detector that matches Python's behavior. It provides functionalities to detect and report hig
- ripgrep.rs: The file `ripgrep.rs` in the CodeHUD Rust project serves as a versatile and powerful text search tool, specifically designed for code analysis. It's built on top of Ripgrep, an ultra-fast, high-precis
- bandit.rs: This file, `bandit.rs` in the CodeHUD Rust project, serves as an integration point for Bandit, a security vulnerability scanner that matches Python's behavior but is specifically designed for detectin
- clippy.rs: This file, clippy.rs in the CodeHUD Rust project, serves as an integration between the CodeHUD Rust project and the Clippy linter for Rust code analysis. It provides integration with cargo clippy for 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/health_calculator.rs
Language: rust
Comments found: 12

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/health_calculator.rs
Language: rust
Module name: health_calculator

COMMENTS TO ANALYZE:
Line 1: ! Health Score Calculator
Line 3: ! Calculates overall codebase health score based on multiple metrics
Line 16: Calculate overall health score (0-100) based on all analysis data
Line 28: Weighted average of all scores
Line 38: Extract health score from quality data if available
Line 45: Fallback calculation based on issues
Line 74: Penalize based on security findings
Line 88: Penalize circular dependencies heavily
Line 97: Penalize high coupling
Line 107: Penalize high average complexity
Line 112: Penalize very high maximum complexity
Line 117: Penalize high technical debt

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3556 characters
📦 Processing batch 11/11 (2 files)...
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (21/52) - pipeline.rs...🔍 DEBUG PROMPT for pipeline.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- pylint.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs serves as a powerful tool for Rust code analysis, specifically focusing on the Pylint static code anal
- vulture.rs: This file, `vulture.rs` in the CodeHUD Rust project, is designed for integration with Vulture, a dead code detector that matches Python's behavior. It provides functionalities to detect and report hig
- ripgrep.rs: The file `ripgrep.rs` in the CodeHUD Rust project serves as a versatile and powerful text search tool, specifically designed for code analysis. It's built on top of Ripgrep, an ultra-fast, high-precis
- bandit.rs: This file, `bandit.rs` in the CodeHUD Rust project, serves as an integration point for Bandit, a security vulnerability scanner that matches Python's behavior but is specifically designed for detectin
- clippy.rs: This file, clippy.rs in the CodeHUD Rust project, serves as an integration between the CodeHUD Rust project and the Clippy linter for Rust code analysis. It provides integration with cargo clippy for 
- git.rs: This Rust file, `git.rs` in the CodeHUD Rust project, serves as a comprehensive Git version control integration system for managing and analyzing code repository data. It offers features such as zero-
- mod.rs: This file serves as the cache module for CodeHUD core, providing intelligent caching capabilities that match Python's behavior for maximum compatibility and efficiency during code analysis tasks. It s
- view_generator.rs: The file `view_generator.rs` in the CodeHUD Rust project, serves as a module responsible for generating formatted output views based on different view types. This includes the generation of comprehens
- mod.rs: This file is the main module in CodeHUD Rust project responsible for orchestrating and managing all analysis operations on a codebase. It serves as an integral part of the overall analysis pipeline, c
- health_calculator.rs: This file, `health_calculator.rs` in the CodeHUD Rust project, serves as a comprehensive health calculator for an overall codebase's quality and security. It calculates an overall score (0-100) based 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/pipeline.rs
Language: rust
Comments found: 8

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/analysis/pipeline.rs
Language: rust
Module name: pipeline

COMMENTS TO ANALYZE:
Line 1: ! Analysis Pipeline Implementation
Line 3: ! Handles different analysis pipeline types (direct, legacy, etc.)
Line 13: Run analysis using the specified pipeline
Line 20: Fast, direct extraction pipeline
Line 24: Legacy pipeline with full processing (future implementation)
Line 25: For now, use the same pipeline but could be extended
Line 29: Hybrid analysis pipeline (future implementation)
Line 35: Run analysis for a specific view only

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3398 characters
🤖 Analyzing: [█████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  42% (22/52) - extraction_benchmarks.rs...🔍 DEBUG PROMPT for extraction_benchmarks.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- pylint.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/src/external_tools/pylint.rs serves as a powerful tool for Rust code analysis, specifically focusing on the Pylint static code anal
- vulture.rs: This file, `vulture.rs` in the CodeHUD Rust project, is designed for integration with Vulture, a dead code detector that matches Python's behavior. It provides functionalities to detect and report hig
- ripgrep.rs: The file `ripgrep.rs` in the CodeHUD Rust project serves as a versatile and powerful text search tool, specifically designed for code analysis. It's built on top of Ripgrep, an ultra-fast, high-precis
- bandit.rs: This file, `bandit.rs` in the CodeHUD Rust project, serves as an integration point for Bandit, a security vulnerability scanner that matches Python's behavior but is specifically designed for detectin
- clippy.rs: This file, clippy.rs in the CodeHUD Rust project, serves as an integration between the CodeHUD Rust project and the Clippy linter for Rust code analysis. It provides integration with cargo clippy for 
- git.rs: This Rust file, `git.rs` in the CodeHUD Rust project, serves as a comprehensive Git version control integration system for managing and analyzing code repository data. It offers features such as zero-
- mod.rs: This file serves as the cache module for CodeHUD core, providing intelligent caching capabilities that match Python's behavior for maximum compatibility and efficiency during code analysis tasks. It s
- view_generator.rs: The file `view_generator.rs` in the CodeHUD Rust project, serves as a module responsible for generating formatted output views based on different view types. This includes the generation of comprehens
- mod.rs: This file is the main module in CodeHUD Rust project responsible for orchestrating and managing all analysis operations on a codebase. It serves as an integral part of the overall analysis pipeline, c
- health_calculator.rs: This file, `health_calculator.rs` in the CodeHUD Rust project, serves as a comprehensive health calculator for an overall codebase's quality and security. It calculates an overall score (0-100) based 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/benches/extraction_benchmarks.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core/benches/extraction_benchmarks.rs
Language: rust
Module name: extraction_benchmarks

COMMENTS TO ANALYZE:
Line 1: ! Extraction performance benchmarks for zero-degradation validation
Line 6: TODO: Implement extraction benchmarks for performance validation
Line 7: This is critical for zero-degradation requirements

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3187 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (52/52) - Complete!
✅ Phase 2 complete: 52 files analyzed with enhanced context
📄 File summaries updated: 59 total files (52 from codehud-core)
📄 Analysis metadata updated: 3 crates processed
🔍 DEBUG: Crate path for codehud-gui: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui
🔍 Processing 62 files from crate codehud-gui
🔍 DEBUG: First 5 files discovered for crate codehud-gui:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/signals.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/health_view_gui.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/topology_view_gui.rs
  4. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/metrics_view_gui.rs
  5. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/tests_view_gui.rs
🧠 Running narrator on 24 files in batch...
🔍 DEBUG: Found 10 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/signals.rs
🔍 DEBUG: Bullet text length: 381 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/signals.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/health_view_gui.rs
🔍 DEBUG: Bullet text length: 262 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/health_view_gui.rs
🔍 DEBUG: Found 13 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/topology_view_gui.rs
🔍 DEBUG: Bullet text length: 578 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/topology_view_gui.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/metrics_view_gui.rs
🔍 DEBUG: Bullet text length: 253 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/metrics_view_gui.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/tests_view_gui.rs
🔍 DEBUG: Bullet text length: 262 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/tests_view_gui.rs
🔍 DEBUG: Found 14 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/dependencies_view_gui.rs
🔍 DEBUG: Bullet text length: 635 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/dependencies_view_gui.rs
🔍 DEBUG: Found 8 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/console_view_gui.rs
🔍 DEBUG: Bullet text length: 370 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/console_view_gui.rs
🔍 DEBUG: Found 22 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/mod.rs
🔍 DEBUG: Bullet text length: 1123 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/mod.rs
🔍 DEBUG: Found 15 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/llm_view_gui.rs
🔍 DEBUG: Bullet text length: 710 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/llm_view_gui.rs
🔍 DEBUG: Found 14 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/quality_view_gui.rs
🔍 DEBUG: Bullet text length: 627 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/quality_view_gui.rs
🔍 DEBUG: Found 7 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/documentation_view_gui.rs
🔍 DEBUG: Bullet text length: 349 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/documentation_view_gui.rs
🔍 DEBUG: Found 9 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/settings_view_gui.rs
🔍 DEBUG: Bullet text length: 470 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/settings_view_gui.rs
🔍 DEBUG: Found 16 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/performance_view_gui.rs
🔍 DEBUG: Bullet text length: 695 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/performance_view_gui.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/files_view_gui.rs
🔍 DEBUG: Bullet text length: 310 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/files_view_gui.rs
🔍 DEBUG: Found 10 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/main.rs
🔍 DEBUG: Bullet text length: 408 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/main.rs
🔍 DEBUG: Found 16 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/state.rs
🔍 DEBUG: Bullet text length: 586 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/state.rs
🔍 DEBUG: Found 7 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/utils.rs
🔍 DEBUG: Bullet text length: 379 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/utils.rs
🔍 DEBUG: Found 11 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/lib.rs
🔍 DEBUG: Bullet text length: 436 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/lib.rs
🔍 DEBUG: Found 2 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/controllers/mod.rs
🔍 DEBUG: Bullet text length: 167 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/controllers/mod.rs
🔍 DEBUG: Found 21 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/controllers/analysis_controller.rs
🔍 DEBUG: Bullet text length: 1233 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/controllers/analysis_controller.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/quality_dashboard.rs
🔍 DEBUG: Bullet text length: 303 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/quality_dashboard.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/code_formatter.rs
🔍 DEBUG: Bullet text length: 303 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/code_formatter.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/code_editor.rs
🔍 DEBUG: Bullet text length: 303 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/code_editor.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/plugin_manager.rs
🔍 DEBUG: Bullet text length: 303 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/plugin_manager.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 83 total files (24 from codehud-gui)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-gui...
🤖 Analyzing 24 files with enhanced context and improved token limits...
📦 Processing batch 1/5 (5 files)...
🤖 Analyzing: [██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   4% (1/24) - health_view_gui.rs...🔍 DEBUG PROMPT for health_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/health_view_gui.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/health_view_gui.rs
Language: rust
Module name: health_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Health View GUI
Line 3: ! Displays overall codebase health metrics and status indicators.
Line 10: Health status view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 830 characters
🤖 Analyzing: [████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   8% (2/24) - topology_view_gui.rs...🔍 DEBUG PROMPT for topology_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/topology_view_gui.rs
Language: rust
Comments found: 41

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/topology_view_gui.rs
Language: rust
Module name: topology_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Topology View - Exact Python Implementation Equivalent
Line 3: ! Displays architectural topology and file structure analysis.
Line 4: ! This is a zero-degradation implementation of the Python TopologyView.
Line 12: Topology analysis view - exact Python TopologyView equivalent
Line 17: UI state matching Python implementation
Line 25: Topology data structure matching Python analysis output
Line 75: Setup topology view UI - exact Python setup_content_ui equivalent
Line 77: Vertical layout with splitter equivalent
Line 79: Top: Summary metrics (Python create_summary_section equivalent)
Line 87: Bottom: File details table (Python create_file_table equivalent)
Line 98: Create summary section - exact Python create_summary_section equivalent
Line 137: File type breakdown (matching Python implementation)
Line 153: Create file table - exact Python create_file_table equivalent
Line 159: Table header (matching Python QTableWidget columns)
Line 184: File table content
Line 208: Show file details if selected (matching Python behavior)
Line 234: Sort table by column - exact Python table sorting equivalent
Line 263: Update data from analysis results - exact Python update_data equivalent
Line 265: Parse JSON data into TopologyData structure
Line 271: Parse topology data from JSON - Python data processing equivalent
Line 273: Extract data from JSON (matching Python data structure)
Line 282: Parse file types
Line 292: Parse complexity metrics
Line 313: Parse file details
Line 323: Parse dependency graph (if available)
Line 324: TODO: Parse from JSON
Line 371: Render view - exact Python rendering equivalent
Line 379: Handle incoming messages
Line 384: Get the view title
Line 389: Called when view becomes active (optional)
Line 394: Called when view becomes inactive (optional)
Line 399: Called when view is being closed (optional)
Line 401: true = allow close
Line 406: Update topology data
Line 407: Equivalent to update_topology_data() in Python version
Line 409: Convert from AppState topology data to view format if needed
Line 414: Update topology data if available in state
Line 416: Convert from state topology data to view format
Line 417: This would match the Python update mechanism

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2922 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  12% (3/24) - metrics_view_gui.rs...🔍 DEBUG PROMPT for metrics_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/metrics_view_gui.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/metrics_view_gui.rs
Language: rust
Module name: metrics_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Metrics View GUI
Line 3: ! Displays comprehensive code metrics and analysis data.
Line 10: Metrics analysis view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 828 characters
🤖 Analyzing: [████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  16% (4/24) - tests_view_gui.rs...🔍 DEBUG PROMPT for tests_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/tests_view_gui.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/tests_view_gui.rs
Language: rust
Module name: tests_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Tests View GUI
Line 3: ! Displays test results, coverage metrics, and test management interface.
Line 10: Test results and coverage interface
Line 56: Toggle coverage view
Line 75: Trigger test run
Line 78: Refresh test results
Line 81: Generate coverage report

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 971 characters
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (5/24) - dependencies_view_gui.rs...🔍 DEBUG PROMPT for dependencies_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/dependencies_view_gui.rs
Language: rust
Comments found: 32

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/dependencies_view_gui.rs
Language: rust
Module name: dependencies_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Dependencies View GUI
Line 3: ! Displays module dependencies and coupling analysis with proper GUI components.
Line 12: Dependencies analysis data structure matching Python implementation
Line 63: Dependencies and coupling analysis view matching Python DependenciesView
Line 68: PyQt5-style signals matching Python implementation
Line 77: Create new dependencies view matching Python constructor
Line 88: Get view title matching Python get_view_title
Line 93: Update content with analysis data matching Python update_content
Line 99: Render overview metrics section matching Python create_overview_section
Line 106: Left: Summary metrics matching Python metrics_widget
Line 137: Right: Coupling distribution matching Python dist_widget
Line 146: Low coupling bar
Line 156: Medium coupling bar
Line 166: High coupling bar
Line 183: Render dependencies table matching Python create_dependencies_table
Line 199: Dependencies table matching Python table structure
Line 207: Table headers matching Python setHorizontalHeaderLabels
Line 214: Sort dependencies by coupling score if enabled
Line 226: Display table rows matching Python update_dependencies_table
Line 228: Module name (clickable)
Line 239: Coupling score with color coding
Line 249: Risk level with background color matching Python implementation
Line 257: Create colored background label
Line 270: Render selected module details panel
Line 337: Main layout matching Python splitter structure (vertical split)
Line 339: Top: Overview metrics matching Python create_overview_section
Line 344: Bottom: Dependencies table matching Python create_dependencies_table
Line 347: Details panel for selected module
Line 360: Dependencies data might be updated with topology

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2453 characters
📦 Processing batch 2/5 (5 files)...
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (6/24) - console_view_gui.rs...🔍 DEBUG PROMPT for console_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/console_view_gui.rs
Language: rust
Comments found: 5

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/console_view_gui.rs
Language: rust
Module name: console_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Console View GUI
Line 3: ! Displays console output and command execution interface.
Line 10: Console output and command interface

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2077 characters
🤖 Analyzing: [██████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  29% (7/24) - llm_view_gui.rs...🔍 DEBUG PROMPT for llm_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/llm_view_gui.rs
Language: rust
Comments found: 44

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/llm_view_gui.rs
Language: rust
Module name: llm_view_gui

COMMENTS TO ANALYZE:
Line 1: ! LLM/Auto Debugger View GUI
Line 3: ! Provides GUI interface for LLM-powered debugging and auto-fixing capabilities.
Line 4: ! Note: LLM functionality temporarily disabled for compilation - will be re-enabled in Phase 5b.
Line 12: LLM operation data structure matching Python implementation
Line 21: Auto-fix operation types matching Python implementation
Line 42: LLM-powered debugging and auto-fixing interface matching Python LLMDebuggerView
Line 47: PyQt5-style signals matching Python implementation
Line 51: UI state matching Python tabs
Line 55: Tab content matching Python implementation
Line 66: Create new LLM view matching Python constructor
Line 85: Get view title matching Python get_view_title
Line 90: Update content matching Python update_content
Line 95: Render auto-fix tab matching Python create_autofix_tab
Line 101: Fix type selection matching Python fix_type_combo
Line 123: Action buttons matching Python implementation
Line 134: Progress bar matching Python autofix_progress
Line 143: Output area matching Python autofix_output
Line 161: Render pattern detection tab matching Python create_patterns_tab
Line 171: Patterns output matching Python patterns_output
Line 183: Render code search tab matching Python create_search_tab
Line 189: Search type selection matching Python search_type_combo
Line 200: Query input matching Python search_query
Line 217: Search results matching Python search_output
Line 225: Render system status tab matching Python create_status_tab
Line 247: Status output matching Python status_output
Line 259: Render view renderer tab matching Python create_view_renderer_tab
Line 265: View selection matching Python view_combo
Line 285: View output matching Python view_output
Line 297: Run auto-fix operation matching Python run_autofix
Line 315: Simulate completion (in real implementation, this would be async)
Line 322: Stop running operation matching Python stop_command
Line 330: Detect patterns matching Python detect_patterns
Line 335: Run search matching Python run_search
Line 341: Simulate search results
Line 345: This would be displayed in search results area
Line 348: Refresh status matching Python refresh_status
Line 353: View dashboard matching Python view_dashboard
Line 358: Check pylint status matching Python check_pylint_status
Line 363: List views matching Python list_views
Line 368: Render view matching Python render_view
Line 377: Tab widget matching Python tab structure
Line 388: Render active tab content matching Python tab implementation
Line 406: Handle LLM request (would be implemented when LLM is re-enabled)
Line 410: Handle LLM response (would be implemented when LLM is re-enabled)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4605 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (8/24) - quality_view_gui.rs...🔍 DEBUG PROMPT for quality_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/quality_view_gui.rs
Language: rust
Comments found: 28

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/quality_view_gui.rs
Language: rust
Module name: quality_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Quality View GUI
Line 3: ! Displays code quality metrics, maintainability index, and technical debt analysis.
Line 12: Quality metrics data structure
Line 47: Quality Analysis GUI View matching Python QualityView implementation
Line 63: Create new quality view matching Python constructor
Line 76: Get view title matching Python implementation
Line 81: Update content with analysis data (matching Python update_content)
Line 87: Render quality overview section (matching Python UI structure)
Line 93: Quality score display
Line 149: Render code smells table (matching Python implementation)
Line 170: Code smells table
Line 185: Filter and display smells
Line 221: Render details panel (matching Python implementation)
Line 272: Main layout matching Python splitter structure
Line 274: Top section: Quality overview
Line 279: Middle section: Code smells table
Line 284: Bottom section: Details panel
Line 289: Toggle details panel button
Line 303: Refresh quality data from state
Line 304: This would typically fetch new data from the analysis engine

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2999 characters
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  37% (9/24) - documentation_view_gui.rs...🔍 DEBUG PROMPT for documentation_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/documentation_view_gui.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/documentation_view_gui.rs
Language: rust
Module name: documentation_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Documentation View GUI
Line 3: ! Displays documentation coverage, generates docs, and manages documentation.
Line 10: Documentation management interface
Line 43: Generate coverage report
Line 61: Documentation content viewer

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2190 characters
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  41% (10/24) - settings_view_gui.rs...🔍 DEBUG PROMPT for settings_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/settings_view_gui.rs
Language: rust
Comments found: 10

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/settings_view_gui.rs
Language: rust
Module name: settings_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Settings View GUI
Line 3: ! Displays application settings and configuration options.
Line 10: Application settings and configuration

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2084 characters
📦 Processing batch 3/5 (5 files)...
🤖 Analyzing: [██████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  45% (11/24) - performance_view_gui.rs...🔍 DEBUG PROMPT for performance_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s
- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/performance_view_gui.rs
Language: rust
Comments found: 31

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/performance_view_gui.rs
Language: rust
Module name: performance_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Performance View GUI
Line 3: ! Displays performance analysis, bottlenecks, and optimization opportunities.
Line 12: Performance analysis data structure matching Python implementation
Line 100: Performance analysis view matching Python PerformanceView
Line 105: PyQt5-style signals matching Python implementation
Line 113: Create new performance view matching Python constructor
Line 123: Get view title matching Python get_view_title
Line 128: Update content with analysis data matching Python update_content
Line 134: Render performance dashboard matching Python create_performance_dashboard
Line 137: Performance score section matching Python score_section
Line 150: Large score display matching Python implementation
Line 161: Performance metrics matching Python metrics_section
Line 205: Optimization opportunities matching Python opportunities_section
Line 239: Render bottlenecks table matching Python create_bottlenecks_table
Line 245: Bottlenecks table matching Python table structure
Line 253: Table headers matching Python setHorizontalHeaderLabels
Line 261: Display bottlenecks matching Python update_bottlenecks_table
Line 263: Impact level with color coding
Line 299: Complexity with color coding
Line 318: Render selected bottleneck details panel
Line 379: Main layout matching Python splitter structure (horizontal split)
Line 381: Left: Performance dashboard matching Python create_performance_dashboard
Line 392: Right: Bottlenecks table matching Python create_bottlenecks_table
Line 399: Details panel for selected bottleneck
Line 414: Performance data might be updated after analysis

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4686 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (12/24) - files_view_gui.rs...🔍 DEBUG PROMPT for files_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s
- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/files_view_gui.rs
Language: rust
Comments found: 8

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/views/files_view_gui.rs
Language: rust
Module name: files_view_gui

COMMENTS TO ANALYZE:
Line 1: ! Files View GUI
Line 3: ! Displays file browser and file management interface.
Line 10: File browser and management interface
Line 47: File tree (simplified)
Line 54: Simulate file tree structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3259 characters
🤖 Analyzing: [███████████████████████████░░░░░░░░░░░░░░░░░░░░░░░]  54% (13/24) - state.rs...🔍 DEBUG PROMPT for state.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s
- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/state.rs
Language: rust
Comments found: 26

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/state.rs
Language: rust
Module name: state

COMMENTS TO ANALYZE:
Line 2: use codehud_core::{CoreEngine, ProjectMetrics};  // Temporarily disabled
Line 3: use codehud_llm::LlmEngine;  // Temporarily disabled
Line 17: pub core_engine: Option<Arc<RwLock<CoreEngine>>>,  // Temporarily disabled
Line 18: pub llm_engine: Option<Arc<RwLock<LlmEngine>>>,  // Temporarily disabled
Line 45: pub metrics: Option<ProjectMetrics>,  // Temporarily disabled
Line 266: Initialize core engine (temporarily disabled)
Line 267: let core_engine = CoreEngine::new().await
Line 269: self.core_engine = Some(Arc::new(RwLock::new(core_engine)));
Line 271: Initialize LLM engine (temporarily disabled)
Line 272: let llm_engine = LlmEngine::new().await
Line 274: self.llm_engine = Some(Arc::new(RwLock::new(llm_engine)));
Line 294: Add to recent projects
Line 305: Simple language detection based on file extensions
Line 350: Default visible components
Line 361: Default hidden components

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3915 characters
🤖 Analyzing: [█████████████████████████████░░░░░░░░░░░░░░░░░░░░░]  58% (14/24) - utils.rs...🔍 DEBUG PROMPT for utils.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s
- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/utils.rs
Language: rust
Comments found: 19

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/utils.rs
Language: rust
Module name: utils

COMMENTS TO ANALYZE:
Line 5: Base trait for all GUI views matching PyQt5 widget pattern
Line 7: Render the view content
Line 10: Handle incoming messages
Line 13: Get the view title
Line 16: Called when view becomes active (optional)
Line 21: Called when view becomes inactive (optional)
Line 26: Called when view is being closed (optional)
Line 28: true = allow close
Line 32: Base trait for GUI components matching PyQt5 widget pattern
Line 34: Get component name
Line 37: Render the component
Line 40: Handle incoming messages
Line 43: Get component visibility
Line 46: Set component visibility
Line 49: Get component enabled state
Line 52: Set component enabled state
Line 144: Weighted average of different health aspects
Line 145: performance, quality, security, maintainability

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3780 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  62% (15/24) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, health_view_gui.rs, is a part of the CodeHUD GUI source code written in Rust. It serves as the graphical user interface for displaying overall codebase health metrics and status indicators.
- topology_view_gui.rs: This Rust file, `topology_view_gui`, is designed for architectural topology and file structure analysis in the context of a GUI application. It provides an exact Python TopologyView equivalent with de
- metrics_view_gui.rs: The metrics_view_gui file is a part of the CodeHUD GUI application, primarily designed for displaying comprehensive code metrics and analysis data. It provides users with real-time insights into their
- tests_view_gui.rs: This Rust file, 'tests_view_gui', serves as the graphical user interface (GUI) for displaying test results, coverage metrics, and managing tests. It displays test results and coverage interfaces in a 
- dependencies_view_gui.rs: The file `dependencies_view_gui` is a Rust implementation of an interface for visualizing module dependencies and coupling analysis, with a user-friendly GUI component. It displays detailed metrics, s
- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/lib.rs
Language: rust
Comments found: 1

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 56: Traits moved to utils.rs to avoid duplication

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3064 characters
📦 Processing batch 4/5 (5 files)...
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (16/24) - analysis_controller.rs...🔍 DEBUG PROMPT for analysis_controller.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh
- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/controllers/analysis_controller.rs
Language: rust
Comments found: 35

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/controllers/analysis_controller.rs
Language: rust
Module name: analysis_controller

COMMENTS TO ANALYZE:
Line 1: ! Analysis Controller - Exact Python Implementation Equivalent
Line 3: ! This module provides the exact equivalent of the Python AnalysisController
Line 4: ! with QThread background processing for zero-degradation compliance.
Line 17: Analysis progress information matching Python AnalysisWorker
Line 28: Analysis results matching Python AnalysisController output
Line 45: Background worker thread matching Python AnalysisWorker exactly
Line 52: PyQt5-style signals matching Python implementation
Line 59: Create new analysis worker - exact Python constructor equivalent
Line 76: Start the worker thread - exact Python start() method
Line 86: Run analysis - exact Python run() method equivalent
Line 90: Emit initial progress
Line 100: Create analysis results structure
Line 164: Stop the worker thread
Line 169: Wait for worker to finish
Line 174: Check if worker is running
Line 182: Signals are created in constructor
Line 187: Connect any internal signals
Line 197: Main analysis controller matching Python AnalysisController exactly
Line 203: PyQt5-style signals matching Python implementation
Line 211: Create new analysis controller matching Python constructor
Line 224: Set codebase path
Line 229: Start analysis matching Python start_analysis method
Line 232: Stop any running analysis
Line 240: Create new worker
Line 266: Emit started signal
Line 276: Stop current analysis - exact Python method equivalent
Line 287: Check if analysis is running
Line 294: Get codebase path
Line 302: Signals are created in constructor
Line 307: Connect any internal signals

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4623 characters
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  70% (17/24) - menu_bar.rs...🔍 DEBUG PROMPT for menu_bar.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh
- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/menu_bar.rs
Language: rust
Comments found: 7

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/menu_bar.rs
Language: rust
Module name: menu_bar

NO MEANINGFUL COMMENTS FOUND - ANALYZING FILE STRUCTURE ONLY:

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3051 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (18/24) - project_explorer.rs...🔍 DEBUG PROMPT for project_explorer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh
- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/project_explorer.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/project_explorer.rs
Language: rust
Module name: project_explorer

COMMENTS TO ANALYZE:
Line 35: Group files by directory
Line 51: Render direct files first
Line 155: Try to read state without blocking
Line 163: Render project info
Line 168: Render file tree

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3205 characters
🤖 Analyzing: [███████████████████████████████████████░░░░░░░░░░░]  79% (19/24) - llm_debugger.rs...🔍 DEBUG PROMPT for llm_debugger.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh
- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/llm_debugger.rs
Language: rust
Comments found: 15

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/llm_debugger.rs
Language: rust
Module name: llm_debugger

COMMENTS TO ANALYZE:
Line 24: Hidden by default
Line 84: Skip system messages if not showing them
Line 116: Metadata (if enabled)
Line 195: Try to read state without blocking
Line 254: Main content area
Line 256: Left panel - conversation list
Line 278: Right panel - conversation content and input

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3301 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  83% (20/24) - health_monitor.rs...🔍 DEBUG PROMPT for health_monitor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: The file console_view_gui in the CodeHUD GUI application is designed for displaying and executing commands within a console-like interface. It provides an interactive environment where users can execu
- llm_view_gui.rs: This Rust file, `llm_view_gui`, is a graphical user interface for leveraging Language Model-powered debugging and auto-fixing capabilities in the context of a GUI application. It provides an interface
- quality_view_gui.rs: The file 'quality_view_gui' is a Rust-based GUI application that serves as the graphical user interface for displaying code quality metrics, maintainability index, and technical debt analysis. It prov
- documentation_view_gui.rs: The file 'documentation_view_gui' in the CodeHUD GUI application is designed for documentation coverage analysis and management, providing a comprehensive interface for users to generate documentation
- settings_view_gui.rs: The settings_view_gui file is a part of the CodeHUD GUI application, specifically designed for managing and configuring various settings and preferences of the application. It displays an interface wh
- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/health_monitor.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/components/health_monitor.rs
Language: rust
Module name: health_monitor

COMMENTS TO ANALYZE:
Line 30: Overall health score
Line 241: Try to read state without blocking
Line 296: Health monitor is always enabled
Line 300: Health monitor cannot be disabled

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3190 characters
📦 Processing batch 5/5 (4 files)...
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  70% (17/24) - app.rs...🔍 DEBUG PROMPT for app.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi
- analysis_controller.rs: This file, analysis_controller.rs, implements a Rust version of the Analysis Controller for the CodeHUD GUI application. It provides an exact equivalent to the Python AnalysisController with QThread b
- menu_bar.rs: The file menu_bar.rs in the CodeHUD GUI application is responsible for managing and presenting a set of menus within the user interface. This includes creating, controlling, and updating various types
- project_explorer.rs: This file, project_explorer.rs in the CodeHUD GUI application, serves as a component responsible for managing and visualizing files within the system. It implements specific features that group files 
- llm_debugger.rs: The file llm_debugger.rs in the CodeHUD GUI project is designed to manage and display the functionalities related to Language Model-powered debugging and auto-fixing capabilities within a console-like
- health_monitor.rs: The file health_monitor.rs in the CodeHUD GUI project is designed for monitoring and reporting on various aspects of its system's overall health, including code quality, performance, and execution sta

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/app.rs
Language: rust
Comments found: 18

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/app.rs
Language: rust
Module name: app

COMMENTS TO ANALYZE:
Line 17: Core components (25+ as per plan)
Line 44: Views (11+ as per plan)
Line 76: Initialize all 25+ components
Line 121: Set up signal connections (PyQt5-style signal/slot architecture)
Line 129: Connect project explorer signals to other components
Line 140: Connect LLM signals
Line 151: Connect quality update signals
Line 192: Tab bar for switching between views
Line 203: Render active view
Line 215: Initialize immediately to skip loading screen
Line 219: Process signals (skip for now to avoid potential issues)
Line 220: if let Err(e) = self.signal_bus.process_pending() {
Line 221: log::error!("Error processing signals: {}", e);
Line 224: Render main layout
Line 233: Save application state

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3664 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (18/24) - project_explorer.rs...🔍 DEBUG PROMPT for project_explorer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi
- analysis_controller.rs: This file, analysis_controller.rs, implements a Rust version of the Analysis Controller for the CodeHUD GUI application. It provides an exact equivalent to the Python AnalysisController with QThread b
- menu_bar.rs: The file menu_bar.rs in the CodeHUD GUI application is responsible for managing and presenting a set of menus within the user interface. This includes creating, controlling, and updating various types
- project_explorer.rs: This file, project_explorer.rs in the CodeHUD GUI application, serves as a component responsible for managing and visualizing files within the system. It implements specific features that group files 
- llm_debugger.rs: The file llm_debugger.rs in the CodeHUD GUI project is designed to manage and display the functionalities related to Language Model-powered debugging and auto-fixing capabilities within a console-like
- health_monitor.rs: The file health_monitor.rs in the CodeHUD GUI project is designed for monitoring and reporting on various aspects of its system's overall health, including code quality, performance, and execution sta

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/widgets/project_explorer.rs
Language: rust
Comments found: 51

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/widgets/project_explorer.rs
Language: rust
Module name: project_explorer

COMMENTS TO ANALYZE:
Line 1: ! Project Explorer Widget - Exact Python Implementation Equivalent
Line 3: ! File tree navigation with health indicators and context menu.
Line 4: ! This is a zero-degradation implementation of the Python ProjectExplorer.
Line 18: Project file explorer with health indicators - exact Python ProjectExplorer equivalent
Line 23: UI state matching Python implementation
Line 30: Health indicators (matching Python health indicators)
Line 38: File tree node structure matching Python QStandardItem model
Line 51: Create new project explorer - exact Python constructor equivalent
Line 67: Initialize user interface - exact Python init_ui equivalent
Line 70: Header (matching Python QLabel header)
Line 82: Search box (exact Python QLineEdit equivalent)
Line 93: File tree (exact Python QTreeView equivalent)
Line 100: Status information (matching Python status display)
Line 123: Render file tree - exact Python QTreeView rendering equivalent
Line 140: Render individual file node - exact Python QStandardItem equivalent
Line 146: Directory node with collapsible header (matching Python tree expansion)
Line 160: Update expansion state
Line 166: File node (matching Python file item)
Line 168: File icon based on type
Line 172: File name with selection
Line 179: Health indicator (matching Python health indicators)
Line 185: File size (if available)
Line 193: Context menu for selected files (matching Python context menu)
Line 198: Open file for viewing
Line 201: Open file for editing
Line 204: Analyze individual file
Line 214: Get file icon based on extension - exact Python icon logic
Line 235: Convert health score to color - exact Python health indicator colors
Line 248: Format file size - exact Python file size formatting
Line 262: Load project - exact Python load_project equivalent
Line 270: Build file tree model - exact Python QStandardItemModel building
Line 280: Scan directory recursively - exact Python directory scanning
Line 292: Skip hidden files unless explicitly shown
Line 302: Recursive directory scan (with depth limit)
Line 323: Sort children: directories first, then files (matching Python sorting)
Line 343: Root is always expanded
Line 347: Load health indicators - exact Python health indicator loading
Line 349: TODO: Load health scores from analysis results
Line 350: This would integrate with the analysis controller to get health data
Line 354: Filter file tree based on search - exact Python search filtering
Line 357: Show all files
Line 361: TODO: Implement search filtering logic matching Python
Line 364: Count files in tree
Line 381: Count folders in tree
Line 401: Signals are created in constructor
Line 406: Signal connections would be set up by parent components

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5727 characters
🤖 Analyzing: [███████████████████████████████████████░░░░░░░░░░░]  79% (19/24) - health_dashboard.rs...🔍 DEBUG PROMPT for health_dashboard.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi
- analysis_controller.rs: This file, analysis_controller.rs, implements a Rust version of the Analysis Controller for the CodeHUD GUI application. It provides an exact equivalent to the Python AnalysisController with QThread b
- menu_bar.rs: The file menu_bar.rs in the CodeHUD GUI application is responsible for managing and presenting a set of menus within the user interface. This includes creating, controlling, and updating various types
- project_explorer.rs: This file, project_explorer.rs in the CodeHUD GUI application, serves as a component responsible for managing and visualizing files within the system. It implements specific features that group files 
- llm_debugger.rs: The file llm_debugger.rs in the CodeHUD GUI project is designed to manage and display the functionalities related to Language Model-powered debugging and auto-fixing capabilities within a console-like
- health_monitor.rs: The file health_monitor.rs in the CodeHUD GUI project is designed for monitoring and reporting on various aspects of its system's overall health, including code quality, performance, and execution sta

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/widgets/health_dashboard.rs
Language: rust
Comments found: 17

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/widgets/health_dashboard.rs
Language: rust
Module name: health_dashboard

COMMENTS TO ANALYZE:
Line 1: ! Health Dashboard Widget
Line 3: ! Displays overall codebase health status and metrics summary.
Line 11: Health dashboard data
Line 37: Health dashboard widget displaying overall codebase health
Line 46: Create new health dashboard
Line 56: Update health status
Line 61: Render health score with color coding
Line 94: Overall score prominently displayed
Line 142: Health trend indicator
Line 155: Trigger health refresh
Line 158: Show detailed health report
Line 161: Navigate to issues view
Line 172: Update health metrics from analysis

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3562 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  83% (20/24) - signals_pyqt5.rs...🔍 DEBUG PROMPT for signals_pyqt5.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, 'performance_view_gui', serves as the graphical user interface for displaying performance analysis data, bottlenecks, and optimization opportunities in a PyQt5-based GUI application. I
- files_view_gui.rs: This file, `files_view_gui.rs`, is a Rust implementation of the graphical user interface for managing and visualizing files within the CodeHUD application. It serves as an interface for displaying fil
- state.rs: This file, state.rs in the CodeHUD GUI project written in Rust, serves as a centralized data storage and management module for maintaining various states of the application. It implements features rel
- utils.rs: This file, `utils.rs`, is a Rust implementation of various traits and interfaces used in the CodeHUD GUI application for managing different aspects of its functionalities such as views, components, an
- lib.rs: The file lib.rs in the CodeHUD GUI application serves as a central hub for all other components of the system, connecting them together and coordinating their actions. It is responsible for initializi
- analysis_controller.rs: This file, analysis_controller.rs, implements a Rust version of the Analysis Controller for the CodeHUD GUI application. It provides an exact equivalent to the Python AnalysisController with QThread b
- menu_bar.rs: The file menu_bar.rs in the CodeHUD GUI application is responsible for managing and presenting a set of menus within the user interface. This includes creating, controlling, and updating various types
- project_explorer.rs: This file, project_explorer.rs in the CodeHUD GUI application, serves as a component responsible for managing and visualizing files within the system. It implements specific features that group files 
- llm_debugger.rs: The file llm_debugger.rs in the CodeHUD GUI project is designed to manage and display the functionalities related to Language Model-powered debugging and auto-fixing capabilities within a console-like
- health_monitor.rs: The file health_monitor.rs in the CodeHUD GUI project is designed for monitoring and reporting on various aspects of its system's overall health, including code quality, performance, and execution sta

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/signals_pyqt5.rs
Language: rust
Comments found: 29

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui/src/signals_pyqt5.rs
Language: rust
Module name: signals_pyqt5

COMMENTS TO ANALYZE:
Line 1: ! PyQt5-Style Signal/Slot System - Zero Degradation Implementation
Line 3: ! This module provides an exact PyQt5 signal/slot architecture implementation
Line 4: ! to ensure zero-degradation from the Python GUI system.
Line 13: PyQt5-style Signal that can emit typed messages to connected slots
Line 29: Connect a slot function to this signal (PyQt5 style)
Line 40: Emit signal with value (PyQt5 style)
Line 49: Also send to emit queue if connected
Line 58: Disconnect all slots
Line 66: Set up emit queue for async processing
Line 73: Clone signal for thread sharing
Line 89: PyQt5-style QObject equivalent with signal/slot management
Line 96: Signal manager matching PyQt5 QObject behavior
Line 110: Register a signal by name (PyQt5 style)
Line 115: Get signal by name and type
Line 121: Connect two objects' signals and slots (PyQt5 style)
Line 135: Cleanup disconnected signals
Line 147: PyQt5 QThread equivalent for background processing
Line 171: Start the thread (PyQt5 QThread.start() equivalent)
Line 182: Emit started signal
Line 192: Emit appropriate completion signal
Line 215: Stop the thread (PyQt5 QThread.quit() equivalent)
Line 220: Wait for thread to finish (PyQt5 QThread.wait() equivalent)
Line 233: Terminate the thread forcefully (PyQt5 QThread.terminate() equivalent)
Line 237: Note: Rust doesn't have forced thread termination for safety reasons
Line 238: This is a graceful shutdown attempt
Line 244: Macro to create PyQt5-style signal connections
Line 252: Macro to emit PyQt5-style signals

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4514 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (24/24) - Complete!
✅ Phase 2 complete: 24 files analyzed with enhanced context
📄 File summaries updated: 83 total files (24 from codehud-gui)
📄 Analysis metadata updated: 4 crates processed
🔍 DEBUG: Crate path for codehud-llm: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm
🔍 Processing 34 files from crate codehud-llm
🔍 DEBUG: First 5 files discovered for crate codehud-llm:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ollama.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/aggregate.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/mod.rs
  4. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/cst.rs
  5. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/config.rs
🧠 Running narrator on 30 files in batch...
🔍 DEBUG: Found 36 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ollama.rs
🔍 DEBUG: Bullet text length: 1852 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ollama.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/aggregate.rs
🔍 DEBUG: Bullet text length: 262 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/aggregate.rs
🔍 DEBUG: Found 12 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/mod.rs
🔍 DEBUG: Bullet text length: 580 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/mod.rs
🔍 DEBUG: Found 2 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/cst.rs
🔍 DEBUG: Bullet text length: 93 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/cst.rs
🔍 DEBUG: Found 1 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/config.rs
🔍 DEBUG: Bullet text length: 57 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/config.rs
🔍 DEBUG: Found 1 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/findings.rs
🔍 DEBUG: Bullet text length: 57 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/findings.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/entrypoint.rs
🔍 DEBUG: Bullet text length: 343 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/entrypoint.rs
🔍 DEBUG: Found 7 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/wrapper.rs
🔍 DEBUG: Bullet text length: 405 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/wrapper.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/imports_exports.rs
🔍 DEBUG: Bullet text length: 264 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/imports_exports.rs
🔍 DEBUG: Found 2 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/mod.rs
🔍 DEBUG: Bullet text length: 137 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/mod.rs
🔍 DEBUG: Found 7 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/comments.rs
🔍 DEBUG: Bullet text length: 346 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/comments.rs
🔍 DEBUG: Found 7 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/io.rs
🔍 DEBUG: Bullet text length: 377 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/io.rs
🔍 DEBUG: Found 5 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/module_relationships.rs
🔍 DEBUG: Bullet text length: 264 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/module_relationships.rs
🔍 DEBUG: Found 6 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/utility_class.rs
🔍 DEBUG: Bullet text length: 340 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/utility_class.rs
🔍 DEBUG: Found 2 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/render.rs
🔍 DEBUG: Bullet text length: 119 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/render.rs
🔍 DEBUG: Found 11 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/constitutional.rs
🔍 DEBUG: Bullet text length: 422 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/constitutional.rs
🔍 DEBUG: Found 33 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/lib.rs
🔍 DEBUG: Bullet text length: 2674 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/lib.rs
🔍 DEBUG: Found 36 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/progress_monitor.rs
🔍 DEBUG: Bullet text length: 1401 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/progress_monitor.rs
🔍 DEBUG: Found 38 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ffi.rs
🔍 DEBUG: Bullet text length: 1584 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ffi.rs
🔍 DEBUG: Found 23 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/structured.rs
🔍 DEBUG: Bullet text length: 1063 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/structured.rs
🔍 DEBUG: Found 14 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/denoiser.rs
🔍 DEBUG: Bullet text length: 647 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/denoiser.rs
🔍 DEBUG: Found 45 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/file_processor.rs
🔍 DEBUG: Bullet text length: 2740 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/file_processor.rs
🔍 DEBUG: Found 34 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/crate_summarizer.rs
🔍 DEBUG: Bullet text length: 2220 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/crate_summarizer.rs
🔍 DEBUG: Found 34 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/comment_extractor.rs
🔍 DEBUG: Bullet text length: 1709 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/comment_extractor.rs
🔍 DEBUG: Found 17 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs
🔍 DEBUG: Bullet text length: 678 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs
🔍 DEBUG: Found 108 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/extraction_fsm.rs
🔍 DEBUG: Bullet text length: 5126 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/extraction_fsm.rs
🔍 DEBUG: Found 24 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/critical.rs
🔍 DEBUG: Bullet text length: 2861 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/critical.rs
🔍 DEBUG: Found 13 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/equivalence.rs
🔍 DEBUG: Bullet text length: 597 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/equivalence.rs
🔍 DEBUG: Found 8 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/native_stub.rs
🔍 DEBUG: Bullet text length: 371 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/native_stub.rs
🔍 DEBUG: Found 14 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/validation.rs
🔍 DEBUG: Bullet text length: 539 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/validation.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 113 total files (30 from codehud-llm)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-llm...
🤖 Analyzing 30 files with enhanced context and improved token limits...
📦 Processing batch 1/6 (5 files)...
🤖 Analyzing: [█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   3% (1/30) - ollama.rs...🔍 DEBUG PROMPT for ollama.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ollama.rs
Language: rust
Comments found: 91

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ollama.rs
Language: rust
Module name: ollama

COMMENTS TO ANALYZE:
Line 1: ! Ollama Pipeline Integration - GPU accelerated local LLM inference
Line 3: ! This module provides integration with Ollama for local LLM inference with 4+ model types
Line 4: ! and GPU acceleration support, matching Python implementation exactly.
Line 17: Ollama configuration matching Python implementation
Line 20: Ollama server URL
Line 47: Model type to use
Line 53: Whether to keep model loaded
Line 68: Model parameters for inference
Line 73: Top-p nucleus sampling
Line 98: GPU acceleration configuration
Line 101: GPU type to use
Line 103: Number of GPU layers to use
Line 105: GPU memory fraction to use
Line 107: Whether to enable memory mapping
Line 109: Whether to enable memory locking
Line 125: Session management configuration
Line 128: Maximum conversation length
Line 132: Whether to persist conversations
Line 134: Context window management
Line 149: Context window management strategy
Line 152: Strategy for handling context overflow
Line 154: Target context utilization (0.0-1.0)
Line 156: Whether to summarize old context
Line 170: Strategy for handling context window overflow
Line 173: Truncate oldest messages
Line 175: Use sliding window approach
Line 177: Summarize and compress
Line 179: Fail on overflow
Line 183: Ollama API request structure
Line 197: Ollama API response structure
Line 216: Ollama model information
Line 226: Detailed model information
Line 236: Ollama pipeline for local LLM inference with GPU acceleration
Line 238: This implementation provides a Rust interface while delegating to the Python
Line 239: implementation during Phase 5a to ensure zero-degradation compatibility.
Line 243: HTTP client for API communication
Line 245: Native LLM engine (Phase 5b primary implementation)
Line 247: Python FFI bridge (Phase 5a fallback)
Line 249: Current conversation context
Line 251: Session ID for tracking
Line 256: Create a new Ollama pipeline
Line 273: Create with native engine for Phase 5b (primary implementation)
Line 277: Initialize native engine with LLM config
Line 297: Create with Python FFI bridge for Phase 5a compatibility
Line 307: Check if Ollama is available and running
Line 315: List available models
Line 336: Pull a model from the Ollama registry
Line 365: Generate text using Ollama with GPU acceleration
Line 371: Phase 5b: Use native engine as primary implementation
Line 379: Generate structured code using constraints for better quality
Line 409: Phase 5a: Fallback to Python bridge if available for guaranteed compatibility
Line 414: Final fallback: Native Ollama HTTP API implementation
Line 418: Generate via Python bridge (Phase 5a)
Line 425: Call Python Ollama pipeline directly
Line 454: Native Rust generation (will be used in Phase 5b)
Line 485: Update conversation context for session continuity
Line 493: Generate structured code with constraints
Line 499: Phase 5b: Use native engine as primary implementation
Line 519: Phase 5a: Fallback to Python bridge for guaranteed compatibility
Line 542: Final fallback: Native structured generation - convert constraints
Line 561: Native structured generation implementation
Line 567: Enhanced prompt with constraints
Line 590: No special formatting required
Line 601: Add validation rules as instructions
Line 612: Start a new conversation session
Line 618: End the current session
Line 624: Get current session ID
Line 629: Check if model is loaded
Line 637: Ensure model is available (pull if necessary)
Line 646: Get GPU information
Line 648: Check GPU availability through system commands
Line 651: Check NVIDIA GPU
Line 664: Check AMD GPU (ROCm)
Line 677: Check Metal (macOS)
Line 709: Requires Ollama server running
Line 714: This test requires Ollama to be running

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4369 characters
🤖 Analyzing: [███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   6% (2/30) - aggregate.rs...🔍 DEBUG PROMPT for aggregate.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/aggregate.rs
Language: rust
Comments found: 6

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/aggregate.rs
Language: rust
Module name: aggregate

COMMENTS TO ANALYZE:
Line 25: Role line: first NoteComment becomes "Role" sentence (trimmed)
Line 44: Group same (type, owner, subject) and merge lines
Line 125: handled as role
Line 136: Install sections in configured order
Line 140: rendered in render.rs header

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 933 characters
🤖 Analyzing: [█████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  10% (3/30) - cst.rs...🔍 DEBUG PROMPT for cst.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/cst.rs
Language: rust
Comments found: 6

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/cst.rs
Language: rust
Module name: cst

COMMENTS TO ANALYZE:
Line 4: Minimal JSON shape compatible with `tree-sitter parse --json`.
Line 5: We only rely on `type`, `children`, `text`, and `startPoint`.
Line 26: original source path if embedded; else the CST file path
Line 28: optional (not always present in CST JSON)
Line 31: Helper functions for Node
Line 48: Get all text content from this node and its children

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1027 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  13% (4/30) - findings.rs...🔍 DEBUG PROMPT for findings.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/findings.rs
Language: rust
Comments found: 4

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/findings.rs
Language: rust
Module name: findings

COMMENTS TO ANALYZE:
Line 18: use crate::, use super::, use self::
Line 19: Calls to functions from other modules
Line 20: pub use statements
Line 32: e.g., TODO text

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 833 characters
🤖 Analyzing: [████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  16% (5/30) - entrypoint.rs...🔍 DEBUG PROMPT for entrypoint.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/entrypoint.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/entrypoint.rs
Language: rust
Module name: entrypoint

COMMENTS TO ANALYZE:
Line 9: Look for Python __name__ == "__main__" pattern and Rust main function
Line 14: Python entrypoint pattern
Line 23: Rust main function

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 854 characters
📦 Processing batch 2/6 (5 files)...
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (6/30) - wrapper.rs...🔍 DEBUG PROMPT for wrapper.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/wrapper.rs
Language: rust
Comments found: 7

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/wrapper.rs
Language: rust
Module name: wrapper

COMMENTS TO ANALYZE:
Line 4: Detect functions that return a single call: return foo(...)
Line 16: Look for a child block containing a single return_statement -> call_expression
Line 32: naive: find first child 'identifier'
Line 44: descend to find return -> call
Line 51: find callee identifier
Line 68: try to find 'identifier' or 'property_identifier'

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2222 characters
🤖 Analyzing: [███████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  23% (7/30) - imports_exports.rs...🔍 DEBUG PROMPT for imports_exports.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/imports_exports.rs
Language: rust
Comments found: 5

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/imports_exports.rs
Language: rust
Module name: imports_exports

COMMENTS TO ANALYZE:
Line 51: Create separate findings for each export to preserve granularity
Line 59: Create separate findings for each import to preserve granularity and show relationships

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2084 characters
🤖 Analyzing: [█████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  26% (8/30) - comments.rs...🔍 DEBUG PROMPT for comments.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/comments.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/comments.rs
Language: rust
Module name: comments

COMMENTS TO ANALYZE:
Line 25: Walk and find "comment" nodes (tree-sitter common name)
Line 30: First comment for "Role"
Line 39: First non-empty trimmed comment line becomes "Note" we map later to "Role" section in render.

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2094 characters
🤖 Analyzing: [███████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  30% (9/30) - io.rs...🔍 DEBUG PROMPT for io.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/io.rs
Language: rust
Comments found: 1

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/io.rs
Language: rust
Module name: io

COMMENTS TO ANALYZE:
Line 51: pick first meaningful token from the bag

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1924 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (10/30) - module_relationships.rs...🔍 DEBUG PROMPT for module_relationships.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/module_relationships.rs
Language: rust
Comments found: 14

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/module_relationships.rs
Language: rust
Module name: module_relationships

COMMENTS TO ANALYZE:
Line 17: Rust use declarations
Line 22: Detect intra-crate imports
Line 27: Detect re-exports (pub use)
Line 38: Look for calls that reference modules (contains ::)
Line 40: Extract just the function call, limit length to avoid huge expressions
Line 42: Try to extract the module::function part
Line 57: Add intra-crate imports
Line 71: Add function calls (deduplicate)
Line 85: Extract the module::function part from a call expression
Line 87: Look for patterns like: module::function(), crate::module::Type::new(), self::helper()
Line 95: Only include calls that reference modules (contain ::) and look like project code
Line 97: Filter out standard library and common external crates to reduce noise

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2632 characters
📦 Processing batch 3/6 (5 files)...
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  36% (11/30) - utility_class.rs...🔍 DEBUG PROMPT for utility_class.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp
- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/utility_class.rs
Language: rust
Comments found: 1

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/detectors/utility_class.rs
Language: rust
Module name: utility_class

COMMENTS TO ANALYZE:
Line 28: crude: look for 'static' token or @staticmethod nearby

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3063 characters
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (12/30) - render.rs...🔍 DEBUG PROMPT for render.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp
- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/render.rs
Language: rust
Comments found: 2

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/narrator/render.rs
Language: rust
Module name: render

COMMENTS TO ANALYZE:
Line 6: Don't include the file path header, we'll integrate this differently
Line 26: Render bullet points in a compact format for LLM consumption

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3105 characters
🤖 Analyzing: [█████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  43% (13/30) - constitutional.rs...🔍 DEBUG PROMPT for constitutional.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp
- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/constitutional.rs
Language: rust
Comments found: 3

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/constitutional.rs
Language: rust
Module name: constitutional

NO MEANINGFUL COMMENTS FOUND - ANALYZING FILE STRUCTURE ONLY:

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3005 characters
🤖 Analyzing: [███████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░]  46% (14/30) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp
- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/lib.rs
Language: rust
Comments found: 59

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD LLM - Large Language Model Integration (Phase 5a: FFI Preservation Bridge)
Line 3: ! This crate provides complete LLM integration preserving Python functionality exactly.
Line 4: ! Phase 5a implements PyO3 bindings to call Python implementations directly for
Line 5: ! guaranteed zero-degradation compatibility.
Line 7: ! Key Components (29+ files from Python implementation):
Line 8: ! - Ollama Pipeline with GPU acceleration
Line 9: ! - Structured code generation with constraints
Line 10: ! - Critical mistake detection and self-correction
Line 11: ! - Constitutional AI with guardrails
Line 12: ! - Conversation tracking and memory
Line 13: ! - 97%+ bug fix success rate preservation
Line 18: LLM capability modules
Line 20: Use full native implementation when candle feature is enabled
Line 24: Use stub implementation when candle feature is disabled (for GUI integration)
Line 43: Re-export main types for convenience
Line 45: Re-export under consistent name
Line 65: Result type for LLM operations
Line 68: Error types for LLM operations
Line 71: Python FFI error
Line 75: Python downcast error
Line 79: HTTP request error
Line 83: JSON parsing error
Line 87: Schema validation error
Line 99: Configuration error (alias)
Line 103: Model inference error
Line 107: Critical mistake detected
Line 111: Constitutional AI violation
Line 115: GPU acceleration error
Line 123: Conversation tracking error
Line 135: Regex compilation error
Line 139: Python bridge errors
Line 168: LLM model types supported (matching Python implementation exactly)
Line 171: DeepSeek Coder models
Line 173: Qwen2.5 Coder models
Line 175: Code Llama models
Line 182: Get the model identifier used by Ollama
Line 192: Get the HuggingFace model identifier
Line 203: GPU acceleration type (matching Python implementation)
Line 208: Metal acceleration (macOS)
Line 214: LLM configuration matching Python behavior exactly
Line 217: Model type to use
Line 219: GPU acceleration type
Line 221: Maximum tokens to generate
Line 223: Temperature for sampling
Line 225: Top-p sampling parameter
Line 227: Random seed for reproducibility
Line 229: Whether to enable structured generation
Line 231: Whether to enable critical mistake detection
Line 233: Whether to enable constitutional AI
Line 235: Session timeout in seconds

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5245 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (15/30) - progress_monitor.rs...🔍 DEBUG PROMPT for progress_monitor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for Ollama, a local LLM (Language Model) inference framework with GPU acceleration support. It supports multiple model types and allows configuration of various as
- aggregate.rs: This file, 'aggregate.rs', is a part of the Rust implementation for CodeHUD's narrator module. It manages and aggregates data from different sources based on roles, groups them together by type, owner
- cst.rs: This Rust file, cst.rs, implements a Context-Sensitive Tree (CST) in the context of CodeHUD's LLM project. The purpose of this file is to parse code into an abstract syntax tree and extract informatio
- findings.rs: This Rust file, `findings.rs`, is part of a larger system designed for managing and analyzing code analysis findings in various programming languages including Rust. The module implements specific fea
- entrypoint.rs: This Rust file is a part of the CodeHUD system, specifically focusing on detecting entry points for different programming languages. It contains various functions and behaviors designed to identify sp
- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/progress_monitor.rs
Language: rust
Comments found: 39

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/progress_monitor.rs
Language: rust
Module name: progress_monitor

COMMENTS TO ANALYZE:
Line 1: ! Progress Monitor for Background Execution
Line 3: ! Displays a popup terminal window with progress bar when the main process
Line 4: ! runs in the background, ensuring visibility of long-running operations.
Line 12: Progress information shared between main process and popup window
Line 15: Current step being processed
Line 17: Total number of steps
Line 19: Current file being processed
Line 21: Total files to process
Line 23: Current operation description
Line 25: Whether the operation is complete
Line 27: Elapsed time in seconds
Line 29: Any error message
Line 48: Progress monitor that can spawn popup windows for background processes
Line 50: Path to the progress file
Line 52: Whether to use popup mode
Line 54: Start time for elapsed calculation
Line 59: Create a new progress monitor
Line 71: Detect if we should use popup mode (running in background)
Line 73: Check if we're running in background by testing if stdout is a terminal
Line 76: If stdout is not a terminal, we're likely running in background
Line 81: Also check for explicit background indicators
Line 86: Check if DISPLAY is set (we're in GUI environment) and no terminal
Line 94: Initialize progress monitoring (spawn popup if needed)
Line 102: Write initial progress
Line 129: Update progress with file count
Line 146: Mark as completed
Line 155: Clean up after a short delay
Line 162: Mark as failed
Line 171: Clean up after a longer delay for errors
Line 178: Write progress to shared file
Line 185: Read progress from shared file
Line 196: Spawn a popup terminal window to display progress
Line 202: Create a script that monitors the progress file
Line 279: Write script to temp file
Line 283: Make script executable
Line 292: Prepare command arguments with proper lifetimes
Line 296: Try different terminal emulators
Line 317: Fallback: just print a message

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4822 characters
📦 Processing batch 4/6 (5 files)...
🤖 Analyzing: [██████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░]  53% (16/30) - ffi.rs...🔍 DEBUG PROMPT for ffi.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl
- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ffi.rs
Language: rust
Comments found: 120

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/ffi.rs
Language: rust
Module name: ffi

COMMENTS TO ANALYZE:
Line 1: ! FFI Bridge - PyO3 bindings to preserve exact Python LLM behavior
Line 3: ! This module implements Phase 5a of the plan: calling Python LLM implementations
Line 4: ! directly through FFI to guarantee zero-degradation compatibility while building
Line 5: ! the Rust infrastructure.
Line 14: Main FFI bridge to Python LLM implementations
Line 16: This bridge calls the Python codehud.local_llm modules directly to ensure
Line 17: identical behavior during the transition period.
Line 19: Python interpreter instance
Line 21: Python Ollama pipeline module
Line 23: Python PyTorch pipeline module
Line 25: Python structured generator module
Line 27: Python critical detector module
Line 29: Python constitutional AI module
Line 31: Python conversation tracker module
Line 33: Python self-verification system module
Line 35: Python continuous test monitor module
Line 37: Python behavior analysis module
Line 39: Python optimized pipeline module
Line 41: Python guardrails integration module
Line 43: Python OpenHands bridge module
Line 45: Python monitoring system module
Line 47: Python validation system module
Line 51: LLM capability enumeration matching Python implementation
Line 54: Ollama pipeline with GPU acceleration
Line 56: PyTorch pipeline with HuggingFace integration
Line 58: Structured code generation with constraints
Line 60: Critical mistake detection and self-correction
Line 62: Constitutional AI with guardrails
Line 64: Conversation tracking and memory
Line 68: Continuous testing and monitoring
Line 70: LLM behavior analysis
Line 74: Advanced constraint enforcement
Line 76: External AI system bridging
Line 81: Get all available capabilities
Line 100: Generation constraints for structured output
Line 103: JSON schema for structured output
Line 105: Grammar rules for constrained generation
Line 107: Maximum length constraints
Line 109: Required output format
Line 115: Output format specification
Line 118: Plain text output
Line 120: JSON structured output
Line 122: Python code output
Line 124: Rust code output
Line 131: Constitutional AI rule
Line 138: Rule pattern to match
Line 140: Action to take when rule is violated
Line 146: Action to take when a constitutional rule is violated
Line 149: Block the output completely
Line 151: Warn and continue
Line 153: Attempt to fix the violation
Line 155: Request human review
Line 159: Severity levels for constitutional rules
Line 162: Low severity - informational
Line 164: Medium severity - warning
Line 166: High severity - requires action
Line 168: Critical severity - blocks execution
Line 173: Create a new Python LLM bridge
Line 175: This initializes the Python interpreter and imports all necessary modules
Line 176: from the original Python codebase.
Line 178: Initialize Python interpreter
Line 182: Add the Python codebase to sys.path
Line 187: Import all Python LLM modules
Line 278: Generate structured code using Python implementation
Line 280: This calls the Python structured generator directly to ensure
Line 281: identical output during the FFI bridge phase.
Line 288: Convert constraints to Python dict
Line 308: Call Python method
Line 317: Detect critical mistakes using Python implementation
Line 399: Run constitutional AI validation using Python implementation
Line 406: Convert rules to Python list
Line 428: Start a new conversation session via Python
Line 437: Add a message to conversation via Python
Line 470: Get conversation history via Python
Line 482: Convert Python result to Rust structures
Line 489: Extract turn data and convert to Rust ConversationTurn
Line 527: Generate conversation summary via Python
Line 541: Would extract from Python
Line 542: Would extract from Python
Line 556: End conversation and get summary via Python
Line 561: Collect system metrics via Python
Line 611: Validate content via Python validation engine
Line 632: Would extract from Python
Line 650: Start monitoring via Python
Line 659: Assess constitutional AI via Python
Line 678: Would extract from Python
Line 688: Helper method to convert Python message to Rust structure
Line 707: Would extract from Python
Line 714: Check if a specific capability is available
Line 732: Try to call the capability check method
Line 740: Get available capabilities
Line 748: Generate bug fix using 97%+ success rate Python implementation
Line 767: Python call wrapper with comprehensive error handling
Line 777: Execute a Python call with error handling and timeout
Line 787: Attempt to acquire GIL with timeout
Line 790: Check if we've exceeded timeout
Line 797: Execute the Python call
Line 801: Convert PyO3 error to our error type
Line 823: Execute an async Python call (using tokio::task::spawn_blocking)
Line 846: Get the Python call wrapper for this bridge
Line 848: 30 second timeout
Line 851: Safe wrapper for Python calls with comprehensive error handling
Line 860: Safe wrapper for async Python calls
Line 870: Thread safety implementation with proper GIL handling
Line 874: Note: These impls are safe because:
Line 875: 1. Python objects are stored as PyObject which can be shared across threads
Line 876: 2. All Python calls go through Python::with_gil() which ensures thread safety
Line 877: 3. The PythonCallWrapper provides additional safety and timeout handling
Line 885: Requires Python environment setup
Line 892: Bridge created successfully
Line 896: Expected if Python environment not available
Line 905: All 12+ LLM capabilities

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8389 characters
🤖 Analyzing: [████████████████████████████░░░░░░░░░░░░░░░░░░░░░░]  56% (17/30) - structured.rs...🔍 DEBUG PROMPT for structured.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl
- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/structured.rs
Language: rust
Comments found: 171

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/structured.rs
Language: rust
Module name: structured

COMMENTS TO ANALYZE:
Line 1: ! Structured Code Generation with Constraints
Line 3: ! This module provides structured code generation with JSON schema validation,
Line 4: ! grammar-based constraints, and constitutional AI guardrails, preserving the
Line 5: ! Python implementation's exact behavior during Phase 5a.
Line 18: Generation constraints for structured output
Line 21: JSON schema for output validation
Line 23: Grammar rules for structured generation
Line 25: Maximum output length
Line 27: Expected output format
Line 29: Additional validation rules
Line 33: Output format specification
Line 36: Plain text output
Line 38: Text output (alias for PlainText)
Line 40: Python source code
Line 42: Rust source code
Line 44: JavaScript source code
Line 48: JSON output (alias for JsonObject)
Line 50: Markdown formatted text
Line 54: Custom format with specification
Line 58: Structured code generator with constraint enforcement
Line 60: Phase 5b uses native LLM engine as primary implementation with FFI bridge fallback.
Line 64: JSON schema validator
Line 66: Native LLM engine (Phase 5b primary)
Line 68: Python FFI bridge (Phase 5a fallback)
Line 74: Configuration for structured generation
Line 77: Maximum generation attempts
Line 79: Timeout per generation attempt
Line 81: Whether to enable self-correction
Line 83: Whether to validate syntax
Line 85: Whether to enforce style guidelines
Line 87: Custom validation rules
Line 104: Custom validation rule
Line 109: Description of what this validates
Line 111: Regex pattern to match (if applicable)
Line 113: Python code to execute for validation
Line 119: Validation severity levels
Line 124: Warning but continue
Line 126: Error - retry generation
Line 128: Critical - fail completely
Line 135: Total generation attempts
Line 141: Average generation time (milliseconds)
Line 143: Total tokens generated
Line 145: Validation failure breakdown
Line 149: Generation result with metadata
Line 154: Whether generation was successful
Line 160: Correction attempts made
Line 162: Final confidence score
Line 166: Individual validation result
Line 171: Whether validation passed
Line 177: Location of issue (if applicable)
Line 181: Error location information
Line 184: Line number (1-indexed)
Line 186: Column number (1-indexed)
Line 188: Length of the issue
Line 190: Context around the error
Line 197: Time taken for generation (milliseconds)
Line 199: Model used for generation
Line 205: Whether self-correction was applied
Line 207: Constraint satisfaction score
Line 211: Syntax validation result
Line 214: Whether syntax is valid
Line 216: Syntax errors found
Line 222: Syntax error information
Line 235: Syntax warning information
Line 246: Types of syntax errors
Line 261: Types of syntax warnings
Line 275: Create a new structured code generator
Line 286: Create with Python FFI bridge for Phase 5a compatibility
Line 296: Set JSON schema for validation
Line 307: Generate structured code with constraints
Line 316: Phase 5a: Use Python bridge for guaranteed compatibility
Line 321: Native Rust implementation (Phase 5b)
Line 325: Generate via Python bridge (Phase 5a)
Line 332: Call Python structured generator directly
Line 358: Validate the generated code using Rust validators
Line 381: Not available from Python bridge
Line 382: Default from Python
Line 383: Handled by Python
Line 391: Native generation implementation (Phase 5b)
Line 417: Continue to next attempt for self-correction
Line 427: All attempts failed
Line 433: Attempt a single generation
Line 439: Enhanced prompt with constraints
Line 442: TODO: Integrate with Ollama or other LLM backend for native generation
Line 443: For now, return a placeholder
Line 461: Will be set by caller
Line 473: Build enhanced prompt with constraints
Line 477: Add output format instructions
Line 508: Add validation rules as constraints
Line 516: Add length constraint
Line 524: Validate generated code against constraints
Line 548: JSON schema validation
Line 601: Custom validation rules
Line 620: Validate syntax for specific output format
Line 636: Text format doesn't have strict syntax rules
Line 644: Plain text format doesn't have strict syntax rules
Line 661: Custom format validation not implemented
Line 675: Validate HTML syntax
Line 677: HTML syntax validation would require external parsers
Line 678: For now, provide a placeholder implementation
Line 690: Validate JavaScript syntax
Line 692: JavaScript syntax validation would require external tools or parsers
Line 693: For now, provide a placeholder implementation
Line 705: Validate Python syntax
Line 707: Use Python AST parsing via FFI bridge if available
Line 709: Call Python ast.parse() for accurate syntax validation
Line 710: TODO: Implement Python AST validation via FFI
Line 713: Basic validation for now
Line 717: Check for basic Python syntax issues
Line 721: Check indentation (very basic)
Line 724: Potential indentation issue
Line 732: Check for common syntax errors
Line 750: Validate Rust syntax
Line 752: Try to parse with syn crate
Line 762: proc_macro2::Span doesn't have start() method
Line 776: Validate JSON syntax
Line 801: Validate Markdown syntax
Line 803: Basic Markdown validation
Line 806: Check for common Markdown issues
Line 808: Check for headers without space after #
Line 819: Markdown is very forgiving
Line 825: Apply custom validation rule
Line 846: Unknown rule passes by default
Line 850: Calculate constraint satisfaction score
Line 879: Update generation statistics
Line 881: Update average time
Line 886: Update validation failure counts
Line 896: Get current generation statistics
Line 928: Missing closing brace
Line 942: Missing closing paren
Line 984: Should be partial satisfaction

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8668 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  60% (18/30) - denoiser.rs...🔍 DEBUG PROMPT for denoiser.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl
- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/denoiser.rs
Language: rust
Comments found: 48

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/denoiser.rs
Language: rust
Module name: denoiser

COMMENTS TO ANALYZE:
Line 1: ! LLM Context Denoiser
Line 3: ! This module removes redundant information, repeated phrases, and verbose content
Line 4: ! to fit large datasets within LLM context windows while preserving key insights.
Line 11: Configuration for the denoiser
Line 14: Target token reduction percentage (0.0 to 1.0)
Line 16: Minimum phrase length to consider for deduplication
Line 18: Maximum phrase length to consider
Line 20: Preserve structural insights (narrator bullet points)
Line 22: Preserve file paths and metadata
Line 38: Statistics about denoising operation
Line 49: Main denoiser for LLM context preparation
Line 52: Cache of common phrases found across files
Line 54: Cache of common words
Line 67: Denoise a collection of file extractions for LLM consumption
Line 69: Phase 1: Analyze frequency patterns across all files
Line 72: Phase 2: Clean each file extraction
Line 87: Track cleaning metrics
Line 112: Analyze frequency patterns across all files to identify redundancy
Line 123: Analyze structural insights if present
Line 134: Analyze frequency of words and phrases in text
Line 138: Count word frequency
Line 146: Count phrase frequency
Line 158: Denoise a single file extraction
Line 167: Clean structural insights (preserve but deduplicate)
Line 177: Denoise a single comment
Line 192: Denoise structural insights while preserving key information
Line 202: Remove exact duplicates but preserve similar items
Line 221: Core text denoising logic
Line 225: Step 1: Remove highly repeated phrases (appears in 5+ files)
Line 237: Step 2: Consolidate repeated words
Line 240: Step 3: Remove common filler phrases
Line 243: Step 4: Clean up whitespace
Line 249: Consolidate repeated words within the same text
Line 260: Only include word if it hasn't appeared too many times
Line 269: Remove common filler phrases that add no value
Line 296: Normalize whitespace and remove empty lines
Line 308: Normalize a word for frequency analysis
Line 315: Normalize a phrase for frequency analysis
Line 324: Calculate content size for statistics
Line 343: Count removed phrases for statistics
Line 345: Simplified for now - could implement detailed tracking
Line 349: Count consolidated words for statistics
Line 351: Simplified for now - could implement detailed tracking
Line 365: Simulate frequent phrases
Line 380: Should reduce repeated instances

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5316 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  63% (19/30) - file_processor.rs...🔍 DEBUG PROMPT for file_processor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl
- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/file_processor.rs
Language: rust
Comments found: 155

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/file_processor.rs
Language: rust
Module name: file_processor

COMMENTS TO ANALYZE:
Line 1: ! File Processing Pipeline for Comment Analysis
Line 3: ! This module implements the three-phase workflow described in LLM_vision.txt:
Line 4: ! 1. Extract comments from files -> comments.json
Line 5: ! 2. Generate per-file summaries using LLM -> summaries.json
Line 6: ! 3. Create system-wide summary -> system_summary.json
Line 26: Summary of a single file based on its comments
Line 29: File path that was analyzed
Line 31: Key themes identified from comments
Line 33: Dependencies mentioned in comments
Line 35: Overall purpose of the file
Line 37: Confidence level of the analysis
Line 39: LLM model used for analysis
Line 41: When the analysis was performed
Line 43: Token usage statistics
Line 47: System-wide summary of the entire codebase
Line 50: Overall themes across the entire system
Line 52: Key dependencies used throughout the system
Line 54: Overall purpose and description of the system
Line 56: Confidence level of the system analysis
Line 58: Metadata about the analysis process
Line 62: Confidence level of LLM analysis
Line 70: Token usage statistics
Line 73: Input tokens sent to LLM
Line 75: Output tokens received from LLM
Line 79: Analysis metadata for system summary
Line 82: Number of files analyzed
Line 84: Total comments extracted
Line 86: Programming languages detected
Line 88: Total analysis duration in seconds
Line 90: LLM model used
Line 94: Configuration for file processing pipeline
Line 97: Comment extraction configuration
Line 107: LLM analysis configuration
Line 110: Maximum tokens per file analysis
Line 112: Maximum tokens for system summary
Line 114: Whether to include code context in analysis
Line 116: Whether to extract TODO items
Line 118: Whether to analyze documentation coverage
Line 120: Temperature for LLM responses
Line 127: Output directory for analysis files
Line 129: Whether to create pretty-formatted JSON
Line 131: Whether to include debug information
Line 138: Whether to enable parallel file processing
Line 140: Maximum concurrent LLM calls
Line 142: Whether to use caching
Line 144: Cache duration in hours
Line 175: Processing report summarizing the entire analysis
Line 178: Overall success status
Line 180: Files processed successfully
Line 182: Files that failed processing
Line 184: Total processing time
Line 186: Output file paths
Line 194: Output file paths
Line 197: Path to comments.json
Line 199: Path to summaries.json
Line 201: Path to system_summary.json
Line 205: Processing error information
Line 208: File that caused the error
Line 212: Processing phase where error occurred
Line 225: Processing performance metrics
Line 228: Comment extraction time
Line 230: LLM analysis time
Line 232: System summary time
Line 234: Average time per file
Line 236: Total tokens processed
Line 238: LLM calls made
Line 242: Main file processor implementing the three-phase workflow
Line 246: LLM pipeline for analysis
Line 248: Structured code generator
Line 250: Constitutional AI for quality control
Line 252: Conversation tracker for context management
Line 254: LLM performance monitor
Line 261: Create a new file processor with all required components
Line 266: Create comment extractor
Line 271: Create LLM pipeline
Line 274: Create structured generator
Line 279: Create constitutional AI with default config
Line 289: Create conversation tracker with default config
Line 301: Create LLM monitor with default config
Line 324: Process a single file and return its summary
Line 326: Phase 1: Extract comments
Line 329: Phase 2: Generate LLM summary for this file
Line 335: Generate a text summary using the LLM (for FSM integration)
Line 336: REMOVED: Old generate_text_summary with low token limit
Line 337: Now using generate_hierarchical_summary for all summaries
Line 339: Generate hierarchical project summary with extended output tokens (600-1000 words)
Line 342: Make direct HTTP call to Ollama API with extended token limit
Line 355: Reduced from 1024 for more concise summaries
Line 387: Generate project-level hierarchical summary (SEPARATE from file summaries)
Line 390: Make direct HTTP call to Ollama API for PROJECT-LEVEL summary
Line 391: Use larger model (14B) for better synthesis and abstraction capabilities
Line 404: 1000 tokens for ~500 word project summary
Line 436: Generate hierarchical summary with custom token budget (for file summaries)
Line 439: Make direct HTTP call to Ollama API with custom token limit
Line 452: Custom token budget
Line 484: Generate LLM summary for a single file's comments
Line 486: Debug: Print comment extraction details
Line 488: If no comments found, return early
Line 505: Build prompt with comments and structural insights
Line 517: Add structural insights if available
Line 534: Generate LLM analysis using actual API call
Line 539: Create file summary
Line 542: TODO: Parse from LLM response
Line 543: TODO: Extract from LLM response
Line 555: Process an entire codebase using the three-phase workflow
Line 568: Create output directory
Line 572: Phase 1: Extract comments from all files
Line 592: Phase 2: Generate per-file summaries using LLM
Line 606: Phase 3: Generate system-wide summary
Line 628: Calculate final metrics
Line 637: Create processing report
Line 653: Phase 1: Extract comments from all files in the codebase
Line 661: Convert to HashMap for JSON output matching vision format
Line 670: Extract comments sequentially (simpler, more stable)
Line 676: Extract comments in parallel (faster for large codebases)
Line 678: For now, use sequential implementation
Line 679: TODO: Implement true parallel processing with tokio tasks
Line 683: Phase 2: Analyze each file's comments using LLM
Line 712: Analyze a single file's comments using structured LLM generation
Line 718: Create structured prompt for file analysis
Line 721: Define constraints for structured generation
Line 733: Generate structured analysis
Line 736: Parse response into FileSummary
Line 745: Rough token estimation
Line 757: Phase 3: Generate system-wide summary from file summaries
Line 777: Add analysis metadata
Line 786: TODO: Calculate from extractions
Line 788: TODO: Calculate actual duration
Line 800: Build prompt for analyzing a single file's comments
Line 829: Build prompt for system-wide summary
Line 858: Get JSON schema for FileSummary
Line 872: Get JSON schema for SystemSummary
Line 886: Create empty summary for files with no comments
Line 900: Save data as JSON file
Line 912: Create failed processing report
Line 936: Get current LLM model name
Line 938: TODO: Get actual model name from LLM pipeline
Line 942: Extract language from file path
Line 960: Analysis statistics for tracking token usage

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 9627 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (20/30) - crate_summarizer.rs...🔍 DEBUG PROMPT for crate_summarizer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: This Rust file, wrapper.rs, is a part of CodeHUD's LLM project and serves as a detector module for managing and analyzing code analysis findings in various programming languages including Rust. It imp
- imports_exports.rs: This file is a part of the CodeHUD system designed for detecting imports and exports in different programming languages including Rust. It implements specific features that allow users to create separ
- comments.rs: This Rust file, `comments.rs`, is part of the CodeHUD system and it's designed for detecting comments in various programming languages including Rust. The module implements specific features like "det
- io.rs: This file, `io.rs`, is a part of the CodeHUD system and its main purpose is to detect entry points for different programming languages. It provides several features that allow it to identify significa
- module_relationships.rs: The file `module_relationships.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and analyzes relationships among modules within the codebase. This is particularl
- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/crate_summarizer.rs
Language: rust
Comments found: 156

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/crate_summarizer.rs
Language: rust
Module name: crate_summarizer

COMMENTS TO ANALYZE:
Line 1: ! Crate-Level Summarization for Hierarchical LLM Analysis
Line 3: ! This module implements hierarchical summarization by grouping files into crates
Line 4: ! and generating focused summaries for each crate before final project analysis.
Line 14: Summary of a single crate with its analysis
Line 17: Name of the crate
Line 19: Path to the crate directory
Line 21: Files analyzed in this crate
Line 23: LLM-generated summary text
Line 25: Aggregated structural insights
Line 27: Token count of the summary
Line 31: Subcrate summaries (for large crates with subdirectories)
Line 36: Summary of a subcrate (subdirectory within a crate) with recursive nesting
Line 39: Name/path of the subcrate (e.g., "narrator/detectors")
Line 41: Number of direct files in this subcrate (not including nested subcrates)
Line 43: Direct files in this subcrate
Line 45: LLM-generated summary for this subcrate
Line 47: Token count of the summary
Line 49: Total size in kilobytes (for prioritization)
Line 51: Nested subcrates (recursive structure)
Line 56: Cleaned file data for crate summarization input (using file summaries, not raw comments)
Line 59: Relative file path
Line 61: LLM-generated file summary (from file_summaries.json)
Line 63: Preserved structural insights for technical details
Line 67: Crate grouping and discovery
Line 70: Root project path
Line 76: Information about a discovered crate
Line 79: Crate name from Cargo.toml
Line 81: Path to crate directory
Line 83: Crate description from Cargo.toml
Line 87: Files belonging to this crate
Line 91: Main crate summarization engine
Line 93: File processor for LLM calls
Line 95: Denoiser for stage 1 cleaning
Line 99: Project root path for relative path conversion
Line 103: Configuration for crate summarization
Line 106: Maximum tokens per crate summary
Line 108: Whether to include code context in summaries
Line 110: Whether to analyze inter-crate dependencies
Line 112: Denoising aggressiveness (0.0 to 1.0)
Line 122: 40% reduction for crate inputs
Line 128: Create a new crate grouper for the project
Line 136: Discover all crates in the project
Line 142: Find all Cargo.toml files
Line 152: Skip tree-sitter grammars and ALL test directories
Line 162: Check for duplicates before adding
Line 177: Sort crates by name for consistent processing order
Line 184: Parse Cargo.toml to extract crate information
Line 216: Will be populated later
Line 220: Group files by their containing crate
Line 237: Update crate file lists
Line 246: Debug output for final grouping
Line 255: Find which crate a file belongs to
Line 257: Convert to absolute path and canonicalize to resolve symlinks
Line 264: Canonicalize paths to resolve any symlinks or '..' components
Line 268: Find the crate that contains this file
Line 273: Make crate path absolute and canonical for comparison
Line 323: Get discovered crate information
Line 330: Create a new crate summarizer
Line 335: Strip metadata for crate summaries
Line 349: Convert full path to project-relative path for token efficiency
Line 355: Fallback: just use filename if strip_prefix fails
Line 363: Convert crate path to project-relative path
Line 372: Generate summary for a single crate
Line 381: Load file summaries (hierarchical: file summaries → crate summary)
Line 384: Build crate summary prompt
Line 387: Check token budget (8K limit per crate)
Line 391: Apply more aggressive denoising if needed
Line 395: Generate summary via LLM with 8K budget
Line 413: Generate summary via LLM within budget
Line 416: Calculate actual token count
Line 419: Aggregate structural insights
Line 436: Generate context-aware crate summary using project memory
Line 448: Load file summaries (hierarchical: file summaries → crate summary)
Line 451: Filter files based on whether they belong to subcrates
Line 473: Build context-aware prompt with subcrates
Line 481: Check token budget (8K limit per crate)
Line 509: Generate summary via LLM with context
Line 527: Load file summaries for crate summary input (hierarchical: file summaries → crate summary)
Line 531: Load all file summaries from disk
Line 547: Create a lookup map for file summaries
Line 550: Build cleaned file data using file summaries + structural insights
Line 552: Get the file summary (required)
Line 572: Build prompt for crate summary generation
Line 598: Add LLM-generated file summary (includes synthesized structural insights)
Line 602: Raw structural insights removed - already synthesized in file summaries
Line 603: This prevents redundancy and token waste in crate-level aggregation
Line 619: Aggregate structural insights from all files in the crate
Line 638: Limit items per section to avoid bloat
Line 650: Apply aggressive denoising for oversized prompts (limit number of files)
Line 652: Simply limit to most important files (first N files)
Line 653: File summaries are already concise, so we just need to limit count
Line 658: Build context-aware prompt using project memory
Line 670: Add project context from memory
Line 694: Limit files to fit within token budget
Line 702: Add LLM-generated file summary (primary source)
Line 706: Add structural insights for technical details
Line 732: Build reduced context prompt for oversized prompts
Line 744: Add minimal context
Line 759: Very limited file data (just first line of summary)
Line 762: Take first sentence of file summary
Line 776: Generate summary using only structural insights (no comments) - ultra token efficient
Line 784: Build prompt using only structural insights
Line 787: Generate summary via LLM
Line 805: Build prompt using only structural insights - extremely token efficient
Line 817: Aggregate all structural insights
Line 824: Shorten long items for token efficiency
Line 845: Calculates total size in KB for a collection of files
Line 853: Detect subcrates recursively with unlimited nesting depth
Line 854: Returns a tree structure of subdirectories that meet the threshold (5+ files)
Line 861: Group files by immediate parent directory
Line 869: File is in a subdirectory
Line 877: Build subcrate nodes recursively
Line 880: Only create subcrate if it has 5+ files (threshold)
Line 887: Find direct files in this directory (not in subdirectories)
Line 900: Recursively find nested subcrates
Line 903: Calculate total size in KB
Line 919: Count all subcrates including nested ones
Line 928: Flatten all subcrates into a prioritized list for truncation
Line 929: Returns (full_path, size_kb, is_nested)
Line 946: Recursively add nested subcrates (marked as nested=true)
Line 950: nested subcrates are marked as nested
Line 957: Generate subcrate summaries recursively (bottom-up traversal)
Line 963: Detect subcrates from the crate root, not hardcoded src/ directory
Line 971: Count all subcrates including nested
Line 980: Determine which subcrates to keep (max 10)
Line 984: Sort by priority for TRUNCATION (will truncate from start):
Line 985: 1. Nested subcrates first (is_nested=true)
Line 986: 2. Within each group, smallest size first
Line 989: nested comes first (truncated first)
Line 990: top-level comes last (kept)
Line 991: sort by size ascending
Line 1012: Calculate per-subcrate token budget (reduced from 500 to 250 max)
Line 1019: Generate summaries (skipping truncated ones)
Line 1043: Generate summary for a single subcrate (handles nesting recursively)
Line 1053: First, generate summaries for all nested subcrates (bottom-up)
Line 1059: Skip if this nested subcrate was truncated
Line 1076: Build prompt for this subcrate
Line 1094: Add nested subcrate summaries if present
Line 1108: Generate LLM summary with token budget
Line 1112: Collect file paths for this subcrate
Line 1129: Collect all file paths recursively from a subcrate summary
Line 1142: Build context-aware prompt with subcrate summaries
Line 1152: Add context from project memory
Line 1173: Add subcrate summaries if present
Line 1183: Add individual file summaries
Line 1201: Build reduced context prompt with subcrates (for when token budget is exceeded)
Line 1217: Add subcrate summaries (these are already compressed)
Line 1227: Only include first sentence of each individual file summary
Line 1248: Internal node structure for subcrate tree
Line 1268: Create a simple Cargo.toml
Line 1292: Mock file extractions

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 11249 characters
📦 Processing batch 5/6 (5 files)...
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  70% (21/30) - comment_extractor.rs...🔍 DEBUG PROMPT for comment_extractor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal
- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/comment_extractor.rs
Language: rust
Comments found: 175

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/comment_extractor.rs
Language: rust
Module name: comment_extractor

COMMENTS TO ANALYZE:
Line 1: ! Comment Extraction Engine with Tree-sitter Integration
Line 3: ! This module implements the core comment extraction functionality described in LLM_vision.txt,
Line 4: ! leveraging CodeHUD's existing enhanced tree-sitter infrastructure for high-performance
Line 5: ! multi-language comment analysis.
Line 17: Position information for comments in source code
Line 20: Line number (1-indexed)
Line 22: Column number (1-indexed)
Line 26: Type of comment detected
Line 29: Single line comment (// in Rust, # in Python)
Line 31: Block comment (/* */ in Rust)
Line 33: Documentation comment (/// in Rust, """ in Python)
Line 35: Multi-line documentation block
Line 39: Code context surrounding a comment
Line 42: Name of function the comment is associated with
Line 44: Name of class/struct the comment is associated with
Line 46: Module or namespace path
Line 48: 3-5 lines of code adjacent to the comment
Line 50: Whether this comment appears to document the following code
Line 54: Structural insights derived from AST analysis
Line 57: Source of these insights
Line 59: Whether these are generated (not human-written)
Line 61: Organized insights by category
Line 65: Cleaned format optimized for LLM consumption
Line 72: Cleaned comment text without JSON overhead
Line 74: Generated structural insights
Line 78: An extracted comment with rich metadata
Line 81: The comment text (without comment markers)
Line 83: Type of comment
Line 85: Byte offset in source file where comment starts
Line 87: Byte offset in source file where comment ends
Line 89: Line/column position where comment starts
Line 91: Line/column position where comment ends
Line 93: Surrounding code context
Line 97: Configuration for comment extraction
Line 100: Include single-line comments
Line 102: Include block comments
Line 104: Include documentation comments
Line 106: Extract code context around comments
Line 108: Number of lines of adjacent code to capture
Line 110: Minimum comment length to include (filters out noise)
Line 112: Maximum comment length to include (prevents huge comments)
Line 114: Skip comments that are just dividers (e.g., "// ========")
Line 133: Results of extracting comments from a single file
Line 136: File path that was analyzed
Line 138: Programming language detected
Line 140: Extraction method used
Line 142: List of extracted comments
Line 144: Generated structural insights about the code
Line 150: Statistics about comment extraction
Line 153: Total comments found
Line 155: Comments by type
Line 157: Total lines of code processed
Line 159: Processing time in milliseconds
Line 161: Whether extraction was successful
Line 163: Error message if extraction failed
Line 167: Main comment extractor leveraging CodeHUD's tree-sitter engine
Line 169: Configuration for extraction behavior
Line 174: Create a new comment extractor
Line 181: Create with custom configuration
Line 188: Extract comments from a single file
Line 192: Read file content
Line 196: Detect language from file extension
Line 199: Extract comments using tree-sitter
Line 202: Structural insights will be added later in batch processing
Line 219: Extract comments from multiple files in a directory
Line 225: Walk directory recursively
Line 238: Skip build artifacts and common ignore patterns
Line 247: Check if we support this language
Line 256: Continue with other files
Line 265: Run narrator in batch and add insights to results
Line 273: Add narrator insights to all extractions in batch (runs narrator once for all files)
Line 282: Read file content
Line 291: Get appropriate language parser
Line 295: Parse with tree-sitter
Line 310: Convert to FileCst and run narrator
Line 320: Convert to StructuralInsights format
Line 359: Extract comments from file content using tree-sitter
Line 366: Use shared query engine instance for performance
Line 389: Extract comments from tree-sitter analysis result
Line 398: Look for dedicated comments section first
Line 407: Get comment type from the analysis
Line 413: Fallback: determine from text content
Line 461: Parse comment from tree-sitter highlight
Line 474: Extract comment text
Line 478: Determine comment type
Line 481: Extract context if enabled
Line 499: Parse comment from tree-sitter capture
Line 505: Similar to parse_comment_from_highlight but for capture format
Line 506: Implementation would be similar, adapting to capture data structure
Line 510: Fallback comment extraction using regex patterns
Line 518: Define regex patterns for different comment types
Line 541: Apply patterns line by line for better position tracking
Line 548: +1 for newline
Line 587: Detect programming language from file extension
Line 613: Clean comment text by removing comment markers and excess whitespace
Line 617: Remove common comment markers
Line 629: Remove leading asterisks from multiline comments
Line 638: Determine the type of comment based on markers
Line 655: Extract code context around a comment
Line 659: Find which line the comment is on
Line 669: +1 for newline
Line 672: Extract surrounding lines
Line 678: Try to extract function/class names (basic implementation)
Line 685: TODO: Extract from file structure
Line 691: Basic function name extraction
Line 693: Simple regex patterns for common languages
Line 712: Basic class name extraction
Line 731: Check if a comment should be included based on configuration
Line 733: Check comment type inclusion
Line 740: Check length constraints
Line 751: Skip divider comments if configured
Line 758: If comment is mostly divider characters, skip it
Line 767: Calculate extraction statistics
Line 797: Convert FileCommentExtraction to cleaned format optimized for LLM
Line 813: Clean comments by removing JSON overhead and comment markers
Line 822: Clean individual comment text for LLM consumption
Line 823: Conservative cleaning that preserves content while removing syntax bloat
Line 826: Only remove outermost comment markers, preserve inner content
Line 837: If cleaning made the text too short or empty, return original (minus just whitespace)
Line 845: Generate structural insights from code content
Line 849: Try to use narrator for bullet point generation
Line 861: Fallback to original method
Line 880: Extract entry points
Line 886: Extract IO operations
Line 892: Extract test patterns
Line 905: Generate bullet points using the narrator module
Line 909: Get the appropriate language parser
Line 913: Parse the content directly with tree-sitter
Line 921: Convert tree-sitter tree to FileCst format
Line 924: Use narrator to detect findings and generate bullet points
Line 931: Convert to StructuralInsights format
Line 934: Parse the bullet text into sections
Line 941: This is a section header
Line 948: This is a bullet point
Line 951: Special handling for role line
Line 956: Add the last section
Line 969: Convert language string to SupportedLanguage enum
Line 981: Convert tree-sitter tree to narrator FileCst format
Line 991: Recursively convert tree-sitter nodes to narrator Node format
Line 1005: Include text for all nodes - detectors need text from parent nodes too
Line 1019: Extract import patterns for multiple languages
Line 1056: Limit to avoid noise
Line 1059: Extract function/method patterns
Line 1096: Skip test functions here, handle in test patterns
Line 1104: Limit to key functions
Line 1107: Extract entry point patterns
Line 1136: Extract IO operation patterns
Line 1140: File IO patterns
Line 1157: Network IO patterns
Line 1194: Extract test patterns
Line 1239: Format cleaned analysis as text for LLM consumption
Line 1240: Balanced approach: removes JSON bloat but preserves essential context
Line 1246: Add comments section with minimal formatting
Line 1249: Limit to avoid excessive length
Line 1259: Add structural insights with logical grouping
Line 1263: Organize sections in a logical order
Line 1269: Limit per section to avoid noise
Line 1279: Add any remaining sections (limited)
Line 1282: Even more limited for misc sections

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 10958 characters
🤖 Analyzing: [████████████████████████████████████░░░░░░░░░░░░░░]  73% (22/30) - conversation.rs...🔍 DEBUG PROMPT for conversation.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal
- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs
Language: rust
Comments found: 18

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs
Language: rust
Module name: conversation

COMMENTS TO ANALYZE:
Line 422: Other strategies would be implemented here
Line 492: Project-level analysis memory for hierarchical summarization
Line 529: Accumulate insights from a crate summary
Line 535: Extract patterns from crate summary
Line 538: Extract architectural insights
Line 541: Extract technology stack information
Line 544: Build crate relationships
Line 548: Build enhanced context for final summary generation
Line 633: Look for crate references in summary
Line 646: Enhanced conversation tracker with project analysis memory
Line 648: Create a new project analysis memory for hierarchical processing
Line 651: Store in conversation context with special project ID
Line 663: 12K token budget for hierarchical analysis
Line 674: Get project analysis memory for a project
Line 677: For now, create empty memory - in full implementation would persist/retrieve
Line 681: Update project memory with crate insights
Line 683: In full implementation, would retrieve, update, and persist memory
Line 684: For now, just log the accumulation

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4002 characters
🤖 Analyzing: [██████████████████████████████████████░░░░░░░░░░░░]  76% (23/30) - extraction_fsm.rs...🔍 DEBUG PROMPT for extraction_fsm.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal
- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/extraction_fsm.rs
Language: rust
Comments found: 320

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/extraction_fsm.rs
Language: rust
Module name: extraction_fsm

COMMENTS TO ANALYZE:
Line 1: ! LLM Comment Extraction Finite State Machine
Line 3: ! This module implements an FSM-based interface for LLM comment extraction
Line 4: ! with two primary modes: single file scanning and project scanning with
Line 5: ! context accumulation.
Line 23: FSM states for the comment extraction process
Line 26: Initial state - ready to accept scan commands
Line 28: File picker mode - waiting for single file selection
Line 30: Single file scanning in progress
Line 32: Project scanning initialization
Line 34: Hierarchical project scan - discovering crates
Line 36: Processing files within each crate for crate-level summaries
Line 43: Project scanning in progress - processing individual files (legacy mode)
Line 50: Generating final project summary from crate summaries
Line 55: Accumulating context and generating project summary (legacy mode)
Line 57: Scan completed successfully
Line 63: Types of scan operations
Line 66: Single file scan with immediate result
Line 68: Project-wide scan with context accumulation
Line 72: Result of a scan operation
Line 75: Whether the scan completed successfully
Line 77: Number of files processed
Line 79: Total scan duration in seconds
Line 81: Summary description of results
Line 83: Any errors encountered
Line 99: Detailed scan results by type
Line 102: Single file scan result
Line 108: Project scan result with accumulated context
Line 116: File summary with accumulated context from previous files
Line 119: Path to the file
Line 123: LLM-generated summary for this file
Line 125: Context from previous files that influenced this summary
Line 127: Processing order in the project scan
Line 131: Project-wide summary with accumulated insights
Line 134: Overall project understanding
Line 136: Key architectural insights
Line 138: Common patterns found across files
Line 140: Identified issues or improvements
Line 142: Total files processed
Line 144: Total comments analyzed
Line 148: FSM events that trigger state transitions
Line 151: Start single file scan mode
Line 153: File selected for single scan
Line 155: Start project scan mode
Line 157: Project directory selected
Line 159: Single file processing completed
Line 165: Project file processing completed
Line 171: All project files processed, ready for final summary
Line 173: Crate discovery completed
Line 177: Single crate summary completed
Line 181: All crate summaries completed, ready for final summary
Line 185: Project summary generation completed
Line 189: Reset to initial state
Line 193: Context accumulator for project scans
Line 196: Accumulated understanding from processed files
Line 198: File summaries in processing order
Line 200: Total comments processed
Line 202: Architectural patterns discovered
Line 206: Main FSM for LLM comment extraction
Line 210: File processor for LLM analysis
Line 214: Project context accumulator
Line 216: Event listeners for GUI/CLI integration
Line 218: Project analysis memory for hierarchical context accumulation
Line 220: Whether to use insights-only mode for ultra token-efficient analysis
Line 225: Create a new FSM instance
Line 248: Get current state
Line 253: Add event listener for GUI/CLI integration
Line 261: Process an event and transition state
Line 279: From Ready state
Line 285: Reset project context
Line 287: Stay in Ready state until project is selected
Line 290: File picker mode
Line 296: Start async file processing
Line 300: Project selection - start with hierarchical crate discovery
Line 302: First, transition to crate grouping state
Line 307: Start async crate discovery
Line 311: File processing completion
Line 319: Will be updated by actual processing
Line 326: Project file completion
Line 332: Update project context
Line 343: All files processed, generate project summary
Line 349: Continue with next file
Line 361: Project summary completion
Line 369: Will be updated by actual processing
Line 378: Hierarchical processing state transitions
Line 380: Crate discovery completion
Line 388: Processing is now handled directly in start_crate_discovery
Line 389: This event handler is no longer needed but kept for compatibility
Line 393: Single crate summary completion
Line 406: All crates processed, move to final summary generation state
Line 409: This will be collected properly
Line 413: Process next crate
Line 421: This is now handled directly in start_crate_discovery
Line 425: All crate summaries complete - generate final summary
Line 434: Release the borrow before async call
Line 445: Reset to ready
Line 451: Invalid transitions - ignore or log
Line 460: Process a single file scan
Line 467: Generate LLM summary
Line 475: Directly update state instead of calling process_event to avoid recursion
Line 481: TODO: Track actual duration
Line 498: Start project scan with proper two-phase architecture
Line 501: Discover all supported files in the project
Line 511: PHASE 1: BULK COMMENT EXTRACTION (Tree-sitter only)
Line 518: Real-time progress bar for extraction
Line 532: Extract comments using tree-sitter (fast, no LLM calls)
Line 542: Continue with other files
Line 547: Clear progress bar and show Phase 1 completion
Line 555: Save extracted comments to JSON for potential reuse/debugging
Line 570: PHASE 2: BATCH LLM ANALYSIS WITH ENHANCED CONTEXT
Line 575: FINAL PHASE: Generate comprehensive project summary
Line 580: Save the results to files
Line 581: Save comprehensive summary
Line 586: Save individual file summaries as JSON
Line 592: Save project metadata
Line 626: Process a single project file without FSM recursion
Line 634: Get accumulated context for this file
Line 642: Generate LLM summary with context
Line 650: Add to project context
Line 656: Process a single file in project context (legacy recursive version)
Line 662: Get accumulated context for this file
Line 671: Generate LLM summary with context
Line 685: Handle project file completion directly
Line 688: Check if more files need processing by examining current state
Line 701: All files processed, move to summary generation
Line 705: Release the lock before calling generate_project_summary
Line 710: Continue with next file
Line 719: Don't recurse - just update state and let the caller continue
Line 734: Add file results to project context
Line 744: Create file summary with context
Line 756: Update accumulated knowledge
Line 765: Keep context manageable (limit to ~8000 characters)
Line 775: Generate final project summary
Line 780: Create comprehensive prompt for project summary
Line 788: Generate project summary using LLM
Line 793: TODO: Parse from LLM response
Line 794: TODO: Parse from LLM response
Line 795: TODO: Parse from LLM response
Line 805: Directly update state for project completion
Line 812: TODO: Track actual duration
Line 829: Generate LLM summary for a single file
Line 850: Generate LLM summary for a file with project context
Line 871: Generate comprehensive LLM analysis of all project comments at once
Line 904: Generate comprehensive project summary from individual file summaries
Line 930: Phase 2: Analyze all extractions with enhanced context and batching
Line 937: Group files into smart batches based on similarity or module structure
Line 943: Build enhanced context for this batch
Line 946: Process files in this batch with shared context
Line 962: Analyze this file with enhanced context and higher token limits
Line 969: Continue with other files
Line 975: Clear progress bar and show completion
Line 984: Ultra token-efficient insights-only file analysis for budget-constrained mode
Line 1006: Generate ultra-compact summary using only structural insights
Line 1013: Continue with other files
Line 1018: Clear progress bar and show completion
Line 1028: Generate ultra-compact file summary using only structural insights (token-efficient)
Line 1030: Build ultra-compact prompt using only structural insights
Line 1036: Add structural insights if available
Line 1052: Add only essential comments (limit to ~10 most important)
Line 1054: Filter out very short comments
Line 1055: Limit to 10 comments max
Line 1068: Debug: Show prompt length to verify it's compact
Line 1071: Generate summary using the LLM
Line 1075: Convert full file path to relative path for token efficiency
Line 1077: For now, just return the file name - this can be enhanced later with project-relative paths
Line 1085: Generate enhanced comprehensive project summary with increased token limits
Line 1114: Use enhanced token limits for comprehensive analysis
Line 1118: Group extractions into smart batches based on file structure and dependencies
Line 1121: Process 5 files at a time for better context sharing
Line 1123: Simple batching for now - can be enhanced with more sophisticated grouping
Line 1131: Build enhanced context for a batch of files
Line 1139: Include recent analyses for context
Line 1154: Generate enhanced file summary with better prompting and higher token limits
Line 1166: Add structural insights if available
Line 1177: If no structural insights, extract basic file context from file path and language
Line 1184: Extract filename which often indicates purpose
Line 1192: Filter out garbage comments (regex patterns, single words, etc.)
Line 1196: Skip single words, regex patterns, and other garbage
Line 1200: Skip common regex comment patterns
Line 1217: Debug: Log the actual prompt being sent to LLM
Line 1227: Discover supported files in a project directory
Line 1240: Only include Rust files for now (can expand later)
Line 1252: ================== HIERARCHICAL PROCESSING METHODS ==================
Line 1254: Static helper for discovering project files without borrowing self
Line 1281: Start crate discovery for hierarchical processing
Line 1286: Initialize crate grouper
Line 1289: Discover all crates in the project
Line 1292: If no crates found, create a virtual crate
Line 1303: Will be populated during processing
Line 1313: Start hierarchical crate processing directly
Line 1316: Clear output files from previous runs to prevent accumulation
Line 1325: Clear from multiple possible locations since working directory can vary
Line 1335: Create if doesn't exist, ignore errors
Line 1346: Initialize progress monitor (popup window if running in background)
Line 1347: Total steps: 3 phases per crate + 1 final summary
Line 1354: ===== PHASE 1: Extract comments and generate file summaries for ALL crates =====
Line 1382: ===== PHASE 2: Detect subcrates and generate subcrate summaries for ALL crates =====
Line 1392: Accumulate all subcrates from all crates into one combined structure
Line 1403: Process crate and get subcrates back instead of saving per-crate
Line 1410: Save ONE combined subcrate file for all crates
Line 1420: ===== PHASE 3: Generate crate summaries for ALL crates =====
Line 1447: Generate final hierarchical summary
Line 1457: Mark as completed
Line 1463: Note: generate_final_summary() already sets the FSM state to ScanComplete
Line 1469: Generate hierarchical project summary from crate summaries
Line 1473: Apply dual-stage denoising to crate summaries for 12K budget
Line 1476: Build hierarchical summary prompt with 12K token budget
Line 1516: Enforce 12K token budget
Line 1520: Generate final summary via LLM with extended output tokens (1024 for 600-1000 words)
Line 1523: Create project summary
Line 1530: TODO: Could aggregate from crate summaries
Line 1533: Save the hierarchical summary to output
Line 1543: Update state to completed
Line 1559: Get project analysis memory for context-aware processing
Line 1564: Apply intelligent denoising that preserves technical content
Line 1568: Skip denoising for single crate scenarios to preserve content
Line 1577: Apply single-stage intelligent denoising (40% reduction, keeping 60%)
Line 1582: Rough token estimate
Line 1595: Apply intelligent denoising that preserves technical content (40% reduction)
Line 1600: Don't denoise very short summaries
Line 1605: Split into sentences and rank by importance
Line 1610: Keep very short summaries intact
Line 1623: Sort by importance score (descending)
Line 1626: Keep top 60% of sentences (40% reduction)
Line 1635: Sort by original order to maintain flow
Line 1647: Calculate importance score for a sentence (higher = more important)
Line 1652: Technical keywords boost
Line 1678: Penalize filler content
Line 1690: Boost sentences with concrete details
Line 1695: Length consideration (medium-length sentences often more informative)
Line 1706: Enforce token budget by truncating if necessary
Line 1708: Rough estimate: 4 chars per token
Line 1727: PHASE 1: Extract comments and generate file summaries for a single crate
Line 1731: Only discover files within this specific crate directory
Line 1742: Extract comments only from files in this crate
Line 1761: ===== BATCH NARRATOR PROCESSING =====
Line 1766: ===== SAVE STRUCTURED JSON DATA =====
Line 1774: Append extracted comments to cumulative JSON file
Line 1783: Add current crate's extractions
Line 1786: Save updated cumulative file
Line 1792: PHASE 2: BATCH LLM ANALYSIS WITH ENHANCED CONTEXT
Line 1796: Use ultra token-efficient insights-only file analysis
Line 1799: Use full enhanced context analysis
Line 1803: Append file summaries to cumulative JSON file
Line 1812: Add current crate's summaries
Line 1815: Save updated cumulative file
Line 1820: Update cumulative analysis metadata
Line 1835: Add current crate info
Line 1858: PHASE 2: Detect subcrates and generate subcrate summaries for a single crate (returns subcrates)
Line 1860: Skip if insights-only mode
Line 1868: Initialize crate summarizer
Line 1872: Load file summaries for this crate
Line 1875: Need to load comment extractions to pass to load_file_summaries_for_crate
Line 1886: Filter to just this crate's extractions (canonicalize both paths for comparison)
Line 1894: Convert file path to absolute by canonicalizing relative to project root
Line 1915: Generate subcrate summaries (bottom-up hierarchical summarization)
Line 1921: Return subcrates for accumulation
Line 1930: PHASE 2: Detect subcrates and generate subcrate summaries for a single crate (OLD - saves to disk)
Line 1932: Skip if insights-only mode
Line 1940: Initialize crate summarizer
Line 1944: Load file summaries for this crate
Line 1947: Need to load comment extractions to pass to load_file_summaries_for_crate
Line 1958: Filter to just this crate's extractions (canonicalize both paths for comparison)
Line 1966: Convert file path to absolute by canonicalizing relative to project root
Line 1987: Generate subcrate summaries (bottom-up hierarchical summarization)
Line 1993: Save subcrate summaries to a JSON file for Phase 3 to load
Line 2006: PHASE 3: Generate crate summary for a single crate
Line 2008: Initialize crate summarizer
Line 2012: Get project memory for context-aware analysis
Line 2015: Determine output directory
Line 2022: Load comment extractions
Line 2033: Filter to just this crate's extractions (canonicalize both paths for comparison)
Line 2041: Convert file path to absolute by canonicalizing relative to project root
Line 2060: Generate crate summary using insights-only or full method based on configuration
Line 2062: Use ultra token-efficient insights-only analysis
Line 2068: Load file summaries for crate summary generation
Line 2071: Load pre-existing subcrate summaries from combined file (already generated in Phase 2)
Line 2077: Extract this crate's subcrates from the combined file
Line 2090: Use full context-aware analysis with subcrate summaries
Line 2104: Save crate summary to cumulative JSON file
Line 2119: Add current crate summary
Line 2122: Save updated crate summaries
Line 2127: Update project memory with this crate's insights
Line 2136: Generate final hierarchical summary from all processed crates
Line 2140: Load real crate summaries from the generated file (use correct directory based on insights_only mode)
Line 2158: Apply dual-stage denoising to crate summaries for 12K budget
Line 2161: Build crate summaries string once (reused across passes)
Line 2176: MULTI-PASS REASONING WITH CONVERSATION MEMORY
Line 2179: ===== PASS 1: Extract Facts =====
Line 2196: ===== PASS 2: Group by Functional Layers =====
Line 2211: ===== PASS 3: Identify Data Flow =====
Line 2228: ===== PASS 4: Generate Final Summary =====
Line 2250: Save intermediate passes for debugging/inspection
Line 2263: Save the hierarchical summary to output (use correct directory based on insights_only mode)
Line 2277: Update state to completed
Line 2296: CLI interface for the FSM
Line 2306: Execute "scan file" command
Line 2310: Direct file path provided
Line 2314: Enter file picker mode
Line 2317: In a real CLI, this would show a file picker or prompt for input
Line 2323: Execute "scan project" command
Line 2332: In a real CLI, this would show a directory picker or prompt for input
Line 2338: Get current scan results
Line 2346: Reset FSM to ready state
Line 2352: GUI integration points
Line 2354: Show file picker dialog
Line 2356: Show project directory picker
Line 2358: Update progress display
Line 2360: Display scan results
Line 2362: Show error message

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 20048 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (24/30) - critical.rs...🔍 DEBUG PROMPT for critical.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal
- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/critical.rs
Language: rust
Comments found: 163

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/critical.rs
Language: rust
Module name: critical

COMMENTS TO ANALYZE:
Line 1: ! Critical Mistake Detection and Self-Correction System
Line 3: ! This module implements advanced mistake detection with automatic correction
Line 4: ! capabilities, preserving the Python implementation's 97%+ bug fix success rate
Line 5: ! during Phase 5a through FFI bridge integration.
Line 12: Types of critical mistakes that can be detected
Line 27: Infinite loops or recursion
Line 31: Location in code where a mistake was detected
Line 34: Line number (1-indexed)
Line 36: Column number (1-indexed)
Line 38: Length of the problematic code
Line 42: A detected critical mistake with correction information
Line 45: Type of mistake detected
Line 47: Severity level (1-10)
Line 49: Description of the mistake
Line 51: Location in the generated code
Line 55: Confidence in the detection (0.0-1.0)
Line 57: Context around the mistake
Line 61: Critical mistake detector with self-correction capabilities
Line 63: During Phase 5a, this delegates to the Python implementation for guaranteed
Line 64: compatibility while building the Rust analysis infrastructure.
Line 68: Analysis rules for different mistake types
Line 70: Python FFI bridge (Phase 5a)
Line 78: Configuration for mistake detection
Line 81: Enable syntax error detection
Line 83: Enable logic error detection
Line 85: Enable security vulnerability detection
Line 87: Enable performance issue detection
Line 89: Enable type mismatch detection
Line 91: Enable resource leak detection
Line 93: Enable infinite execution detection
Line 95: Maximum correction attempts
Line 97: Severity threshold for automatic correction
Line 99: Enable learning from corrections
Line 114: High severity and above
Line 120: Detection rule for specific mistake patterns
Line 125: Mistake type this rule detects
Line 129: Pattern to match (regex or code pattern)
Line 131: Rule severity (1-10)
Line 133: Language this rule applies to
Line 135: Suggested correction template
Line 137: Whether this rule is enabled
Line 144: Total code samples analyzed
Line 146: Total mistakes detected
Line 148: Mistakes by type
Line 150: Mistakes by severity
Line 156: Average detection time (milliseconds)
Line 158: False positive rate
Line 162: Record of a correction attempt
Line 165: Original code with mistake
Line 169: Mistakes that were corrected
Line 175: Correction method used
Line 177: Validation results after correction
Line 181: Methods used for correction
Line 192: Manual correction (human-provided)
Line 196: Validation result after correction
Line 201: Whether validation passed
Line 205: Time taken for validation (milliseconds)
Line 209: Types of validation performed
Line 226: Detection result with metadata
Line 235: Confidence in detections
Line 242: Time taken for detection (milliseconds)
Line 244: Number of rules applied
Line 246: Analysis depth level
Line 250: Code complexity score
Line 254: Analysis depth levels
Line 257: Surface-level pattern matching
Line 259: Syntax tree analysis
Line 269: Suggested correction for a detected mistake
Line 272: Mistake being corrected
Line 278: Confidence in the correction
Line 280: Explanation of the correction
Line 282: Location where correction should be applied
Line 287: Create a new critical mistake detector
Line 300: Create with Python FFI bridge for Phase 5a compatibility
Line 310: Detect critical mistakes in code
Line 315: Phase 5a: Use Python bridge for guaranteed compatibility
Line 320: Native Rust implementation (Phase 5b)
Line 324: Detect via Python bridge (Phase 5a)
Line 330: Call Python critical mistake detector directly
Line 345: Generate suggested corrections using Rust logic
Line 348: Update average detection time
Line 358: Python uses semantic analysis
Line 363: High confidence from Python implementation
Line 367: Native detection implementation (Phase 5b)
Line 374: Apply all enabled detection rules
Line 401: Generate suggested corrections
Line 414: Lower confidence for native implementation initially
Line 418: Apply a single detection rule
Line 424: Pattern matching based on rule type
Line 436: Detect syntax errors
Line 446: Use regex pattern matching for now
Line 471: Detect logic errors
Line 481: Common logic error patterns
Line 515: Detect security vulnerabilities
Line 525: Common security vulnerability patterns
Line 543: Security issues are high severity
Line 561: Detect performance issues
Line 571: Common performance issue patterns
Line 605: Detect type mismatches
Line 615: Basic type mismatch detection (would be enhanced with proper type inference)
Line 648: Detect resource leaks
Line 658: Resource leak patterns
Line 673: Resource leaks are serious
Line 691: Detect infinite execution patterns
Line 701: Infinite execution patterns
Line 716: Infinite execution is critical
Line 734: Generate suggested corrections for detected mistakes
Line 751: Generate correction for a specific mistake
Line 773: Generate correction based on mistake type
Line 805: Generate syntax correction
Line 817: Generate security correction
Line 834: Generate performance correction
Line 846: Detect programming language
Line 859: Calculate code complexity score
Line 866: Simple complexity calculation
Line 870: Load default detection rules
Line 916: Get current detection statistics
Line 921: Get correction history
Line 931: Add custom detection rule
Line 936: Remove detection rule by ID

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8287 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  83% (25/30) - equivalence.rs...🔍 DEBUG PROMPT for equivalence.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, utility_class.rs, is a part of the CodeHUD system and its main purpose is to detect potential crudeness in code snippets related to static methods within different programming language
- render.rs: The file `render.rs` in the Rust implementation of CodeHUD's LLM project, serves as a module for rendering various elements into a compact format for use by an LLM (Language Model) inference framework
- constitutional.rs: This file, `constitutional.rs` in the Rust implementation of CodeHUD's LLM project, does not seem to contain any specific functions, features, or behaviors that are immediately apparent from its conte
- lib.rs: This Rust file, `lib.rs`, is the main entry point for CodeHUD's LLM project. It provides complete LLM integration by maintaining zero-degradation compatibility with Python functionality. This crate al
- progress_monitor.rs: This file, `progress_monitor.rs`, serves as a utility for managing and tracking the progress of long-running operations in CodeHUD's LLM project. It offers features such as displaying a popup terminal
- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/equivalence.rs
Language: rust
Comments found: 49

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/equivalence.rs
Language: rust
Module name: equivalence

COMMENTS TO ANALYZE:
Line 1: ! Zero-Degradation Equivalence Testing
Line 3: ! This module implements comprehensive testing to ensure the Rust FFI bridge
Line 4: ! produces identical results to direct Python calls, maintaining 97%+ bug fix
Line 5: ! success rate as required by the plan.
Line 31: Rust/Python execution time ratio
Line 42: Patterns that should be in the fix
Line 52: Create a new equivalence tester with Python bridge
Line 56: Load predefined test cases
Line 65: Run comprehensive equivalence tests
Line 69: Test 1: Structured Code Generation Equivalence
Line 72: Test 2: Critical Mistake Detection Equivalence
Line 75: Test 3: Constitutional AI Assessment Equivalence
Line 78: Test 4: Conversation Tracking Equivalence
Line 81: Test 5: Validation System Equivalence
Line 84: Test 6: Bug Fix Generation Equivalence (97% success rate test)
Line 110: Test structured code generation equivalence
Line 130: Call through Rust FFI bridge - convert constraints
Line 145: Direct Python call (would need to be implemented)
Line 151: 95% similarity threshold
Line 170: Test critical mistake detection equivalence
Line 179: Call through Rust FFI bridge
Line 188: Direct Python call
Line 194: Should detect at least one mistake
Line 213: Test constitutional AI assessment equivalence
Line 220: Call through Rust FFI bridge
Line 228: Direct Python call
Line 234: Should fail due to security issues
Line 253: Test conversation tracking equivalence
Line 259: Test conversation through Rust FFI bridge
Line 275: Direct Python call
Line 300: Test validation system equivalence
Line 311: Call through Rust FFI bridge
Line 319: Direct Python call
Line 325: Should detect security issues
Line 344: Test bug fix generation equivalence (97% success rate requirement)
Line 351: Generate bug fix through Rust FFI bridge
Line 362: Direct Python call
Line 369: Check if fix contains expected patterns
Line 395: Calculate text similarity between two outputs
Line 397: Simple similarity calculation based on common words and structure
Line 411: Calculate performance ratio (Rust/Python execution time)
Line 427: Direct Python call for comparison (simplified implementation)
Line 429: This would make direct Python calls without going through the bridge
Line 430: For now, return a placeholder that simulates Python output
Line 442: Load predefined bug fix test cases
Line 483: Generate comprehensive equivalence report

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5356 characters
📦 Processing batch 6/6 (5 files)...
🤖 Analyzing: [███████████████████████████████████████████░░░░░░░]  86% (26/30) - native_stub.rs...🔍 DEBUG PROMPT for native_stub.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul
- comment_extractor.rs: This file, `comment_extractor.rs`, is a key component of the CodeHUD's LLM project and serves as an engine for comment extraction with tree-sitter integration. It leverages CodeHUD's existing enhanced
- conversation.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs in the Rust implementation of CodeHUD's LLM project serves as a module for managing and tracking conversations, 
- extraction_fsm.rs: This file is a comprehensive source code for an advanced static analysis tool named "Static Scanner". This tool is designed specifically for large-scale programming projects, offering deep insights in
- critical.rs: This file serves as the central module for a critical mistake detection and self-correction system in a code analysis tool known as CodeHUD. It implements advanced features such as automatic correctio
- equivalence.rs: This Rust file, equivalence.rs, is a module in the CodeHUD system designed for testing and evaluating the equivalence of different code snippets across various programming languages. It performs compr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/native_stub.rs
Language: rust
Comments found: 5

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/native_stub.rs
Language: rust
Module name: native_stub

COMMENTS TO ANALYZE:
Line 1: ! Native Rust LLM Engine - Phase 5b Stub Implementation
Line 3: ! This is a stub implementation that provides the interface without candle dependencies
Line 4: ! for GUI integration testing. The full implementation will be enabled with candle feature.
Line 14: Native Rust LLM Engine stub
Line 58: Always loaded in stub mode

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3313 characters
🤖 Analyzing: [█████████████████████████████████████████████░░░░░]  90% (27/30) - native.rs...🔍 DEBUG PROMPT for native.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul
- comment_extractor.rs: This file, `comment_extractor.rs`, is a key component of the CodeHUD's LLM project and serves as an engine for comment extraction with tree-sitter integration. It leverages CodeHUD's existing enhanced
- conversation.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs in the Rust implementation of CodeHUD's LLM project serves as a module for managing and tracking conversations, 
- extraction_fsm.rs: This file is a comprehensive source code for an advanced static analysis tool named "Static Scanner". This tool is designed specifically for large-scale programming projects, offering deep insights in
- critical.rs: This file serves as the central module for a critical mistake detection and self-correction system in a code analysis tool known as CodeHUD. It implements advanced features such as automatic correctio
- equivalence.rs: This Rust file, equivalence.rs, is a module in the CodeHUD system designed for testing and evaluating the equivalence of different code snippets across various programming languages. It performs compr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/native.rs
Language: rust
Comments found: 93

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/native.rs
Language: rust
Module name: native

COMMENTS TO ANALYZE:
Line 1: ! Native Rust LLM Engine - Phase 5b Implementation
Line 3: ! This module implements the native Rust LLM engine using candle-core,
Line 4: ! replacing the FFI bridge from Phase 5a while maintaining 97%+ bug fix
Line 5: ! success rate and zero-degradation compatibility.
Line 19: Placeholder types when candle is not available
Line 34: Native Rust LLM Engine using candle-core
Line 36: Model management and loading
Line 38: Tokenizer for input/output processing
Line 40: Inference engine for model execution
Line 42: Constraint system for structured generation
Line 46: Device for computation (CPU/CUDA/Metal)
Line 50: Model Manager for handling multiple model types
Line 52: Loaded models cache
Line 54: HuggingFace API for model downloading
Line 56: Model cache directory
Line 60: Loaded model with metadata
Line 63: Model weights and architecture
Line 69: Device the model is loaded on
Line 73: Model configuration matching Python implementation
Line 97: Native inference engine
Line 99: Current active model
Line 103: KV cache for conversation context
Line 107: Generation configuration matching Python behavior
Line 121: KV Cache for efficient conversation handling
Line 124: Cached key-value pairs
Line 128: Max cache length
Line 132: Constraint system for structured generation
Line 134: JSON schema validators
Line 136: Grammar rules for code generation
Line 138: Constraint enforcement strategies
Line 142: Grammar rule for structured generation
Line 151: Constraint enforcement strategy
Line 161: Create a new native LLM engine
Line 163: Initialize device based on GPU configuration
Line 166: Initialize model manager
Line 169: Load tokenizer for the specified model
Line 172: Initialize inference engine
Line 177: Initialize constraint system
Line 190: Initialize device for computation
Line 213: Load tokenizer for the specified model
Line 222: Download tokenizer from HuggingFace
Line 233: Generate structured code with constraints (native implementation)
Line 242: Load model if not already loaded
Line 245: Apply constraints and generate
Line 248: Validate and post-process output
Line 252: Detect critical mistakes (native implementation)
Line 258: Analyze code for potential issues
Line 261: Generate analysis using the model
Line 265: Parse analysis into structured mistake format
Line 269: Generate bug fix with 97%+ success rate (core requirement)
Line 276: Build comprehensive fix prompt
Line 279: Generate fix with constraints to ensure correctness
Line 286: Validate fix quality and correctness
Line 290: Assess constitutional AI compliance (native implementation)
Line 304: === Private Helper Methods ===
Line 327: Convert tokens to tensor
Line 330: Generate with constraint guidance
Line 416: Validate against JSON schema if provided
Line 430: Validate output format
Line 439: Other formats would be validated here
Line 446: Use Python AST validation through tokenizer or external tool
Line 447: For now, basic validation
Line 452: Check for common syntax issues
Line 481: Parse LLM analysis into structured mistake format
Line 484: Simple parsing logic (would be more sophisticated in practice)
Line 507: Additional mistake detection patterns would be implemented here
Line 513: Find division operators in code
Line 532: Validate that the fix addresses the reported error
Line 535: Check that fix is different from original
Line 540: Validate fix addresses the specific error
Line 554: Parse LLM assessment into structured format
Line 562: Would be parsed from analysis
Line 565: Would be extracted from analysis
Line 570: === Implementation of supporting structures ===
Line 592: Download model files
Line 599: For now, create a placeholder loaded model
Line 600: In a real implementation, this would load the actual model weights
Line 635: Real implementation would use candle-core for inference with constraints
Line 636: Dummy token sequence
Line 641: Dummy token sequence
Line 687: Placeholder model implementation
Line 692: Placeholder - would implement actual forward pass

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6978 characters
🤖 Analyzing: [██████████████████████████████████████████████░░░░]  93% (28/30) - monitoring.rs...🔍 DEBUG PROMPT for monitoring.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul
- comment_extractor.rs: This file, `comment_extractor.rs`, is a key component of the CodeHUD's LLM project and serves as an engine for comment extraction with tree-sitter integration. It leverages CodeHUD's existing enhanced
- conversation.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs in the Rust implementation of CodeHUD's LLM project serves as a module for managing and tracking conversations, 
- extraction_fsm.rs: This file is a comprehensive source code for an advanced static analysis tool named "Static Scanner". This tool is designed specifically for large-scale programming projects, offering deep insights in
- critical.rs: This file serves as the central module for a critical mistake detection and self-correction system in a code analysis tool known as CodeHUD. It implements advanced features such as automatic correctio
- equivalence.rs: This Rust file, equivalence.rs, is a module in the CodeHUD system designed for testing and evaluating the equivalence of different code snippets across various programming languages. It performs compr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/monitoring.rs
Language: rust
Comments found: 18

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/monitoring.rs
Language: rust
Module name: monitoring

COMMENTS TO ANALYZE:
Line 165: Run health checks
Line 225: Would be implemented based on actual queue
Line 226: Would track active requests
Line 238: Would be calculated from validation results
Line 239: Would be calculated from user feedback
Line 240: Would be calculated from content analysis
Line 243: Would be collected from user feedback
Line 252: Would be calculated from actual usage
Line 253: Would track maximum concurrent users
Line 254: Would track actual bandwidth
Line 391: Simplified memory usage calculation
Line 392: Would use actual system metrics
Line 396: Simplified CPU usage calculation
Line 397: Would use actual system metrics
Line 401: Would query actual GPU metrics
Line 406: Would calculate from actual request history
Line 411: Would calculate tokens per second

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3746 characters
🤖 Analyzing: [████████████████████████████████████████████████░░]  96% (29/30) - phase_5b_validation.rs...🔍 DEBUG PROMPT for phase_5b_validation.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul
- comment_extractor.rs: This file, `comment_extractor.rs`, is a key component of the CodeHUD's LLM project and serves as an engine for comment extraction with tree-sitter integration. It leverages CodeHUD's existing enhanced
- conversation.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs in the Rust implementation of CodeHUD's LLM project serves as a module for managing and tracking conversations, 
- extraction_fsm.rs: This file is a comprehensive source code for an advanced static analysis tool named "Static Scanner". This tool is designed specifically for large-scale programming projects, offering deep insights in
- critical.rs: This file serves as the central module for a critical mistake detection and self-correction system in a code analysis tool known as CodeHUD. It implements advanced features such as automatic correctio
- equivalence.rs: This Rust file, equivalence.rs, is a module in the CodeHUD system designed for testing and evaluating the equivalence of different code snippets across various programming languages. It performs compr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/tests/phase_5b_validation.rs
Language: rust
Comments found: 27

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/tests/phase_5b_validation.rs
Language: rust
Module name: phase_5b_validation

COMMENTS TO ANALYZE:
Line 1: ! Phase 5b Native LLM Implementation Validation Tests
Line 3: ! These tests validate that the native Rust LLM engine maintains 97%+ bug fix
Line 4: ! success rate and zero-degradation compatibility while eliminating Python dependencies.
Line 18: Use CPU for testing
Line 31: Test basic functionality
Line 68: Create pipeline with native engine
Line 71: Test basic text generation
Line 112: Validate fix quality
Line 131: Phase 5b requirement: maintain 97%+ success rate
Line 276: Test native engine performance
Line 281: Validate output quality
Line 289: Performance should be reasonable (less than 30 seconds for simple generation)
Line 303: Test 1: Native engine initialization
Line 308: Test 2: Model management (4+ model types)
Line 318: Test 3: GPU acceleration types
Line 322: Test 4: Core LLM capabilities
Line 336: Critical mistake detection
Line 340: Bug fix generation
Line 363: Helper function to simulate model availability check
Line 365: In a real implementation, this would check if the model is downloaded
Line 374: Helper function to simulate GPU availability check
Line 377: CPU always available
Line 379: Would check for CUDA installation
Line 383: Would check for Metal support (macOS)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4223 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (30/30) - equivalence_tests.rs...🔍 DEBUG PROMPT for equivalence_tests.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: This Rust file, ffi.rs, is the FFI (Foreign Function Interface) Bridge for CodeHUD's LLM project. It implements Phase 5a of the plan by calling Python LLM implementations directly through FFI to guara
- structured.rs: This file, structured.rs, is a module within the CodeHUD system designed for generating and validating structured code snippets with specific constraints, enforcing grammar-based rules and JSON schema
- denoiser.rs: This Rust file, denoiser.rs, is a module for handling and analyzing text data in the context of large datasets used by Large Language Models (LLMs). It specializes in reducing redundant information wi
- file_processor.rs: This file (file_processor.rs) serves as a comprehensive solution for processing and analyzing code comments in Rust, specifically designed according to the three-phase workflow described in LLM_vision
- crate_summarizer.rs: The file `crate_summarizer.rs` in the Rust implementation of CodeHUD's LLM project serves as a module that manages and summarizes code crates for hierarchical language model (LLM) analysis. This modul
- comment_extractor.rs: This file, `comment_extractor.rs`, is a key component of the CodeHUD's LLM project and serves as an engine for comment extraction with tree-sitter integration. It leverages CodeHUD's existing enhanced
- conversation.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/src/conversation.rs in the Rust implementation of CodeHUD's LLM project serves as a module for managing and tracking conversations, 
- extraction_fsm.rs: This file is a comprehensive source code for an advanced static analysis tool named "Static Scanner". This tool is designed specifically for large-scale programming projects, offering deep insights in
- critical.rs: This file serves as the central module for a critical mistake detection and self-correction system in a code analysis tool known as CodeHUD. It implements advanced features such as automatic correctio
- equivalence.rs: This Rust file, equivalence.rs, is a module in the CodeHUD system designed for testing and evaluating the equivalence of different code snippets across various programming languages. It performs compr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/tests/equivalence_tests.rs
Language: rust
Comments found: 39

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm/tests/equivalence_tests.rs
Language: rust
Module name: equivalence_tests

COMMENTS TO ANALYZE:
Line 1: ! Comprehensive Equivalence Tests for Zero-Degradation Validation
Line 3: ! These tests ensure the Rust FFI bridge maintains 97%+ bug fix success rate
Line 4: ! and produces equivalent results to the Python implementation.
Line 11: Requires Python environment setup
Line 13: Set up the equivalence tester
Line 14: Adjust path as needed
Line 17: Run the full equivalence test suite
Line 20: Generate and print report
Line 24: Assert critical requirements
Line 37: Performance should not degrade significantly (allow up to 2x slower for FFI overhead)
Line 49: Requires Python environment setup
Line 64: Requires Python environment setup
Line 79: Requires Python environment setup
Line 112: Test that we can create the equivalence testing structures
Line 149: Create a mock tester for testing similarity calculation
Line 150: Note: This would need the actual Python environment in practice
Line 153: Test similarity calculation logic
Line 157: Perfect match should be 1.0 similarity
Line 158: This would need to be implemented as a standalone function for testing
Line 162: Integration test that validates the complete zero-degradation pipeline
Line 164: Requires full Python environment and test data
Line 168: Step 1: Initialize the equivalence tester
Line 171: Step 2: Run comprehensive equivalence tests
Line 174: Step 3: Validate all zero-degradation requirements
Line 179: Step 4: Generate comprehensive report
Line 182: Write report to file for review
Line 192: Stress test for concurrent FFI bridge usage
Line 194: Requires Python environment setup
Line 199: Create multiple concurrent tasks
Line 208: Wait for all tasks to complete
Line 223: Memory leak detection test for long-running FFI usage
Line 225: Requires Python environment setup
Line 232: Run many iterations to detect potential memory leaks
Line 237: Check memory every 100 iterations
Line 242: Allow reasonable memory growth but detect leaks
Line 255: Helper function to get current memory usage
Line 264: Convert KB to bytes
Line 270: Fallback for unsupported platforms

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5051 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (30/30) - Complete!
✅ Phase 2 complete: 30 files analyzed with enhanced context
📄 File summaries updated: 113 total files (30 from codehud-llm)
📄 Analysis metadata updated: 5 crates processed
🔍 DEBUG: Crate path for codehud-realtime: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime
🔍 Processing 1 files from crate codehud-realtime
🔍 DEBUG: First 5 files discovered for crate codehud-realtime:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime/src/lib.rs
🧠 Running narrator on 1 files in batch...
🔍 DEBUG: Found 34 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime/src/lib.rs
🔍 DEBUG: Bullet text length: 1664 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime/src/lib.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 114 total files (1 from codehud-realtime)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-realtime...
🤖 Analyzing 1 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (1 files)...
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (1/1) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime/src/lib.rs
Language: rust
Comments found: 51

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Real-time - Real-time analysis and file watching
Line 3: ! This crate provides real-time file system monitoring and incremental
Line 4: ! analysis capabilities matching the Python implementation.
Line 30: Real-time file monitoring and analysis system
Line 39: Configuration for real-time monitoring
Line 42: Debounce delay for file changes (milliseconds)
Line 44: Maximum files to analyze in a single batch
Line 46: Analysis timeout per file (seconds)
Line 48: Enable incremental analysis (only changed files)
Line 50: File patterns to watch
Line 52: File patterns to ignore
Line 80: Cache for analysis results
Line 88: Result of analyzing a single file
Line 100: Events emitted by the real-time monitor
Line 103: File was modified
Line 108: Analysis started for a batch of files
Line 113: Analysis completed for a file
Line 117: Batch analysis completed
Line 123: Error occurred during monitoring
Line 131: Create a new real-time monitor
Line 151: Configure the monitor
Line 157: Start real-time monitoring
Line 163: Set up file watcher
Line 178: Watch the codebase directory
Line 184: Start the event processing loop
Line 214: Process file system events
Line 229: Handle file system events
Line 248: Handle debounced batch processing
Line 279: Extract relevant files from a file system event
Line 289: Check if a file should be analyzed
Line 291: Must be within codebase
Line 296: Check ignore patterns
Line 306: Check watch patterns
Line 316: Analyze a batch of files
Line 328: Notify analysis started
Line 337: Check if we need to analyze this file (incremental analysis)
Line 346: Analyze the file with timeout
Line 376: Notify batch completed
Line 385: Analyze a single file
Line 402: Run topology analysis
Line 410: Run quality analysis
Line 418: Run security analysis
Line 439: Check if file should be skipped (for incremental analysis)
Line 454: Update analysis cache
Line 467: Calculate hash of file contents
Line 479: Simple glob pattern matching
Line 481: Simple implementation - in production would use glob crate

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2710 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (1/1) - Complete!
✅ Phase 2 complete: 1 files analyzed with enhanced context
📄 File summaries updated: 114 total files (1 from codehud-realtime)
📄 Analysis metadata updated: 6 crates processed
🔍 DEBUG: Crate path for codehud-transform: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform
🔍 Processing 15 files from crate codehud-transform
🔍 DEBUG: First 5 files discovered for crate codehud-transform:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/types.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/lib.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/engine.rs
  4. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/rollback.rs
  5. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/libcst.rs
🧠 Running narrator on 15 files in batch...
🔍 DEBUG: Found 9 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/types.rs
🔍 DEBUG: Bullet text length: 339 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/types.rs
🔍 DEBUG: Found 10 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/lib.rs
🔍 DEBUG: Bullet text length: 637 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/lib.rs
🔍 DEBUG: Found 39 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/engine.rs
🔍 DEBUG: Bullet text length: 2585 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/engine.rs
🔍 DEBUG: Found 44 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/rollback.rs
🔍 DEBUG: Bullet text length: 1823 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/rollback.rs
🔍 DEBUG: Found 25 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/libcst.rs
🔍 DEBUG: Bullet text length: 1010 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/libcst.rs
🔍 DEBUG: Found 14 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation.rs
🔍 DEBUG: Bullet text length: 1118 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation.rs
🔍 DEBUG: Found 17 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs
🔍 DEBUG: Bullet text length: 1229 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs
🔍 DEBUG: Found 27 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/mod.rs
🔍 DEBUG: Bullet text length: 1284 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/mod.rs
🔍 DEBUG: Found 25 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/magic_numbers.rs
🔍 DEBUG: Bullet text length: 1398 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/magic_numbers.rs
🔍 DEBUG: Found 13 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args.rs
🔍 DEBUG: Bullet text length: 999 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args.rs
🔍 DEBUG: Found 28 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language_old.rs
🔍 DEBUG: Bullet text length: 1664 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language_old.rs
🔍 DEBUG: Found 29 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/batch.rs
🔍 DEBUG: Bullet text length: 1752 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/batch.rs
🔍 DEBUG: Found 26 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation_old.rs
🔍 DEBUG: Bullet text length: 1505 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation_old.rs
🔍 DEBUG: Found 21 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args_old.rs
🔍 DEBUG: Bullet text length: 1170 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args_old.rs
🔍 DEBUG: Found 33 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/architectural.rs
🔍 DEBUG: Bullet text length: 1816 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/architectural.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 129 total files (15 from codehud-transform)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-transform...
🤖 Analyzing 15 files with enhanced context and improved token limits...
📦 Processing batch 1/3 (5 files)...
🤖 Analyzing: [███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   6% (1/15) - types.rs...🔍 DEBUG PROMPT for types.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/types.rs
Language: rust
Comments found: 114

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/types.rs
Language: rust
Module name: types

COMMENTS TO ANALYZE:
Line 1: ! Transformation Types and Core Data Structures
Line 3: ! This module defines all transformation types and supporting data structures
Line 4: ! exactly matching the Python implementation for zero degradation.
Line 11: All transformation types implemented exactly as in Python
Line 14: Extract magic numbers to constants
Line 16: Large-scale architectural changes
Line 18: Batch transformations with formatting
Line 20: Cross-language transformations via Comby
Line 22: Property-based and search-based test creation
Line 24: Code cleanup and dead code elimination
Line 29: Get all transformation types
Line 41: Get string representation matching Python
Line 53: Get display name for UI
Line 65: Check if transformation supports dry run
Line 72: Creates new files
Line 77: Check if transformation supports rollback
Line 79: All transformations support rollback via Git integration
Line 84: Status of a transformation operation - matching Python exactly
Line 87: Transformation is pending execution
Line 89: Transformation is currently in progress
Line 91: Transformation completed successfully
Line 95: Transformation was rolled back
Line 100: Get string representation matching Python
Line 112: A suggested transformation operation - matching Python dataclass exactly
Line 115: Type of transformation suggested
Line 117: Human-readable description of the transformation
Line 119: List of files that would be affected
Line 121: Confidence level (0.0 to 1.0)
Line 123: Estimated impact description
Line 125: Prerequisites that must be met
Line 127: Additional metadata for the transformation
Line 153: Complexity estimate for transformations
Line 156: Estimated execution time in seconds
Line 158: Number of files that will be modified
Line 160: Number of individual transformations
Line 162: Risk level for the transformation
Line 164: Confidence in the estimate (0.0 to 1.0)
Line 166: Estimated lines of code affected
Line 168: Whether manual review is recommended
Line 172: Risk levels for transformations
Line 175: Safe transformation with minimal risk
Line 177: Moderate risk, should be reviewed
Line 179: High risk, requires careful review
Line 181: Critical risk, expert review required
Line 186: Get display color for UI
Line 196: Get risk description
Line 207: Input data for transformations
Line 210: Source code to transform
Line 212: File path for context
Line 214: Language of the source code
Line 218: Analysis context from CodeHUD
Line 222: Configuration for transformations
Line 225: Whether to perform dry run only
Line 227: Whether to create backup before transformation
Line 229: Custom transformation parameters
Line 231: Target style guide (e.g., "pep8", "google", "microsoft")
Line 233: Maximum complexity allowed after transformation
Line 235: Whether to preserve comments
Line 237: Whether to preserve formatting
Line 255: Analysis context from CodeHUD core
Line 258: Function signatures in the file
Line 260: Class definitions in the file
Line 272: Function information for transformation context
Line 277: Line number where function starts
Line 279: Line number where function ends
Line 283: Return type annotation if available
Line 287: Whether function is used elsewhere
Line 291: Class information for transformation context
Line 296: Line number where class starts
Line 298: Line number where class ends
Line 304: Number of lines of code
Line 308: Issue information for transformation context
Line 311: Issue type (e.g., "magic_number", "unused_variable")
Line 321: Suggested fix if available
Line 325: Result of a transformation operation - matching Python dataclass exactly
Line 328: Type of transformation that was applied
Line 330: Current status of the transformation
Line 332: List of files that were modified
Line 334: Git commit hash for backup
Line 336: Validation results with details
Line 338: Error message if transformation failed
Line 340: Whether rollback is available for this transformation
Line 344: Backup information for rollback
Line 349: Git commit hash if using Git
Line 351: Backup directory path
Line 353: Timestamp of backup
Line 355: Files included in backup
Line 359: Statistics about transformation execution
Line 362: Total lines processed
Line 370: Number of transformations applied
Line 372: Complexity before transformation
Line 374: Complexity after transformation
Line 378: New issues introduced

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5040 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  13% (2/15) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/lib.rs
Language: rust
Comments found: 26

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Transform - Code Transformation and Refactoring Engine
Line 3: ! This crate provides comprehensive code transformation capabilities, implementing
Line 4: ! all transformation types from the Python codebase with zero degradation.
Line 6: ! Key features:
Line 7: ! - LibCST-equivalent concrete syntax tree transformations
Line 8: ! - Magic number extraction and architectural refactoring
Line 9: ! - Property-based and search-based test generation
Line 10: ! - Git-integrated rollback system
Line 11: ! - Batch transformations with formatting preservation
Line 21: Re-export main types for convenience
Line 27: Result type for transformation operations
Line 30: Error types for transformation operations
Line 33: I/O operation failed
Line 45: Git operation error
Line 49: External tool error
Line 65: CodeHUD core error
Line 73: Tree-sitter language error
Line 77: Tree-sitter query error
Line 81: UTF-8 encoding error

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1602 characters
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (3/15) - engine.rs...🔍 DEBUG PROMPT for engine.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/engine.rs
Language: rust
Comments found: 85

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/engine.rs
Language: rust
Module name: engine

COMMENTS TO ANALYZE:
Line 1: ! Central Transformation Engine
Line 3: ! This module implements the main transformation orchestrator that coordinates
Line 4: ! all transformation types, history tracking, and rollback functionality.
Line 19: Central transformation orchestrator matching Python exactly
Line 21: All available transformers
Line 27: Git integration for backups
Line 33: Configuration for the transformation engine
Line 36: Maximum number of concurrent transformations
Line 38: Whether to create Git backups by default
Line 40: Default timeout for transformations (seconds)
Line 42: Whether to validate transformations after applying
Line 44: Whether to run tests after transformations
Line 46: Directory for storing backups
Line 63: Transformation history tracking
Line 66: All transformation sessions
Line 68: Current session if active
Line 72: A single transformation session
Line 75: Unique session identifier
Line 77: Session start time
Line 79: Session end time
Line 81: Transformations applied in this session
Line 85: Git commit hash for this session
Line 91: Status of a transformation session
Line 94: Session is currently active
Line 96: Session completed successfully
Line 100: Session was rolled back
Line 104: Record of a single transformation
Line 107: Unique transformation identifier
Line 109: Type of transformation
Line 111: Input file path
Line 113: Timestamp of transformation
Line 117: Whether this transformation was rolled back
Line 122: Create a new transformation engine
Line 135: Register all default transformers
Line 141: Register a transformer for a specific type
Line 150: Start a new transformation session
Line 171: Create Git backup if enabled
Line 182: End the current transformation session
Line 198: Analyze codebase and get transformation opportunities
Line 219: Apply a transformation suggestion
Line 225: Ensure we have an active session
Line 230: Get the appropriate transformer
Line 236: Create backup if enabled
Line 253: Add backup commit to result
Line 258: Validate result if enabled
Line 269: Record transformation in history
Line 287: Apply multiple transformation suggestions in batch
Line 299: On error, rollback all successful transformations in this batch
Line 309: Rollback the current session
Line 312: Mark all transformations as rolled back
Line 326: Rollback a specific transformation
Line 328: Find the transformation record
Line 334: Use backup commit to restore
Line 346: Get transformation history
Line 351: Get current session
Line 356: Check if a transformer is available
Line 361: Get list of available transformation types
Line 366: Register all default transformers - matching Python exactly
Line 368: Import and register transformers exactly as Python does
Line 378: Magic Number Extractor -> MAGIC_NUMBERS
Line 384: Architectural Refactorer -> ARCHITECTURAL_REFACTOR
Line 390: Batch Transformer (includes Bowler-based large-scale refactoring) -> BATCH_TRANSFORM
Line 396: Multi-Language Transformer -> MULTI_LANGUAGE
Line 402: Test Generator -> TEST_GENERATION
Line 408: Code Cleanup (unused arguments, imports, etc.) -> CODE_CLEANUP
Line 417: Find transformation record by ID
Line 419: Search in current session
Line 427: Search in completed sessions
Line 438: Validate transformation result
Line 440: Basic validation - check status
Line 456: Run post-transformation tests
Line 458: TODO: Implement test execution
Line 459: This would run relevant tests after transformation to ensure nothing broke
Line 465: Get statistics about transformation history
Line 493: Update transformation type counts
Line 504: Statistics about transformation history

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4282 characters
🤖 Analyzing: [█████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  26% (4/15) - rollback.rs...🔍 DEBUG PROMPT for rollback.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/rollback.rs
Language: rust
Comments found: 78

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/rollback.rs
Language: rust
Module name: rollback

COMMENTS TO ANALYZE:
Line 1: ! Rollback System with Git Integration
Line 3: ! This module provides comprehensive rollback functionality with Git backup
Line 4: ! integration, matching Python's behavior exactly for zero degradation.
Line 15: Rollback system managing backups and restoration
Line 18: Configuration for rollback system
Line 20: Active backups by ID
Line 22: Backup storage directory
Line 26: Configuration for rollback system
Line 29: Maximum number of backups to keep
Line 31: Whether to use Git for backups
Line 33: Backup directory path
Line 35: Whether to compress backups
Line 37: Retention policy in days
Line 53: Entry for a single backup
Line 56: Unique backup identifier
Line 58: Files included in backup
Line 60: Timestamp when backup was created
Line 62: Git commit hash if using Git
Line 64: Backup directory path
Line 66: Description of what was backed up
Line 68: Size of backup in bytes
Line 72: Git backup integration system
Line 75: Git repository path
Line 77: Whether Git is available
Line 83: Configuration for Git backup integration
Line 86: Whether to auto-commit backups
Line 88: Branch prefix for backup branches
Line 90: Whether to create tags for backups
Line 92: Tag prefix for backup tags
Line 108: Create new rollback system
Line 126: Create backup directory if it doesn't exist
Line 138: Create a backup of the specified file
Line 151: Create backup subdirectory
Line 155: Copy file to backup location
Line 163: Calculate file size
Line 166: Create backup entry
Line 179: Create backup info for return
Line 188: Clean old backups if needed
Line 194: Restore from backup
Line 201: Restore each file
Line 214: Create parent directories if needed
Line 226: List all available backups
Line 233: Remove a specific backup
Line 236: Remove backup directory
Line 244: Clean up old backups based on retention policy
Line 249: Find backups to remove
Line 257: Also enforce max backup limit
Line 268: Remove old backups
Line 276: Get backup statistics
Line 300: Create new Git backup integration
Line 312: Create a session backup using Git
Line 318: Create commit for current state
Line 321: Add all changes
Line 349: Get commit hash
Line 364: Create tag if enabled
Line 374: Tag creation failure is not critical
Line 382: Restore to a specific Git commit
Line 388: Reset to specified commit
Line 405: Check if Git is available and repo is initialized
Line 407: Check if git command is available
Line 418: Check if current directory is a git repository
Line 429: Get Git repository status
Line 440: Get current branch
Line 483: Backup system statistics
Line 486: Total number of backups
Line 488: Total size of all backups in bytes
Line 490: Timestamp of oldest backup
Line 492: Timestamp of newest backup
Line 496: Git repository status
Line 499: Whether the repository is clean (no uncommitted changes)
Line 501: Current branch name
Line 503: Number of uncommitted changes
Line 505: Number of untracked files
Line 541: This will return false since temp directory is not a git repo

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3677 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (5/15) - libcst.rs...🔍 DEBUG PROMPT for libcst.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/libcst.rs
Language: rust
Comments found: 64

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/libcst.rs
Language: rust
Module name: libcst

COMMENTS TO ANALYZE:
Line 1: ! LibCST-equivalent Concrete Syntax Tree Implementation
Line 3: ! This module provides concrete syntax tree transformations preserving
Line 4: ! formatting and comments exactly like Python LibCST
Line 11: Language definition for our CST
Line 27: Syntax kinds for our CST
Line 129: Type aliases for our CST
Line 133: CST Node wrapper preserving all metadata
Line 136: Underlying syntax node
Line 138: Original source text
Line 140: Metadata about formatting and comments
Line 144: Metadata preserved with each node
Line 151: Original text range
Line 153: Whether this node was modified
Line 157: Trivia (whitespace, comments, etc.)
Line 171: LibCST-equivalent transformer for concrete syntax trees
Line 173: Parser for the target language
Line 181: Parser that preserves all formatting information
Line 187: Code formatter that preserves original formatting
Line 214: Comment preservation system
Line 220: Create new LibCST transformer
Line 224: Set language based on input
Line 252: Parse source with metadata preservation (matching Python LibCST behavior)
Line 254: Parse with tree-sitter
Line 258: Extract comments and whitespace
Line 261: Build CST with metadata
Line 267: Transform preserving formatting (matching Python LibCST behavior)
Line 273: Apply transformation while preserving metadata
Line 279: Generate code from CST (matching Python LibCST behavior)
Line 286: Extract trivia (comments, whitespace) from source
Line 293: Recursively extract trivia
Line 297: Check if this is a comment or whitespace
Line 324: Associate trivia with nearby nodes
Line 331: Recurse to children
Line 345: Check if node represents trivia
Line 350: Build CST with preserved metadata
Line 354: Convert tree-sitter tree to rowan green tree
Line 375: Convert tree-sitter node to rowan node
Line 385: Leaf node - add as token
Line 389: Internal node - add children
Line 408: Map tree-sitter node kind to our CST kind
Line 447: Generate code recursively
Line 454: Add leading trivia
Line 459: Process node content
Line 463: Recursively process child nodes
Line 473: Add token text
Line 479: Add trailing trivia
Line 488: Trait for CST transformations
Line 490: Visit and potentially modify a CST node
Line 494: Example transformation that preserves formatting
Line 499: Mark as modified but don't change structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2985 characters
📦 Processing batch 2/3 (5 files)...
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (6/15) - test_generation.rs...🔍 DEBUG PROMPT for test_generation.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation.rs
Language: rust
Comments found: 36

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation.rs
Language: rust
Module name: test_generation

COMMENTS TO ANALYZE:
Line 1: ! Test Generation Transformer
Line 3: ! This module implements automatic test generation using property-based testing
Line 4: ! and search-based test generation techniques, matching Python TestGenerator.
Line 16: Configuration for test generation
Line 19: Maximum number of tests to generate per function
Line 21: Whether to generate property-based tests
Line 23: Whether to generate unit tests
Line 25: Test framework to use
Line 40: Generated test information
Line 47: Test type (unit, property, integration)
Line 49: Function being tested
Line 51: Test file path
Line 55: Test generation transformer matching Python TestGenerator
Line 63: Create new test generation transformer
Line 70: Create with custom configuration
Line 75: Detect functions that need tests
Line 108: Generate test for a specific function
Line 140: Detect language from file path
Line 154: Analyze code and suggest test generation opportunities
Line 161: Look for functions that lack test coverage
Line 169: Skip test files
Line 185: Create suggestion if we found functions needing tests
Line 211: Apply test generation transformation
Line 220: Generate tests for each affected file
Line 231: Create tests directory if it doesn't exist
Line 236: Write test file
Line 248: New test files created
Line 261: Validate test generation transformation
Line 265: Validate transformation status
Line 269: Check if test files were created and are accessible
Line 280: Try to read the test file
Line 291: Overall validation success

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3409 characters
🤖 Analyzing: [███████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░]  46% (7/15) - multi_language.rs...🔍 DEBUG PROMPT for multi_language.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs
Language: rust
Comments found: 40

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs
Language: rust
Module name: multi_language

COMMENTS TO ANALYZE:
Line 1: ! Multi-Language Transformer
Line 3: ! This module implements cross-language transformations using Comby-style
Line 4: ! pattern matching and replacement, enabling transformations across different
Line 5: ! programming languages with consistent patterns.
Line 18: Multi-language transformation pattern
Line 23: Comby-style pattern string
Line 25: Example before transformation
Line 27: Example after transformation
Line 29: Languages this pattern supports
Line 31: Confidence in this pattern (0.0 to 1.0)
Line 35: Configuration for multi-language transformations
Line 38: Whether to preserve formatting
Line 40: Maximum number of replacements per file
Line 42: Whether to apply language-specific rules
Line 56: Multi-language transformer for cross-language transformations
Line 66: Create new multi-language transformer
Line 74: Create with custom patterns
Line 82: Create default transformation patterns
Line 104: Detect language from source code and file path
Line 107: Detect by file extension
Line 119: Detect by code patterns
Line 131: Apply a language-specific pattern to source code
Line 135: Simple TODO enhancement
Line 140: Basic naming convention adjustments - would be more sophisticated in real implementation
Line 141: No change for now
Line 150: Analyze code for multi-language transformation opportunities
Line 157: Look for cross-language patterns and opportunities
Line 168: Look for cross-language transformation opportunities
Line 173: Look for naming convention patterns
Line 181: Create suggestions for patterns found across languages
Line 183: Only suggest if found in multiple files
Line 209: Apply multi-language transformation
Line 221: Apply transformation to affected files
Line 251: Validate multi-language transformation
Line 255: Validate transformation status
Line 259: Validate files were actually modified
Line 280: Overall validation success

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3788 characters
🤖 Analyzing: [██████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░]  53% (8/15) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/mod.rs
Language: rust
Comments found: 19

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Transformer implementations
Line 3: ! This module contains all transformer implementations matching Python behavior
Line 20: Re-export all transformers - matching Python exactly
Line 28: Base transformer trait - matching Python BaseTransformer ABC exactly
Line 29: Only abstract methods are required; concrete methods are provided as default implementations
Line 32: Analyze code and suggest transformation opportunities
Line 33: Matches Python: analyze_transformation_opportunities(self, analysis_result: AnalysisResult) -> list[TransformationSuggestion]
Line 39: Apply a specific transformation
Line 40: Matches Python: apply_transformation(self, suggestion: TransformationSuggestion, codebase_path: Path) -> TransformationResult
Line 47: Validate that transformation was successful
Line 48: Matches Python: validate_transformation(self, result: TransformationResult, codebase_path: Path) -> dict[str, Any]
Line 55: Concrete methods with default implementations (matching Python BaseTransformer)
Line 57: Create a git commit backup before transformation
Line 58: Matches Python: create_backup(self, codebase_path: Path) -> Optional[str]
Line 60: Default implementation - delegates to GitBackupIntegration
Line 67: Create backup using session ID similar to Python
Line 75: Rollback transformation using git
Line 76: Matches Python: rollback_transformation(self, backup_commit: str, codebase_path: Path) -> bool
Line 82: Default implementation - delegates to GitBackupIntegration

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3360 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  60% (9/15) - magic_numbers.rs...🔍 DEBUG PROMPT for magic_numbers.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/magic_numbers.rs
Language: rust
Comments found: 114

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/magic_numbers.rs
Language: rust
Module name: magic_numbers

COMMENTS TO ANALYZE:
Line 1: ! Magic Number Transformer
Line 3: ! Extracts magic numbers to named constants, matching Python behavior exactly
Line 18: Represents the context around a magic number for intelligent extraction
Line 19: Matches Python MagicNumberContext exactly
Line 22: The numeric value found
Line 24: Line number where found (1-based)
Line 26: Column number where found (1-based)
Line 28: Surrounding code context
Line 30: AI-suggested constant name
Line 32: Suggested grouping class for organization
Line 34: Confidence in the suggestion (0.0 to 1.0)
Line 39: Create new context for a magic number
Line 52: Analyze surrounding code to determine appropriate constant name
Line 53: Matches Python analyze_context method exactly
Line 57: God Class pattern detection
Line 61: Health score pattern detection
Line 65: Complexity pattern detection
Line 69: HTTP status code detection
Line 73: Threshold pattern detection
Line 77: Configuration pattern detection
Line 81: Default pattern analysis
Line 87: Analyze God Class specific patterns
Line 100: Analyze health score patterns
Line 113: Analyze complexity patterns
Line 126: Analyze HTTP status codes
Line 148: Analyze threshold patterns
Line 161: Analyze configuration patterns
Line 168: Generic context analysis fallback
Line 170: Generate a reasonable constant name based on the number
Line 181: Magic number transformer - extracts magic numbers to constants
Line 183: CST transformer for preserving formatting
Line 185: Configuration for magic number detection
Line 189: Configuration for magic number detection
Line 192: Numbers to ignore (common constants)
Line 194: Minimum value to consider as magic number
Line 196: Maximum value to consider as magic number
Line 198: Whether to extract floating point numbers
Line 200: Whether to extract numbers in strings
Line 202: Prefix for generated constant names
Line 204: Where to place constants (top of file, separate constants file)
Line 208: Strategy for placing extracted constants
Line 211: At the top of the same file
Line 213: In a separate constants file
Line 215: Near first usage
Line 222: Common numbers that are usually not magic
Line 239: Information about a detected magic number
Line 242: The numeric value
Line 244: Line number where it appears
Line 248: Context around the number
Line 250: Suggested constant name
Line 252: How many times this number appears
Line 257: Create new magic number transformer
Line 265: Create with custom configuration
Line 273: Find all magic numbers in the source code
Line 278: Regex patterns for different number types
Line 289: Find integer literals
Line 299: Find float literals if enabled
Line 311: Find hex literals
Line 319: Find binary literals
Line 327: Process numbers found in this line
Line 340: Will be updated later
Line 345: Update usage counts
Line 353: Check if a number should be extracted as a magic number
Line 355: Skip ignored numbers
Line 360: Parse the number to check range
Line 380: Generate a constant name for a magic number
Line 382: Try to infer meaning from context
Line 415: Extract context around a magic number
Line 421: Clean up the context
Line 425: Generate the replacement code with constants
Line 433: Generate constants section
Line 438: Add constants at the top after imports
Line 442: Find end of import statements
Line 470: Add rest of the code with replacements
Line 481: Just replace magic numbers with constant references
Line 490: Place constants near their first usage
Line 495: Check if any magic numbers appear in this line for the first time
Line 499: Add constant definition before this line
Line 506: Add the line with replacements
Line 517: Generate constants section
Line 524: Group by value to avoid duplicates
Line 541: Replace magic numbers in a single line with constant references
Line 545: Sort by column position (descending) to avoid position shifts
Line 548: Check if this magic number appears in this line
Line 555: Group by value to get the suggested name
Line 561: Replace each unique value
Line 563: Use word boundaries to avoid partial replacements
Line 573: Extract magic numbers from analysis result
Line 577: For now, create a simple implementation
Line 578: In a real implementation, this would parse the analysis result
Line 579: and extract actual magic numbers from the code
Line 581: This is a placeholder that would be replaced with actual analysis
Line 594: Apply magic number extraction to source code
Line 596: Simple regex-based replacement for now
Line 597: In a real implementation, this would use LibCST for precise transformation
Line 613: Analyze code and suggest magic number extraction opportunities
Line 620: Extract magic numbers from analysis result
Line 650: Apply magic number extraction transformation
Line 656: Read the source file
Line 659: Extract transformation parameters from metadata
Line 667: Apply the transformation
Line 670: Write transformed code back
Line 677: Will be set by engine
Line 684: Validate that transformation was successful
Line 685: Returns detailed validation results as dict[str, Any] matching Python
Line 696: Basic validation - check if transformation completed successfully
Line 705: Validate files were actually modified if claimed
Line 743: Should find: 100, 50, 0.15, 0.05, 25
Line 744: Should NOT find: 1 (ignored)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 7189 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (10/15) - unused_args.rs...🔍 DEBUG PROMPT for unused_args.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args.rs
Language: rust
Comments found: 42

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args.rs
Language: rust
Module name: unused_args

COMMENTS TO ANALYZE:
Line 1: ! Unused Argument Remover Transformer
Line 3: ! This module implements dead code elimination, focusing on unused function
Line 4: ! arguments, imports, and variables, matching Python UnusedArgumentRemover.
Line 16: Configuration for unused code removal
Line 19: Remove unused function arguments
Line 21: Remove unused imports
Line 23: Remove unused variables
Line 25: Preserve public API elements
Line 40: Information about detected unused code
Line 43: Name of the unused item
Line 45: Type of unused item (argument, import, variable)
Line 47: Line number where it appears
Line 49: Function/scope containing the item
Line 53: Unused argument remover transformer matching Python UnusedArgumentRemover
Line 61: Create new unused argument remover
Line 68: Create with custom configuration
Line 73: Detect unused arguments in source code
Line 90: Find unused arguments in Python code
Line 96: Extract function definition
Line 105: Check if arguments are used in function body
Line 124: Find unused arguments in Rust code
Line 130: Extract function definition
Line 139: Check if arguments are used in function body
Line 158: Check if an argument is used in the function body
Line 171: End of function
Line 175: Simple check if argument name appears in line
Line 184: Remove unused arguments from source code
Line 188: Simple removal - in real implementation would use proper AST manipulation
Line 191: Simple pattern-based removal (would be more sophisticated in real implementation)
Line 203: Detect language from file path
Line 217: Analyze code and suggest unused code removal opportunities
Line 224: Look for unused code elements
Line 243: Create suggestion if we found unused code
Line 269: Apply unused code removal transformation
Line 277: Remove unused code from each affected file
Line 313: Validate unused code removal transformation
Line 317: Validate transformation status
Line 321: Basic validation - check that modified files are syntactically valid
Line 333: Try to read the modified file
Line 350: Overall validation success

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3939 characters
📦 Processing batch 3/3 (5 files)...
🤖 Analyzing: [████████████████████████████████████░░░░░░░░░░░░░░]  73% (11/15) - multi_language_old.rs...🔍 DEBUG PROMPT for multi_language_old.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th
- test_generation.rs: This file, test_generation.rs, implements a transformer for automatic test generation using property-based testing and search-based techniques, similar to the Python TestGenerator. The transformer is 
- multi_language.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs implements a multi-language code transformation system. It allows for cross-language transf
- mod.rs: This file implements a set of transformers in Rust, which are used for code transformation and refactoring tasks. The transformers match the behavior of Python's transformations closely, offering adva
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a Rust code transformer specifically designed for extracting magic numbers (hardcoded numeric values) into named constants in the source code. It is designed 
- unused_args.rs: This file, unused_args.rs in the /transformers directory of CodeHUD Transform Rust project, is designed for identifying and removing unused code elements from a given source code base. It focuses on f

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language_old.rs
Language: rust
Comments found: 120

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language_old.rs
Language: rust
Module name: multi_language_old

COMMENTS TO ANALYZE:
Line 1: ! Multi-Language Transformer
Line 3: ! This module implements cross-language transformations using Comby-style
Line 4: ! pattern matching and replacement, enabling transformations across different
Line 5: ! programming languages with consistent patterns.
Line 19: Multi-language transformer using Comby-style patterns
Line 21: Configuration for multi-language transformations
Line 23: Pattern library for different languages
Line 25: Language detection engine
Line 29: Configuration for multi-language transformations
Line 32: Whether to use external Comby tool
Line 34: Path to Comby executable
Line 36: Maximum file size to process
Line 38: Whether to validate syntax after transformation
Line 40: Whether to preserve formatting
Line 69: Default to internal implementation
Line 84: Line ending style
Line 86: Maximum line length
Line 88: Whether to preserve comments
Line 90: Command to check syntax
Line 97: Spaces with specified count
Line 103: Line ending style
Line 106: Unix style (\n)
Line 108: Windows style (\r\n)
Line 110: Mac style (\r)
Line 114: Pattern library for cross-language transformations
Line 117: Patterns organized by category
Line 121: Cross-language transformation pattern
Line 126: Description of what this pattern does
Line 128: Languages this pattern applies to
Line 130: Source pattern to match
Line 134: Pattern type (structural, syntactic, semantic)
Line 136: Examples of transformations
Line 138: Constraints for when pattern should apply
Line 142: Type of transformation pattern
Line 145: Structural code patterns (loops, conditionals)
Line 147: Syntactic patterns (naming, formatting)
Line 149: Semantic patterns (logic, algorithms)
Line 151: Cross-language migration patterns
Line 155: Example of pattern transformation
Line 158: Example input code
Line 160: Expected output code
Line 162: Language for this example
Line 166: Constraint for pattern application
Line 169: Only apply in specific contexts
Line 171: Only apply if certain conditions are met
Line 173: Only apply to specific language versions
Line 175: Only apply if dependencies are present
Line 179: Language detection engine
Line 182: File extension mappings
Line 184: Content-based detection patterns
Line 188: Result of applying a pattern
Line 191: Whether pattern was applied successfully
Line 193: Number of matches found
Line 195: Number of replacements made
Line 206: Create new multi-language transformer
Line 215: Create with custom configuration
Line 224: Apply cross-language transformation
Line 232: Find appropriate pattern
Line 243: Apply a specific pattern to code
Line 257: Apply pattern using external Comby tool
Line 266: Create temporary files for input and pattern
Line 283: Clean up temporary files
Line 312: Apply pattern using internal implementation
Line 319: Convert Comby-style pattern to regex
Line 332: Process replacement pattern with captured groups
Line 335: Replace captured variables (:[var] -> $var)
Line 347: Validate result if configured
Line 364: Convert Comby-style pattern to regex
Line 368: Replace Comby holes with regex groups
Line 369: :[var] -> (.+?) for any identifier
Line 370: :[var:e] -> (.+?) for expressions
Line 371: :[var:s] -> (.+?) for statements
Line 375: Escape special regex characters except our groups
Line 382: Count pattern matches in source code
Line 389: Validate syntax of transformed code
Line 393: Create temporary file
Line 397: Run syntax checker
Line 421: Detect language of source code
Line 426: List available patterns
Line 431: Add custom pattern
Line 438: Create new pattern library with default patterns
Line 448: Load default transformation patterns
Line 450: Add common cross-language patterns
Line 491: Add a pattern to the library
Line 505: Find pattern by name and languages
Line 519: List all patterns
Line 528: Create new language detector
Line 550: Detect language from source code and file path
Line 552: Try file extension first
Line 563: Fall back to content-based detection
Line 576: Analyze code for multi-language transformation opportunities
Line 581: Detect source language if not specified
Line 588: Get transformation parameters
Line 599: Apply default transformations for the language
Line 602: Apply specific pattern
Line 643: Will be set by engine
Line 657: 0.02 seconds per line
Line 663: Cross-language transformations have moderate risk
Line 665: Estimate 20% of lines affected
Line 666: Cross-language changes should be reviewed
Line 672: Apply default transformations for a language
Line 674: Find applicable patterns for this language
Line 692: Apply first applicable pattern as default

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 7608 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (12/15) - batch.rs...🔍 DEBUG PROMPT for batch.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th
- test_generation.rs: This file, test_generation.rs, implements a transformer for automatic test generation using property-based testing and search-based techniques, similar to the Python TestGenerator. The transformer is 
- multi_language.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs implements a multi-language code transformation system. It allows for cross-language transf
- mod.rs: This file implements a set of transformers in Rust, which are used for code transformation and refactoring tasks. The transformers match the behavior of Python's transformations closely, offering adva
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a Rust code transformer specifically designed for extracting magic numbers (hardcoded numeric values) into named constants in the source code. It is designed 
- unused_args.rs: This file, unused_args.rs in the /transformers directory of CodeHUD Transform Rust project, is designed for identifying and removing unused code elements from a given source code base. It focuses on f

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/batch.rs
Language: rust
Comments found: 131

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/batch.rs
Language: rust
Module name: batch

COMMENTS TO ANALYZE:
Line 1: ! Batch Transformer
Line 3: ! This module implements batch transformation capabilities for processing
Line 4: ! multiple files with consistent formatting and style preservation.
Line 17: Batch transformer for processing multiple files
Line 19: Configuration for batch processing
Line 21: Statistics from batch operations
Line 25: Configuration for batch transformations
Line 28: Maximum number of files to process concurrently
Line 30: Whether to stop on first error
Line 32: Whether to create backup of all files before processing
Line 34: Whether to validate all files after transformation
Line 36: Maximum file size to process (in bytes)
Line 38: File patterns to include
Line 40: File patterns to exclude
Line 42: Whether to preserve directory structure
Line 61: Statistics for batch operations
Line 64: Total files processed
Line 66: Files successfully transformed
Line 68: Files that failed transformation
Line 70: Files skipped due to filters
Line 72: Total processing time in milliseconds
Line 74: Average time per file in milliseconds
Line 76: Total lines processed
Line 78: Total lines modified
Line 86: Batch processing error
Line 89: File path where error occurred
Line 95: Line number if applicable
Line 99: Batch operation specification
Line 102: Files to process
Line 104: Transformations to apply
Line 106: Configuration for this batch
Line 110: File in a batch operation
Line 113: Path to the file
Line 115: Language of the file (detected or specified)
Line 117: File size in bytes
Line 119: Last modified timestamp
Line 121: Whether this file should be processed
Line 123: Reason for skipping if not processed
Line 127: Transformation to apply in batch
Line 130: Type of transformation
Line 132: Parameters for this transformation
Line 134: Whether this transformation should be applied to all files
Line 136: File patterns this transformation applies to
Line 140: Result of batch processing
Line 143: Overall success status
Line 145: Results for individual files
Line 149: Files that were created during batch processing
Line 151: Files that were modified
Line 157: Backup information for batch operations
Line 164: Files included in backup
Line 166: Timestamp of backup
Line 171: Create new batch transformer
Line 179: Create with custom configuration
Line 187: Process a batch of files (DEPRECATED - not part of Python-matching interface)
Line 197: Create backup if configured
Line 220: Update overall statistics
Line 224: Track created and modified files
Line 246: Calculate timing statistics
Line 267: Process a single file with specified transformations (DEPRECATED)
Line 274: Read file content
Line 277: Create transform input
Line 286: Apply each transformation sequentially
Line 311: Check if transformation applies to this file
Line 316: Apply transformation parameters
Line 319: Get appropriate transformer and apply
Line 335: Merge file lists
Line 347: Write transformed content back to file if not dry run
Line 358: Check if transformation applies to a file
Line 364: Check file patterns
Line 374: Check if file path matches a pattern
Line 376: Simplified pattern matching - in a real implementation would use glob crate
Line 387: Apply a transformation to input (DEPRECATED)
Line 394: This would delegate to the appropriate transformer based on transformation type
Line 395: For now, return a placeholder result
Line 412: Create backup for batch operation
Line 418: Create backup directory
Line 430: Create parent directories if needed
Line 435: Copy file to backup location
Line 449: Scan directory for files to process
Line 462: Recursively scan directory
Line 479: Analyze a file to determine if it should be processed
Line 485: Detect language from file extension
Line 488: Check if file should be processed
Line 501: Detect programming language from file extension
Line 521: Check if file should be processed
Line 523: Check file size
Line 528: Check language support
Line 533: Check include patterns
Line 541: Check exclude patterns
Line 551: Get processing statistics
Line 561: Apply a specific pattern transformation to source code
Line 563: Simple pattern-based transformations
Line 564: In a real implementation, this would use more sophisticated AST manipulation
Line 567: Example: improve format! usage consistency
Line 572: Example: organize use statements (very basic)
Line 573: No change for now - would need proper parsing
Line 576: Example: suggest alternatives to unwrap() (very basic)
Line 581: Unknown pattern - return unchanged
Line 590: Analyze code and suggest batch transformation opportunities
Line 597: Look for patterns that could benefit from large-scale batch transformations
Line 598: This matches the Python BatchTransformer which looks for deprecated patterns
Line 603: Count patterns across all files
Line 609: Look for deprecated string formatting patterns (like Python %)
Line 614: Look for import reorganization opportunities
Line 619: Look for code consistency patterns
Line 627: Create suggestions for patterns found in multiple files (batch-worthy)
Line 629: Only suggest if found in multiple files
Line 666: Apply batch transformation
Line 678: Apply the batch transformation pattern to all affected files
Line 684: Only write if the code actually changed
Line 697: Will be set by engine if backup is created
Line 710: Validate batch transformation results
Line 711: Returns detailed validation results as dict[str, Any] matching Python
Line 722: Basic validation - check if transformation completed successfully
Line 727: Validate that all modified files exist and are accessible
Line 739: Try to read the file to ensure it's accessible
Line 753: Additional validation: check that batch operation didn't introduce syntax errors
Line 754: This could be enhanced with language-specific parsing
Line 766: Don't clone statistics

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8779 characters
🤖 Analyzing: [███████████████████████████████████████████░░░░░░░]  86% (13/15) - test_generation_old.rs...🔍 DEBUG PROMPT for test_generation_old.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th
- test_generation.rs: This file, test_generation.rs, implements a transformer for automatic test generation using property-based testing and search-based techniques, similar to the Python TestGenerator. The transformer is 
- multi_language.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs implements a multi-language code transformation system. It allows for cross-language transf
- mod.rs: This file implements a set of transformers in Rust, which are used for code transformation and refactoring tasks. The transformers match the behavior of Python's transformations closely, offering adva
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a Rust code transformer specifically designed for extracting magic numbers (hardcoded numeric values) into named constants in the source code. It is designed 
- unused_args.rs: This file, unused_args.rs in the /transformers directory of CodeHUD Transform Rust project, is designed for identifying and removing unused code elements from a given source code base. It focuses on f

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation_old.rs
Language: rust
Comments found: 171

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/test_generation_old.rs
Language: rust
Module name: test_generation_old

COMMENTS TO ANALYZE:
Line 1: ! Test Generation Transformer
Line 3: ! This module implements automated test generation using property-based testing
Line 4: ! and search-based techniques, matching Python's Hypothesis and similar tools.
Line 17: Test generation transformer
Line 19: Parser for syntax analysis
Line 21: Configuration for test generation
Line 23: Test generators for different languages
Line 27: Configuration for test generation
Line 30: Type of tests to generate
Line 32: Whether to use property-based testing
Line 34: Whether to use mutation testing
Line 36: Maximum number of test cases per function
Line 38: Whether to generate edge case tests
Line 40: Whether to generate performance tests
Line 42: Test framework to target
Line 63: Types of tests to generate
Line 80: Test generator trait
Line 82: Generate tests for a function
Line 85: Generate tests for a class
Line 88: Generate property-based tests
Line 92: Information about a function for test generation
Line 99: Parameter types and names
Line 103: Function body (for analysis)
Line 107: Line numbers (start, end)
Line 115: Information about a class for test generation
Line 122: Methods in the class
Line 141: Whether parameter is optional
Line 143: Constraints on parameter values
Line 156: Whether attribute is public
Line 160: Constraints on parameter values
Line 163: Range constraint for numbers
Line 165: Length constraint for strings/collections
Line 169: Regex pattern for strings
Line 175: Detected function patterns
Line 178: Pure function (no side effects)
Line 180: Function with side effects
Line 182: Function that throws exceptions
Line 184: Function with loops
Line 186: Function with conditionals
Line 190: Function with I/O operations
Line 194: Generated test case
Line 207: Setup code (if needed)
Line 209: Teardown code (if needed)
Line 222: Actual value expression
Line 228: Types of assertions
Line 241: Not None assertion
Line 255: Test data for parameterized tests
Line 264: Test case description
Line 268: Python test generator
Line 270: Hypothesis strategy mappings
Line 274: JavaScript test generator
Line 276: Test framework specific settings
Line 281: Create new test generation transformer
Line 297: Generate tests for source code
Line 299: Parse source code
Line 303: Extract functions and classes
Line 307: Get appropriate generator
Line 315: Generate tests for functions
Line 320: Generate property-based tests if enabled
Line 327: Generate tests for classes
Line 336: Extract function information from syntax tree
Line 343: Recursively extract functions
Line 363: Extract class information from syntax tree
Line 370: Recursively extract classes
Line 390: Analyze function node
Line 395: Extract function name
Line 398: Extract function signature
Line 404: Extract return type (if available)
Line 407: Extract function body
Line 432: Analyze class node
Line 451: Extract function name
Line 467: Extract class name
Line 469: Similar to extract_function_name but for classes
Line 473: Extract function parameters
Line 493: Extract parameters from parameters node
Line 502: Would need type annotation analysis
Line 503: Would need default value analysis
Line 516: Extract return type
Line 518: Simplified - would need full type annotation parsing
Line 522: Extract function body
Line 540: Simplified - would need docstring extraction
Line 544: Calculate function complexity
Line 551: Count complexity contributing nodes
Line 574: Detect function patterns
Line 580: Check for various patterns
Line 602: Extract base classes
Line 608: Extract class methods
Line 615: Extract class attributes
Line 645: Generate basic unit test
Line 663: Generate edge case tests if enabled
Line 669: Limit number of tests
Line 678: Generate constructor test
Line 692: Generate tests for each method
Line 726: Generate test parameters
Line 761: Generate hypothesis decorators
Line 777: Generate property assertion
Line 849: JavaScript property-based testing would use libraries like fast-check
Line 860: Set parser for input language
Line 871: Generate test file content
Line 874: Determine test file name
Line 891: Original file unchanged
Line 907: Test generation always creates files
Line 916: 0.5 seconds per line, minimum 2 seconds
Line 922: Test generation is safe
Line 924: Original file not modified
Line 925: Generated tests should be reviewed
Line 931: Generate test file content from tests
Line 963: Generate test file name
Line 995: Would need actual test with tree-sitter parsing

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 7474 characters
🤖 Analyzing: [██████████████████████████████████████████████░░░░]  93% (14/15) - unused_args_old.rs...🔍 DEBUG PROMPT for unused_args_old.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th
- test_generation.rs: This file, test_generation.rs, implements a transformer for automatic test generation using property-based testing and search-based techniques, similar to the Python TestGenerator. The transformer is 
- multi_language.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs implements a multi-language code transformation system. It allows for cross-language transf
- mod.rs: This file implements a set of transformers in Rust, which are used for code transformation and refactoring tasks. The transformers match the behavior of Python's transformations closely, offering adva
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a Rust code transformer specifically designed for extracting magic numbers (hardcoded numeric values) into named constants in the source code. It is designed 
- unused_args.rs: This file, unused_args.rs in the /transformers directory of CodeHUD Transform Rust project, is designed for identifying and removing unused code elements from a given source code base. It focuses on f

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args_old.rs
Language: rust
Comments found: 183

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/unused_args_old.rs
Language: rust
Module name: unused_args_old

COMMENTS TO ANALYZE:
Line 1: ! Unused Argument Removal Transformer
Line 3: ! This module implements dead code elimination focusing on unused function
Line 4: ! arguments, variables, and imports, matching Python's capabilities exactly.
Line 16: Unused argument removal transformer
Line 18: Parser for syntax analysis
Line 20: Configuration for dead code removal
Line 26: Configuration for dead code elimination
Line 29: Whether to remove unused function arguments
Line 31: Whether to remove unused local variables
Line 33: Whether to remove unused imports
Line 35: Whether to remove unused class attributes
Line 37: Whether to remove unreachable code
Line 39: Patterns to ignore (e.g., "self", "_*")
Line 41: Whether to be conservative (keep potentially used items)
Line 43: Minimum confidence threshold for removal
Line 67: Analysis of code usage patterns
Line 70: Functions and their argument usage
Line 72: Variables and their usage
Line 74: Imports and their usage
Line 76: Class attributes and their usage
Line 78: Unreachable code blocks
Line 82: Function usage information
Line 89: Parameter usage information
Line 91: Whether function is called externally
Line 99: Parameter usage information
Line 104: Whether parameter is used in function body
Line 108: Confidence in usage analysis
Line 110: Whether parameter might be used dynamically
Line 114: Variable usage information
Line 119: Where variable is defined
Line 121: Where variable is used
Line 125: Whether variable is assigned but never read
Line 127: Confidence in usage analysis
Line 131: Import usage information
Line 138: Usage sites for each name
Line 142: Whether import is used
Line 146: Attribute usage information
Line 157: Whether attribute is accessed externally
Line 161: Call site information
Line 164: Location of call
Line 166: Arguments passed to call
Line 168: Whether call uses all parameters
Line 175: Line number (1-based)
Line 177: Column number (1-based)
Line 179: Length of the element
Line 183: Code block information
Line 192: Reason why block is unreachable
Line 201: Parameter type (if available)
Line 203: Default value (if any)
Line 205: Whether parameter is variadic (*args, **kwargs)
Line 227: If statement block
Line 243: Transformation result for dead code removal
Line 246: Modified source code
Line 248: Removed unused arguments
Line 250: Removed unused variables
Line 252: Removed unused imports
Line 254: Removed unreachable code
Line 256: Warnings about potentially incorrect removals
Line 260: Information about a removed item
Line 267: Location where item was removed
Line 269: Confidence in removal decision
Line 273: Type of removed item
Line 284: Unreachable code block
Line 289: Create new unused argument remover
Line 301: Create with custom configuration
Line 308: Analyze code for unused elements
Line 310: Check cache first
Line 315: Parse source code
Line 327: Analyze different types of usage
Line 340: Remove dead code based on analysis
Line 351: Remove unused imports first (affects other removals)
Line 356: Remove unused function arguments
Line 361: Remove unused variables
Line 366: Remove unreachable code
Line 374: Analyze function usage
Line 380: Recursively analyze functions
Line 400: Analyze a single function node
Line 410: Analyze parameter usage within function body
Line 417: Find call sites (simplified - would need full cross-reference analysis)
Line 431: Extract function name
Line 447: Extract function parameters
Line 467: Extract parameters from parameters node
Line 475: Skip if matches ignore patterns
Line 479: Would need type annotation analysis
Line 480: Would need default value analysis
Line 481: Would need variadic detection
Line 493: Check if parameter should be ignored
Line 503: Analyze parameter usage within function
Line 508: Find all identifier nodes in function body that match parameter name
Line 511: High confidence in static analysis
Line 518: Would need more sophisticated analysis
Line 522: Find identifier usage in node
Line 536: Recursively search children
Line 550: Find function call sites
Line 554: Simple regex-based search for function calls
Line 566: Would need proper argument parsing
Line 567: Would need argument analysis
Line 575: Analyze variable usage
Line 577: Simplified implementation - would need comprehensive variable analysis
Line 581: Analyze import usage
Line 587: Recursively analyze imports
Line 609: Analyze import node
Line 619: Check if imports are used (simplified)
Line 638: Extract imported names from import node
Line 658: Find import usage sites
Line 662: Simple regex-based search
Line 676: Remove the import statement itself
Line 678: Simple heuristic: if it's on a line starting with import, it's the import statement
Line 689: Analyze attribute usage
Line 691: Simplified implementation - would need comprehensive attribute analysis
Line 695: Analyze unreachable code
Line 697: Simplified implementation - would need control flow analysis
Line 701: Remove unused imports
Line 707: Remove the import line
Line 719: Remove empty lines and rebuild
Line 728: Remove unused function arguments
Line 733: Remove parameter from function signature
Line 753: Remove unused variables
Line 757: Remove variable assignment
Line 776: Remove unreachable code
Line 779: Remove unreachable code block
Line 793: Remove parameter from function signature
Line 795: Simplified implementation using regex
Line 799: This is a simplified implementation - a real implementation would need proper AST manipulation
Line 803: Remove variable assignment
Line 809: Remove code block
Line 821: Set parser for input language
Line 833: Count potentially removable items
Line 844: For dry run, just report what would be removed
Line 851: Apply dead code removal
Line 889: Will be set by engine
Line 903: 0.1 seconds per line
Line 905: Count potential functions to analyze
Line 913: Dead code removal has moderate risk
Line 915: Estimate 10% of lines affected
Line 916: Should review what was removed

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8943 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (15/15) - architectural.rs...🔍 DEBUG PROMPT for architectural.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This file provides a comprehensive set of data types and classes for transformations in code, with an emphasis on matching the Python implementation's capabilities exactly. It defines various transfor
- lib.rs: This Rust library, CodeHUD Transform, is a comprehensive code transformation and refactoring tool that provides advanced capabilities for transforming codebase with Python-like transformations. It sup
- engine.rs: This file provides a comprehensive transformation engine, serving as the central hub for all transformations including history tracking, rollback capabilities, and integration with Git for backups. It
- rollback.rs: This Rust file is a rollback system with Git integration, designed for managing backups and restoring data from previous states. It provides comprehensive rollback functionalities including the abilit
- libcst.rs: This Rust file, libcst, provides a comprehensive implementation of the Concrete Syntax Tree (CST) in Rust, similar to Python LibCST. It is designed for preserving formatting and comments exactly as th
- test_generation.rs: This file, test_generation.rs, implements a transformer for automatic test generation using property-based testing and search-based techniques, similar to the Python TestGenerator. The transformer is 
- multi_language.rs: The file /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/multi_language.rs implements a multi-language code transformation system. It allows for cross-language transf
- mod.rs: This file implements a set of transformers in Rust, which are used for code transformation and refactoring tasks. The transformers match the behavior of Python's transformations closely, offering adva
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a Rust code transformer specifically designed for extracting magic numbers (hardcoded numeric values) into named constants in the source code. It is designed 
- unused_args.rs: This file, unused_args.rs in the /transformers directory of CodeHUD Transform Rust project, is designed for identifying and removing unused code elements from a given source code base. It focuses on f

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/architectural.rs
Language: rust
Comments found: 155

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform/src/transformers/architectural.rs
Language: rust
Module name: architectural

COMMENTS TO ANALYZE:
Line 1: ! Architectural Refactoring Transformer
Line 3: ! This module implements large-scale architectural transformations including:
Line 4: ! - Class hierarchy restructuring
Line 5: ! - Design pattern implementation
Line 6: ! - Module organization improvements
Line 7: ! - Dependency injection patterns
Line 21: Architectural refactoring transformer
Line 23: Parser for syntax analysis
Line 25: Language being processed
Line 27: Refactoring patterns to apply
Line 29: Configuration for architectural changes
Line 33: Configuration for architectural refactoring
Line 36: Maximum class size before splitting
Line 38: Maximum function complexity before refactoring
Line 40: Whether to apply design patterns
Line 42: Whether to extract interfaces
Line 44: Whether to apply dependency injection
Line 46: Whether to restructure inheritance hierarchies
Line 63: Refactoring pattern definition
Line 70: Conditions that trigger this pattern
Line 72: Transformations to apply
Line 74: Risk level of applying this pattern
Line 78: Condition for pattern application
Line 81: Class has too many methods
Line 83: Function is too complex
Line 85: Duplicate code detected
Line 87: Poor cohesion detected
Line 89: Tight coupling detected
Line 91: God class anti-pattern
Line 95: Transformation to apply for a pattern
Line 98: Extract method from large function
Line 100: Split large class into multiple classes
Line 102: Extract interface from class
Line 104: Apply strategy pattern
Line 106: Apply factory pattern
Line 108: Apply dependency injection
Line 112: Strategy for splitting classes
Line 115: Split by functionality
Line 117: Split by data cohesion
Line 119: Split by method groups
Line 123: Analysis result for architectural assessment
Line 126: Classes found in the code
Line 128: Functions found in the code
Line 130: Detected architectural issues
Line 132: Suggested refactoring patterns
Line 134: Overall architectural health score
Line 138: Analysis of a single class
Line 143: Line numbers (start, end)
Line 145: Number of methods
Line 147: Number of attributes
Line 149: Lines of code
Line 151: Cohesion score (0.0 to 1.0)
Line 153: Coupling score (0.0 to 1.0)
Line 159: Analysis of a single function
Line 164: Line numbers (start, end)
Line 166: Number of parameters
Line 168: Lines of code
Line 174: Whether function has side effects
Line 178: Architectural issue detected
Line 185: Description of the issue
Line 187: Location in code
Line 194: Create new architectural refactorer
Line 198: Default to Python - will be set based on input
Line 210: Detect language from file extension
Line 221: Create default refactoring patterns
Line 285: Analyze architectural structure
Line 287: Parse the source code
Line 299: Analyze classes and functions
Line 302: Calculate health score
Line 305: Suggest refactoring patterns
Line 311: Analyze a syntax tree node recursively
Line 325: Recursively analyze child nodes
Line 339: Analyze a class definition
Line 345: Extract class name
Line 348: Count methods and attributes
Line 351: Calculate cohesion and coupling (simplified metrics)
Line 368: Analyze a function definition
Line 374: Extract function name
Line 380: Calculate complexity metrics
Line 396: Extract class name from node
Line 413: Extract function name from node
Line 430: Count class members (methods and attributes)
Line 452: Count function parameters
Line 468: Calculate class cohesion (simplified LCOM metric)
Line 470: Simplified implementation - in a real system this would analyze
Line 472: Default moderate cohesion
Line 475: Calculate class coupling (simplified metric)
Line 477: Simplified implementation - in a real system this would analyze
Line 479: Default low coupling
Line 482: Calculate class complexity
Line 484: Sum complexity of all methods
Line 502: Calculate cyclomatic complexity
Line 512: Count nodes that contribute to complexity
Line 540: Calculate cognitive complexity
Line 542: Simplified cognitive complexity calculation
Line 546: Check if function has side effects
Line 548: Simplified implementation - would analyze for global variable access,
Line 549: I/O operations, etc.
Line 553: Calculate overall architectural health score
Line 557: Penalize large classes
Line 570: Penalize complex functions
Line 580: Suggest refactoring patterns based on analysis
Line 584: Check for god classes
Line 603: Check for complex functions
Line 622: Apply architectural refactoring
Line 633: Apply a specific refactoring pattern
Line 644: Apply a specific transformation
Line 668: Extract method refactoring
Line 670: Simplified implementation - would extract complex logic into separate methods
Line 674: Split class refactoring
Line 676: Simplified implementation - would split large classes
Line 680: Extract interface refactoring
Line 682: Simplified implementation - would extract interface from class
Line 686: Apply strategy pattern
Line 688: Simplified implementation - would apply strategy pattern
Line 692: Apply factory pattern
Line 694: Simplified implementation - would apply factory pattern
Line 698: Apply dependency injection
Line 700: Simplified implementation - would apply dependency injection
Line 707: Analyze code and suggest architectural refactoring opportunities
Line 714: For each analyzed file, check for architectural issues
Line 721: Set up parser for analysis
Line 727: Skip unsupported languages
Line 731: Analyze architectural structure
Line 734: Create suggestions based on analysis
Line 776: Apply architectural refactoring transformation
Line 782: Extract metadata from suggestion
Line 787: Get the target file path
Line 794: Set up parser for the language
Line 808: Analyze and apply refactoring
Line 812: Write the transformed code back to file
Line 815: Calculate transformation details
Line 823: Will be set by engine if backup is created
Line 837: Validate that architectural refactoring transformation was successful
Line 838: Returns detailed validation results as dict[str, Any] matching Python
Line 849: Basic validation - check if transformation completed successfully
Line 858: Validate that files exist and are syntactically correct
Line 870: Try to read and parse the file to ensure it's valid
Line 876: Additional language-specific validation could be added here
Line 908: Basic test - would need actual tree-sitter nodes for full testing

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 9312 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (15/15) - Complete!
✅ Phase 2 complete: 15 files analyzed with enhanced context
📄 File summaries updated: 129 total files (15 from codehud-transform)
📄 Analysis metadata updated: 7 crates processed
🔍 DEBUG: Crate path for codehud-tui: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui
🔍 Processing 2 files from crate codehud-tui
🔍 DEBUG: First 5 files discovered for crate codehud-tui:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/main.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/lib.rs
🧠 Running narrator on 2 files in batch...
🔍 DEBUG: Found 32 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/main.rs
🔍 DEBUG: Bullet text length: 927 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/main.rs
🔍 DEBUG: Found 87 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/lib.rs
🔍 DEBUG: Bullet text length: 3112 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/lib.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 131 total files (2 from codehud-tui)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-tui...
🤖 Analyzing 2 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (2 files)...
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (1/2) - main.rs...🔍 DEBUG PROMPT for main.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/main.rs
Language: rust
Comments found: 48

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/main.rs
Language: rust
Module name: main

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD TUI CLI entry point
Line 3: ! Command-line interface for the CodeHUD Terminal User Interface
Line 4: ! optimized for Claude Code consumption.
Line 20: Path to the codebase to analyze
Line 24: Export analysis data to JSON instead of running TUI
Line 28: Output file for exported data
Line 32: Maximum number of issues to display
Line 36: Show only critical issues
Line 40: Use relative file paths
Line 44: Force TUI mode (skip terminal check)
Line 48: Show text preview of TUI output (no interactive terminal)
Line 52: Show visualizations directly in terminal (no interactive mode)
Line 59: Run the interactive TUI
Line 61: Path to the codebase to analyze
Line 64: Export analysis data as structured JSON
Line 66: Path to the codebase to analyze
Line 68: Output file path
Line 72: Validate TUI configuration
Line 94: Handle legacy CLI interface
Line 117: Run the interactive TUI
Line 122: Run the interactive TUI with options
Line 124: Check if we're in a terminal first (unless forced)
Line 150: Show text preview of TUI output (no interactive terminal required)
Line 155: Create headless TUI instance and load analysis
Line 160: Display TUI-formatted output as text
Line 174: Show critical issues (TUI Priority View)
Line 192: Show security summary (TUI Security View)
Line 206: Show quality metrics (TUI Quality View)
Line 214: Show navigation hint
Line 232: Show visualizations directly in terminal without interactive mode
Line 237: Create headless TUI instance and load analysis
Line 242: Create viz engine
Line 245: Convert analysis data to AnalysisResult
Line 251: Convert the analysis data to JSON and store in view data
Line 255: Create output directory for visualization exports
Line 258: Generate and display different view types
Line 275: Export as files
Line 286: Display summary in terminal
Line 308: Convert visualization view to readable text format (standalone version)
Line 352: Export analysis data as structured JSON
Line 356: Create headless TUI instance and load analysis
Line 360: Get analysis data and export
Line 388: Validate TUI configuration
Line 392: Check terminal capabilities
Line 402: Check color support

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2814 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (2/2) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/lib.rs
Language: rust
Comments found: 138

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD TUI - Terminal User Interface optimized for Claude Code consumption
Line 3: ! This crate provides a terminal-based interface using ratatui that presents
Line 4: ! CodeHUD analysis results in a structured, actionable format optimized for
Line 5: ! AI agents and command-line integration.
Line 49: Claude Code optimized TUI application
Line 60: Application state for navigation and display
Line 63: Current view being displayed
Line 65: List of available views
Line 67: Current selection index in lists
Line 71: Filter applied to current view
Line 73: Show only critical items
Line 75: Sort order (ascending/descending)
Line 77: Currently focused panel
Line 81: Panels that can receive focus
Line 90: Aggregated analysis data optimized for TUI display
Line 93: Overall health score (0-100)
Line 95: Total files analyzed
Line 97: Critical issues requiring immediate attention
Line 99: Quality metrics summary
Line 103: Top problematic files
Line 109: Raw analysis results for detailed views
Line 115: Critical issue requiring immediate attention
Line 127: Quality metrics summary
Line 137: Security assessment summary
Line 147: Problematic file with actionable metrics
Line 158: Dependency analysis insights
Line 168: Performance bottleneck identification
Line 178: Severity levels for issues
Line 188: Risk assessment levels
Line 201: Maximum items to display in lists
Line 203: Show file paths relative or absolute
Line 207: Auto-refresh interval in seconds
Line 209: Default view on startup
Line 211: Enable syntax highlighting in code views
Line 228: Color schemes for TUI
Line 234: Optimized for Claude Code consumption
Line 238: Create a new TUI instance for interactive use
Line 240: Check if we're in a proper terminal environment
Line 291: Create a new TUI instance for headless data processing (no terminal)
Line 328: Load analysis data from a codebase path
Line 333: Run comprehensive analysis
Line 336: Process and aggregate data into TUI-optimized format
Line 342: Process analysis result into TUI-optimized format
Line 347: Extract data from views
Line 353: Extract critical issues across all analyses
Line 356: Use existing health score from analysis
Line 359: Process quality summary
Line 362: Process security summary
Line 365: Identify problematic files
Line 368: Process dependency insights
Line 371: Extract performance bottlenecks
Line 397: Extract critical issues that need immediate attention
Line 401: Extract critical quality issues
Line 409: Critical threshold for maintainability
Line 425: Extract critical security issues
Line 448: Sort by impact score (highest first)
Line 454: Calculate overall health score from multiple analyses
Line 459: Quality score (40% weight)
Line 470: Security score (35% weight)
Line 477: Default to average if we have partial data
Line 481: Default neutral score
Line 485: Process quality data into summary format
Line 514: Sort worst files by maintainability score
Line 516: Top 10 worst files
Line 524: Mock complexity distribution for now
Line 540: Process security data into summary format
Line 580: TODO: Extract from data
Line 584: Identify most problematic files across all analyses
Line 603: Calculate priority rank based on multiple factors
Line 624: Will be set after sorting
Line 631: Sort by priority score and assign ranks
Line 642: Return top 20 most problematic files
Line 648: Process dependency analysis into insights
Line 650: Mock implementation - would need actual dependency data structure
Line 660: Extract performance bottlenecks from analysis data
Line 662: Mock implementation - would extract from actual performance analysis
Line 666: Run the main TUI event loop
Line 715: Draw the TUI interface
Line 725: Main layout: Header + Body + Footer
Line 735: Render components with captured data
Line 744: Render header with view tabs
Line 782: Render main content area based on current view
Line 801: Render quality analysis view
Line 811: Worst files list
Line 855: Quality metrics summary
Line 869: Render security analysis view
Line 924: Security issues list (filtered to security issues only)
Line 986: Render topology view
Line 994: Render dependencies view
Line 1007: Render performance view
Line 1018: Render issues view
Line 1020: Show all critical issues in a detailed list
Line 1092: Render placeholder for unimplemented views
Line 1100: Render view when no analysis data is available
Line 1115: Render footer with help information
Line 1142: Get color style based on health score
Line 1223: TODO: Implement detail view for selected item
Line 1227: TODO: Implement filtering
Line 1239: TODO: Implement data refresh
Line 1243: Get the current analysis data (for export functionality)
Line 1248: Static render methods for use in closures
Line 1290: Create visualization engine for rendering
Line 1293: Convert data and use viz engine
Line 1296: Export visualization to file for inspection
Line 1304: Fallback to old static methods if viz engine fails
Line 1351: Worst files list
Line 1391: Quality metrics summary
Line 1417: Render visualization charts using the viz engine
Line 1419: Use the visualization engine to generate a view
Line 1422: Render the visualization view in the TUI
Line 1427: Get visualization engine reference
Line 1432: Convert AnalysisData to AnalysisResult for viz engine
Line 1439: Convert the analysis data to JSON and store in view data
Line 1446: Fallback rendering when viz engine fails
Line 1465: Export visualization to file for inspection
Line 1469: Create output directory
Line 1472: Convert view to displayable format
Line 1483: Export as JSON for inspection
Line 1488: Export as text summary
Line 1497: Convert visualization view to readable text format
Line 1553: Limit for static view
Line 1631: Create and run TUI for a given codebase
Line 1639: Export analysis data in structured format for programmatic consumption

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6512 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (2/2) - Complete!
✅ Phase 2 complete: 2 files analyzed with enhanced context
📄 File summaries updated: 131 total files (2 from codehud-tui)
📄 Analysis metadata updated: 8 crates processed
🔍 DEBUG: Crate path for codehud-utils: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils
🔍 Processing 5 files from crate codehud-utils
🔍 DEBUG: First 5 files discovered for crate codehud-utils:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/config/mod.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/lib.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/logging/mod.rs
  4. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/file/mod.rs
  5. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/string/mod.rs
🧠 Running narrator on 5 files in batch...
🔍 DEBUG: Found 27 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/config/mod.rs
🔍 DEBUG: Bullet text length: 925 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/config/mod.rs
🔍 DEBUG: Found 10 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/lib.rs
🔍 DEBUG: Bullet text length: 778 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/lib.rs
🔍 DEBUG: Found 28 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/logging/mod.rs
🔍 DEBUG: Bullet text length: 1086 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/logging/mod.rs
🔍 DEBUG: Found 43 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/file/mod.rs
🔍 DEBUG: Bullet text length: 1900 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/file/mod.rs
🔍 DEBUG: Found 10 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/string/mod.rs
🔍 DEBUG: Bullet text length: 468 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/string/mod.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 136 total files (5 from codehud-utils)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-utils...
🤖 Analyzing 5 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (5 files)...
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (1/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/config/mod.rs
Language: rust
Comments found: 26

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/config/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Configuration utilities with Python configparser compatibility
Line 3: ! This module provides configuration loading and management that
Line 4: ! behaves identically to Python's configparser and related utilities.
Line 10: Configuration loader that supports TOML, JSON, and YAML
Line 17: Create a new configuration loader
Line 24: Load configuration from file (auto-detects format)
Line 64: Get configuration value by key path (supports dot notation)
Line 70: Get string value
Line 75: Get integer value
Line 80: Get float value
Line 85: Get boolean value
Line 90: Get array value
Line 95: Helper to navigate nested JSON values using dot notation
Line 107: Merge configurations (second config overrides first)
Line 117: Get all config names
Line 129: Merge two JSON values (second overrides first)
Line 147: Load configuration from file (convenience function)
Line 184: Merge two configurations (second overrides first)
Line 203: Validate configuration against schema (basic validation)
Line 208: Convert to JSON to perform validation
Line 212: TODO: Add more sophisticated validation if needed
Line 216: Configuration builder for fluent API
Line 226: Create new config builder with defaults
Line 233: Load from file and merge
Line 240: Merge with another config
Line 246: Validate and build final config

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1988 characters
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (2/5) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/lib.rs
Language: rust
Comments found: 25

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Utilities - Python-Compatible Utility Functions
Line 3: ! This crate provides utility functions that match Python behavior exactly
Line 4: ! to ensure zero degradation in file operations, string processing,
Line 5: ! configuration handling, and logging.
Line 15: Re-export commonly used utilities
Line 26: Result type used throughout CodeHUD utilities
Line 29: Error types for utility operations
Line 32: I/O operation failed
Line 40: String processing error
Line 44: Path operation error
Line 53: Common exclusion patterns that match Python behavior exactly
Line 75: IDE and editor files
Line 99: File extensions for different programming languages (matches Python logic)
Line 139: Detect programming language from file extension
Line 153: Check if a path should be excluded based on patterns
Line 159: Handle glob patterns like *.pyc

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1513 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  60% (3/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/logging/mod.rs
Language: rust
Comments found: 35

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/logging/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! Logging utilities with Python logging compatibility
Line 3: ! This module provides logging capabilities that behave similarly
Line 4: ! to Python's logging module while leveraging Rust's tracing ecosystem.
Line 19: Log levels matching Python logging levels
Line 36: Rust doesn't have CRITICAL, use ERROR
Line 54: Logger configuration matching Python logging behavior
Line 78: Initialize logging with configuration
Line 100: Initialize basic logging (equivalent to Python's basicConfig)
Line 109: Logger struct that mimics Python logger behavior
Line 117: Create a new logger with the given name
Line 125: Set the logging level
Line 130: Get the current logging level
Line 135: Check if a level is enabled
Line 140: Log a debug message
Line 147: Log an info message
Line 154: Log a warning message
Line 161: Log an error message
Line 168: Log a critical message
Line 175: Log an exception (error with extra context)
Line 181: Get a logger by name (equivalent to Python's logging.getLogger)
Line 186: Structured logging macros that work with tracing
Line 223: File handler for logging to files (equivalent to Python's FileHandler)
Line 229: Create a new file handler
Line 239: Write a log record to the file
Line 246: Rotating file handler (basic implementation)
Line 256: Create a new rotating file handler
Line 278: Write a log record, rotating if necessary
Line 283: Check if rotation is needed
Line 294: Perform log rotation
Line 296: Close current file
Line 299: Rotate backup files
Line 309: Move current log to .1
Line 315: Create new log file
Line 378: Write enough to trigger rotation
Line 383: Check that backup files were created

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2324 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (4/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/file/mod.rs
Language: rust
Comments found: 36

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/file/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! File system utilities with Python pathlib compatibility
Line 3: ! This module provides file system operations that behave identically
Line 4: ! to Python's pathlib and related utilities.
Line 12: Safely join paths, preventing directory traversal attacks (matches Python os.path.join behavior)
Line 14: Normalize the relative path to prevent .. traversal
Line 17: Check for absolute path or .. traversal attempts
Line 27: Normalize path (equivalent to Python pathlib.Path.resolve())
Line 32: Find project root by looking for common project markers (matches Python behavior)
Line 50: Check if any project markers exist in current directory
Line 57: Move up to parent directory
Line 67: Create a timestamped backup of a file (matches Python behavior)
Line 96: Copy file with automatic backup creation
Line 98: Create backup of destination if it exists
Line 103: Ensure destination directory exists
Line 112: Get file metadata in a Python-compatible format
Line 126: Create FileMetadata from a path
Line 131: Creation time is not reliable on all platforms (like Python's behavior)
Line 149: Recursively find files matching patterns (equivalent to Python glob/pathlib)
Line 161: Recursive helper for find_files
Line 170: Check depth limit
Line 177: Check if directory should be excluded
Line 191: Check if file should be excluded
Line 198: Check if file matches patterns
Line 221: Calculate file content hash (for caching)
Line 242: Read file with encoding detection (matches Python behavior)
Line 244: Try UTF-8 first (most common)
Line 248: Fallback to bytes and try to decode as UTF-8 with replacement
Line 255: Ensure directory exists (equivalent to pathlib.Path.mkdir(parents=True, exist_ok=True))
Line 281: Unsafe joins should fail
Line 300: Create a project marker
Line 303: Should find project root from subdirectory
Line 330: Create test files
Line 339: Find Python files
Line 363: Same file should have same hash
Line 366: Modified file should have different hash

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2648 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (5/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/string/mod.rs
Language: rust
Comments found: 27

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils/src/string/mod.rs
Language: rust
Module name: mod

COMMENTS TO ANALYZE:
Line 1: ! String processing utilities with Python compatibility
Line 3: ! This module provides string operations that behave identically
Line 4: ! to Python's string methods and utilities.
Line 10: Safely truncate text to maximum length (matches Python textwrap behavior)
Line 16: Find grapheme boundary at or before max_len
Line 29: Add ellipsis if truncated and there's space
Line 33: Replace last characters with ellipsis
Line 41: Normalize whitespace (matches Python string normalization)
Line 46: Replace all whitespace sequences with single spaces
Line 50: Strip leading and trailing whitespace
Line 54: Extract function names from code (Python-like regex patterns)
Line 74: Calculate string similarity (Levenshtein distance-based, 0.0 to 1.0)
Line 90: Calculate Levenshtein distance between two strings
Line 99: Initialize first row and column
Line 107: Fill the matrix
Line 120: Convert camelCase to snake_case (Python convention)
Line 126: Convert snake_case to camelCase
Line 143: Capitalize first letter of a string
Line 152: Split text into lines preserving line endings (matches Python splitlines)
Line 157: Remove common leading whitespace from lines (like Python textwrap.dedent)
Line 164: Find minimum indentation (excluding empty lines)
Line 171: Remove common indentation
Line 184: Check if string is valid identifier (Python rules)
Line 193: First character must be letter or underscore
Line 198: Remaining characters must be alphanumeric or underscore
Line 213: Test with Unicode

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2173 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (5/5) - Complete!
✅ Phase 2 complete: 5 files analyzed with enhanced context
📄 File summaries updated: 136 total files (5 from codehud-utils)
📄 Analysis metadata updated: 9 crates processed
🔍 DEBUG: Crate path for codehud-viz: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz
🔍 Processing 8 files from crate codehud-viz
🔍 DEBUG: First 5 files discovered for crate codehud-viz:
  1. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/call_graph.rs
  2. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/lib.rs
  3. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/topology_test.rs
  4. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/summary_test.rs
  5. /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/quality_test.rs
🧠 Running narrator on 8 files in batch...
🔍 DEBUG: Found 16 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/call_graph.rs
🔍 DEBUG: Bullet text length: 577 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/call_graph.rs
🔍 DEBUG: Found 28 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/lib.rs
🔍 DEBUG: Bullet text length: 1330 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/lib.rs
🔍 DEBUG: Found 9 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/topology_test.rs
🔍 DEBUG: Bullet text length: 424 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/topology_test.rs
🔍 DEBUG: Found 8 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/summary_test.rs
🔍 DEBUG: Bullet text length: 344 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/summary_test.rs
🔍 DEBUG: Found 9 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/quality_test.rs
🔍 DEBUG: Bullet text length: 422 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/quality_test.rs
🔍 DEBUG: Found 9 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/flow_test.rs
🔍 DEBUG: Bullet text length: 416 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/flow_test.rs
🔍 DEBUG: Found 9 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/dependencies_test.rs
🔍 DEBUG: Bullet text length: 432 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/dependencies_test.rs
🔍 DEBUG: Found 8 findings for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/security_test.rs
🔍 DEBUG: Bullet text length: 344 for /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/security_test.rs
✅ Added structural insights to all files
💾 Comments JSON updated: 144 total files (8 from codehud-viz)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-viz...
🤖 Analyzing 8 files with enhanced context and improved token limits...
📦 Processing batch 1/2 (5 files)...
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  12% (1/8) - call_graph.rs...🔍 DEBUG PROMPT for call_graph.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/call_graph.rs
Language: rust
Comments found: 19

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/call_graph.rs
Language: rust
Module name: call_graph

COMMENTS TO ANALYZE:
Line 1: ! Call Graph Visualization Module
Line 3: ! Provides call graph analysis and visualization capabilities using ratatui widgets.
Line 44: Add nodes if they don't exist
Line 60: Add or update edge
Line 71: Update call counts
Line 78: Split area into sections
Line 83: Function analysis chart
Line 95: Function analysis as bar chart
Line 98: Call relationships list
Line 109: Convert to bar chart data
Line 277: Normalize to reasonable max

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1120 characters
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (2/8) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/lib.rs
Language: rust
Comments found: 252

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/src/lib.rs
Language: rust
Module name: lib

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Visualization - Data visualization and export capabilities
Line 3: ! This crate provides visualization capabilities matching the Python implementation
Line 4: ! with support for various output formats and interactive visualizations.
Line 42: Main visualization system
Line 59: Configuration for visualization
Line 62: Terminal width (characters)
Line 64: Terminal height (characters)
Line 68: Enable syntax highlighting
Line 70: Maximum items to show in lists
Line 72: Chart data point limit
Line 89: Color schemes for visualization
Line 97: Renderable view that can be displayed in terminal
Line 106: Content types for different visualizations
Line 109: Summary dashboard with key metrics
Line 117: Code topology visualization
Line 124: Quality analysis visualization
Line 132: Security analysis visualization
Line 148: Performance analysis visualization
Line 175: Code flow visualization
Line 182: Tree-sitter enhanced semantic analysis
Line 192: File tree structure for topology visualization
Line 250: Tree-sitter import analysis summary
Line 262: Tree-sitter symbol information
Line 272: Tree-sitter semantic highlights summary
Line 282: Language feature detected by tree-sitter
Line 292: Create a new visualization engine
Line 301: Configure the visualization engine
Line 307: Generate a renderable view from analysis results
Line 334: Render a view to terminal
Line 348: Render content based on view type
Line 367: Generate summary view content
Line 372: Core analysis metrics
Line 378: Extract additional metrics from various view data sources
Line 411: Count security vulnerabilities
Line 481: Add general recommendations based on analysis
Line 498: Generate topology view content
Line 500: Extract topology data from analysis result
Line 520: Extract language distribution from summary
Line 532: Extract file and directory counts from structure
Line 545: Extract complexity data from files
Line 549: Extract file path and complexity
Line 562: Extract coupling metrics from coupling analysis
Line 582: Build real file tree structure from project structure
Line 590: Build hierarchical file tree from files data
Line 605: Extract filename from full path for display
Line 614: Build file tree structure from files data
Line 617: Limit for performance
Line 637: Generate quality view content
Line 647: Extract issues by severity from quality_issues
Line 658: Extract file metrics for analysis
Line 669: Sort by lowest maintainability (most problematic)
Line 673: Extract complexity and maintainability trends with better file handling
Line 690: Extract additional metrics from summary if available
Line 692: Add overall statistics to issues if available
Line 696: If no specific severity breakdown, add general category
Line 704: Normalize health score to 0-1 range if needed
Line 716: Generate security view content
Line 727: Extract from all_vulnerabilities (comprehensive security issues)
Line 735: Create security issue object with enhanced data
Line 753: Extract from all_security_issues (additional security analysis)
Line 780: Extract from dangerous function usage
Line 805: Calculate risk level and security score based on vulnerabilities
Line 824: Extract from summary if available
Line 839: Remove duplicates from files_with_issues
Line 852: Generate dependencies view content
Line 867: Extract summary info
Line 874: Extract circular dependencies
Line 893: Extract coupling analysis
Line 908: Extract external dependencies
Line 925: Extract graph structure
Line 927: Extract nodes from file dependencies
Line 934: Extract edges from coupling analysis
Line 949: Extract circular cycles for graph
Line 978: Extract average performance score
Line 983: Extract performance hotspots
Line 1014: Extract slow functions from optimization opportunities
Line 1046: Extract commit activity patterns
Line 1060: Extract author contributions from author_metrics
Line 1074: Extract file stability from file_evolutions
Line 1082: Get just the filename for display
Line 1090: Extract churn metrics (files with high change frequency)
Line 1098: Get just the filename for display
Line 1106: Sort by value (highest first)
Line 1129: Extract issues by tool type from issue_summary
Line 1143: Extract recent issues from all tools
Line 1195: Generate mock resolution trends based on issue types
Line 1197: Simulate trend data - in production this would come from historical analysis
Line 1201: Sort by severity (critical, high, medium, low)
Line 1230: Extract overall test coverage from metrics
Line 1233: Convert to 0-1 range
Line 1236: Extract files without tests as uncovered files
Line 1249: Extract test file names from test_files array
Line 1261: Generate test trends from coverage data
Line 1270: Convert to 0-1 range
Line 1276: If no coverage data, generate trends from test files and their test counts
Line 1286: Convert test count to a relative score (normalize to 0-1)
Line 1287: Assume 20+ tests = 100%
Line 1295: Sort trends by coverage (highest first)
Line 1316: Extract data flow nodes and edges
Line 1320: Process data flow edges
Line 1356: Calculate flow complexity based on patterns
Line 1370: Extract bottlenecks from patterns
Line 1390: Extract additional bottlenecks from variable lifecycles
Line 1409: Normalize complexity to 0-1 range
Line 1421: Generate tree-sitter analysis view content
Line 1446: Extract import analysis
Line 1466: Extract language features
Line 1481: TODO: extract files list
Line 1513: Extract highlight summary
Line 1532: Group symbols by type
Line 1544: TODO: calculate actual complexity
Line 1549: Calculate complexity for a flow edge type
Line 1560: Render header section
Line 1568: Render footer section
Line 1575: Render summary content
Line 1578: Create 4-panel layout
Line 1594: Top Left: Health Score Overview
Line 1597: Top Right: Core Metrics
Line 1600: Bottom Left: Quality & Security Metrics
Line 1603: Bottom Right: Recommendations
Line 1608: Render health score overview panel
Line 1644: Render overview text
Line 1659: Render core metrics panel
Line 1697: Render quality and security metrics panel
Line 1744: Render recommendations panel
Line 1775: Render topology content
Line 1778: Create 4-panel layout
Line 1794: Top Left: Language Distribution
Line 1797: Top Right: File Structure Overview
Line 1800: Bottom Left: Complexity Distribution
Line 1803: Bottom Right: Coupling Metrics
Line 1808: Render language distribution panel
Line 1817: Limit for display
Line 1831: Render file structure overview panel
Line 1838: Add sample files if available
Line 1865: Render complexity distribution panel
Line 1894: Render coupling metrics panel
Line 1923: Render quality content
Line 1926: Create 4-panel layout
Line 1942: Top Left: Health Score Gauge
Line 1945: Top Right: Issues by Severity
Line 1948: Bottom Left: Complexity Trend
Line 1951: Bottom Right: Maintainability Scores
Line 1956: Render health score gauge
Line 1988: Render text on top
Line 2003: Render issues by severity panel
Line 2025: Render complexity trend panel
Line 2054: Render maintainability scores panel
Line 2056: Prefer problematic files if available, otherwise show maintainability scores
Line 2096: Render security content
Line 2099: Create 4-panel layout
Line 2115: Top Left: Security Score Gauge
Line 2118: Top Right: Vulnerabilities by Severity
Line 2121: Bottom Left: Top Security Issues
Line 2124: Bottom Right: Files with Issues
Line 2129: Render security score gauge
Line 2156: Render text on top
Line 2171: Render vulnerabilities by severity panel
Line 2193: Render top security issues panel
Line 2224: Render files with security issues panel
Line 2248: Show count of additional files
Line 2264: Render dependencies content
Line 2278: Left side - Summary and circular dependencies
Line 2305: Truncate long cycle paths for display
Line 2326: Right side - Coupling analysis and external dependencies
Line 2391: Left side - Performance score and hotspots
Line 2397: Performance score gauge
Line 2435: Right side - Bottlenecks and slow functions
Line 2459: Slow functions (optimization opportunities)
Line 2499: Left side - Commit activity and author contributions
Line 2505: Commit activity patterns
Line 2574: Right side - File stability and churn metrics
Line 2613: Churn metrics (change frequency)
Line 2619: Very high churn
Line 2659: Left side - Issues by type and summary
Line 2665: Issues by type/tool
Line 2724: Right side - Recent issues
Line 2785: Left side - Coverage and test files
Line 2791: Test coverage gauge
Line 2800: Test files list
Line 2821: Right side - Uncovered files and test trends
Line 2848: Test trends (coverage by file or test counts)
Line 2886: Create 4-panel layout
Line 2902: Top Left: Flow Complexity Gauge
Line 2905: Top Right: Data Flows
Line 2908: Bottom Left: Control Flows
Line 2911: Bottom Right: Bottlenecks
Line 2916: Render tree-sitter analysis content
Line 2919: Create 4-panel layout
Line 2935: Top Left: Import Summary
Line 2938: Top Right: Highlight Summary
Line 2941: Bottom Left: Language Features
Line 2944: Bottom Right: Symbols
Line 2949: Render import summary
Line 2972: Render highlight summary
Line 3007: Render language features
Line 3017: Simple icon for now
Line 3045: Render symbols list
Line 3103: Render flow complexity gauge
Line 3105: Create gauge visualization
Line 3143: Render text on top
Line 3158: Render data flows list
Line 3196: Render control flows list
Line 3234: Render flow bottlenecks
Line 3266: Truncate a name to specified length with ellipsis
Line 3275: Get color for health score visualization
Line 3291: Get color for risk level
Line 3308: Get color for performance score visualization
Line 3324: Get color for test coverage visualization
Line 3340: Get header style
Line 3349: Get footer style
Line 3358: Get content style
Line 3367: Get chart style

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 10439 characters
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  37% (3/8) - topology_test.rs...🔍 DEBUG PROMPT for topology_test.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/topology_test.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/topology_test.rs
Language: rust
Module name: topology_test

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create topology extractor
Line 19: Extract topology data
Line 24: Create analysis result with real topology data
Line 31: Store topology data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Topology view
Line 44: Check that we got the right view content
Line 86: Verify we have at least some data structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1112 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (4/8) - summary_test.rs...🔍 DEBUG PROMPT for summary_test.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/summary_test.rs
Language: rust
Comments found: 16

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/summary_test.rs
Language: rust
Module name: summary_test

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create analysis result with comprehensive mock data from multiple extractors
Line 26: Add comprehensive view data from multiple extractors to test aggregation
Line 88: Create visualization engine
Line 92: Generate Summary view
Line 97: Check that we got the right view content
Line 125: Verify we have valid data structure
Line 132: Verify enhanced metrics were extracted
Line 139: Check specific values
Line 146: Verify enhanced recommendations were added
Line 147: Should have original + enhanced

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1241 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  62% (5/8) - quality_test.rs...🔍 DEBUG PROMPT for quality_test.rs:
=====================================
CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/quality_test.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/quality_test.rs
Language: rust
Module name: quality_test

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create quality extractor
Line 19: Extract quality data
Line 24: Create analysis result with real quality data
Line 31: Store quality data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Quality view
Line 44: Check that we got the right view content
Line 88: Verify we have valid data structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1096 characters
📦 Processing batch 2/2 (3 files)...
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (4/8) - flow_test.rs...🔍 DEBUG PROMPT for flow_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- call_graph.rs: The file "call_graph.rs" in Rust language is a module that offers call graph analysis and visualization capabilities. It provides functionalities such as adding nodes if they don't exist, updating edg
- lib.rs: This file serves as the main entry point for CodeHUD, a Rust-based tool providing data visualization and export capabilities in addition to supporting various output formats and interactive visualizat
- topology_test.rs: This Rust file serves as a unit test for the topology visualization feature of CodeHUD. It verifies that the codebase can correctly generate and analyze topological data, which is essential for unders
- summary_test.rs: This Rust file is designed for testing the summary feature of a code analysis tool named CodeHUD. It covers various functionalities including creating test data, generating comprehensive mock data fro
- quality_test.rs: This Rust file serves as a quality testing module for the CodeHUD visualization tool. It provides functionalities related to extracting code quality data, creating analysis results with real quality d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/flow_test.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/flow_test.rs
Language: rust
Module name: flow_test

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create flow extractor
Line 19: Extract flow data
Line 24: Create analysis result with real flow data
Line 31: Store flow data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Flow view
Line 44: Check that we got the right view content
Line 79: Verify we have at least some data structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2279 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  62% (5/8) - dependencies_test.rs...🔍 DEBUG PROMPT for dependencies_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- call_graph.rs: The file "call_graph.rs" in Rust language is a module that offers call graph analysis and visualization capabilities. It provides functionalities such as adding nodes if they don't exist, updating edg
- lib.rs: This file serves as the main entry point for CodeHUD, a Rust-based tool providing data visualization and export capabilities in addition to supporting various output formats and interactive visualizat
- topology_test.rs: This Rust file serves as a unit test for the topology visualization feature of CodeHUD. It verifies that the codebase can correctly generate and analyze topological data, which is essential for unders
- summary_test.rs: This Rust file is designed for testing the summary feature of a code analysis tool named CodeHUD. It covers various functionalities including creating test data, generating comprehensive mock data fro
- quality_test.rs: This Rust file serves as a quality testing module for the CodeHUD visualization tool. It provides functionalities related to extracting code quality data, creating analysis results with real quality d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/dependencies_test.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/dependencies_test.rs
Language: rust
Module name: dependencies_test

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create dependencies extractor
Line 19: Extract dependencies data
Line 24: Create analysis result with real dependencies data
Line 31: Store dependencies data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Dependencies view
Line 44: Check that we got the right view content
Line 82: Verify we have at least some data

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2333 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (6/8) - security_test.rs...🔍 DEBUG PROMPT for security_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- call_graph.rs: The file "call_graph.rs" in Rust language is a module that offers call graph analysis and visualization capabilities. It provides functionalities such as adding nodes if they don't exist, updating edg
- lib.rs: This file serves as the main entry point for CodeHUD, a Rust-based tool providing data visualization and export capabilities in addition to supporting various output formats and interactive visualizat
- topology_test.rs: This Rust file serves as a unit test for the topology visualization feature of CodeHUD. It verifies that the codebase can correctly generate and analyze topological data, which is essential for unders
- summary_test.rs: This Rust file is designed for testing the summary feature of a code analysis tool named CodeHUD. It covers various functionalities including creating test data, generating comprehensive mock data fro
- quality_test.rs: This Rust file serves as a quality testing module for the CodeHUD visualization tool. It provides functionalities related to extracting code quality data, creating analysis results with real quality d

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/security_test.rs
Language: rust
Comments found: 9

BASIC FILE CONTEXT:
File: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz/tests/security_test.rs
Language: rust
Module name: security_test

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create analysis result with mock security data to test visualization
Line 23: Create mock security data that matches what the SecurityExtractor would produce
Line 67: Store security data in the extracted view data
Line 70: Create visualization engine
Line 74: Generate Security view
Line 79: Check that we got the right view content
Line 116: Verify we have valid data structure
Line 121: Verify mock data was processed correctly

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2373 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (8/8) - Complete!
✅ Phase 2 complete: 8 files analyzed with enhanced context
📄 File summaries updated: 144 total files (8 from codehud-viz)
📄 Analysis metadata updated: 10 crates processed

📝 PHASE 2: Detecting subcrates and generating subcrate summaries for all crates...

🔍 Detecting subcrates for crate: codehud-analysis
🔍 DEBUG: Filtered 3 files for crate codehud-analysis (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis)
📦 No subcrates detected for codehud-analysis (files: 3)
✅ Phase 2 complete for crate: codehud-analysis
🔍 Detecting subcrates for crate: codehud-cli
🔍 DEBUG: Filtered 4 files for crate codehud-cli (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli)
📦 No subcrates detected for codehud-cli (files: 4)
✅ Phase 2 complete for crate: codehud-cli
🔍 Detecting subcrates for crate: codehud-core
🔍 DEBUG: Filtered 52 files for crate codehud-core (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core)
📦 Detected 4 subcrates for codehud-core (including nested)
   - src (2 direct files, 3 nested, 670.4 KB)
📊 Token budget: 4 subcrates × 250 tokens/subcrate = 1000 total (max 5000)
📝 Generating summary for subcrate: src (2 files, 670.4 KB)
✅ Generated subcrate summary: src (177 tokens)
📦 Total subcrate summaries generated: 1
✅ Generated 1 subcrate summaries for crate: codehud-core
✅ Phase 2 complete for crate: codehud-core
🔍 Detecting subcrates for crate: codehud-gui
🔍 DEBUG: Filtered 24 files for crate codehud-gui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui)
📦 Detected 2 subcrates for codehud-gui (including nested)
   - src (5 direct files, 1 nested, 194.7 KB)
📊 Token budget: 2 subcrates × 250 tokens/subcrate = 500 total (max 5000)
📝 Generating summary for subcrate: src (5 files, 194.7 KB)
✅ Generated subcrate summary: src (163 tokens)
📦 Total subcrate summaries generated: 1
✅ Generated 1 subcrate summaries for crate: codehud-gui
✅ Phase 2 complete for crate: codehud-gui
🔍 Detecting subcrates for crate: codehud-llm
🔍 DEBUG: Filtered 30 files for crate codehud-llm (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm)
📦 Detected 3 subcrates for codehud-llm (including nested)
   - src (17 direct files, 1 nested, 537.0 KB)
📊 Token budget: 3 subcrates × 250 tokens/subcrate = 750 total (max 5000)
📝 Generating summary for subcrate: src (17 files, 537.0 KB)
✅ Generated subcrate summary: src (167 tokens)
📦 Total subcrate summaries generated: 1
✅ Generated 1 subcrate summaries for crate: codehud-llm
✅ Phase 2 complete for crate: codehud-llm
🔍 Detecting subcrates for crate: codehud-realtime
🔍 DEBUG: Filtered 1 files for crate codehud-realtime (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime)
📦 No subcrates detected for codehud-realtime (files: 1)
✅ Phase 2 complete for crate: codehud-realtime
🔍 Detecting subcrates for crate: codehud-transform
🔍 DEBUG: Filtered 15 files for crate codehud-transform (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform)
📦 Detected 2 subcrates for codehud-transform (including nested)
   - src (5 direct files, 1 nested, 291.5 KB)
📊 Token budget: 2 subcrates × 250 tokens/subcrate = 500 total (max 5000)
📝 Generating summary for subcrate: src (5 files, 291.5 KB)
✅ Generated subcrate summary: src (170 tokens)
📦 Total subcrate summaries generated: 1
✅ Generated 1 subcrate summaries for crate: codehud-transform
✅ Phase 2 complete for crate: codehud-transform
🔍 Detecting subcrates for crate: codehud-tui
🔍 DEBUG: Filtered 2 files for crate codehud-tui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui)
📦 No subcrates detected for codehud-tui (files: 2)
✅ Phase 2 complete for crate: codehud-tui
🔍 Detecting subcrates for crate: codehud-utils
🔍 DEBUG: Filtered 5 files for crate codehud-utils (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils)
📦 Detected 1 subcrates for codehud-utils (including nested)
   - src (1 direct files, 0 nested, 49.4 KB)
📊 Token budget: 1 subcrates × 250 tokens/subcrate = 250 total (max 5000)
📝 Generating summary for subcrate: src (1 files, 49.4 KB)
✅ Generated subcrate summary: src (178 tokens)
📦 Total subcrate summaries generated: 1
✅ Generated 1 subcrate summaries for crate: codehud-utils
✅ Phase 2 complete for crate: codehud-utils
🔍 Detecting subcrates for crate: codehud-viz
🔍 DEBUG: Filtered 8 files for crate codehud-viz (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz)
📦 Detected 1 subcrates for codehud-viz (including nested)
   - tests (6 direct files, 0 nested, 26.0 KB)
📊 Token budget: 1 subcrates × 250 tokens/subcrate = 250 total (max 5000)
📝 Generating summary for subcrate: tests (6 files, 26.0 KB)
✅ Generated subcrate summary: tests (178 tokens)
📦 Total subcrate summaries generated: 1
✅ Generated 1 subcrate summaries for crate: codehud-viz
✅ Phase 2 complete for crate: codehud-viz
💾 Saved combined subcrate summaries: 6 subcrates across 10 crates

📝 PHASE 3: Generating crate summaries for all crates...

🔍 DEBUG: Filtered 3 files for crate codehud-analysis (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis)
⚠️  No subcrate summaries found in combined file for crate: codehud-analysis
🧠 Generating context-aware summary for crate: codehud-analysis (with 0 previous insights)
📄 No subcrates, using all 3 files individually
✅ Context-aware crate summary generated: 514 tokens
✅ Generated context-aware summary for crate 'codehud-analysis': 514 tokens
📄 Crate summaries updated: 1 total crates
🔍 DEBUG: Filtered 4 files for crate codehud-cli (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli)
⚠️  No subcrate summaries found in combined file for crate: codehud-cli
🧠 Generating context-aware summary for crate: codehud-cli (with 1 previous insights)
📄 No subcrates, using all 4 files individually
✅ Context-aware crate summary generated: 328 tokens
✅ Generated context-aware summary for crate 'codehud-cli': 328 tokens
📄 Crate summaries updated: 2 total crates
🔍 DEBUG: Filtered 52 files for crate codehud-core (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core)
📂 Loaded 1 subcrate summaries for crate: codehud-core
🧠 Generating context-aware summary for crate: codehud-core (with 2 previous insights)
📦 Using subcrate summaries: 1 subcrates, 17 individual files, 35 files in subcrates
✅ Context-aware crate summary generated: 574 tokens
✅ Generated context-aware summary for crate 'codehud-core': 574 tokens
📄 Crate summaries updated: 3 total crates
🔍 DEBUG: Filtered 24 files for crate codehud-gui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui)
📂 Loaded 1 subcrate summaries for crate: codehud-gui
🧠 Generating context-aware summary for crate: codehud-gui (with 3 previous insights)
📦 Using subcrate summaries: 1 subcrates, 7 individual files, 17 files in subcrates
✅ Context-aware crate summary generated: 661 tokens
✅ Generated context-aware summary for crate 'codehud-gui': 661 tokens
📄 Crate summaries updated: 4 total crates
🔍 DEBUG: Filtered 30 files for crate codehud-llm (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm)
📂 Loaded 1 subcrate summaries for crate: codehud-llm
🧠 Generating context-aware summary for crate: codehud-llm (with 4 previous insights)
📦 Using subcrate summaries: 1 subcrates, 2 individual files, 28 files in subcrates
✅ Context-aware crate summary generated: 561 tokens
✅ Generated context-aware summary for crate 'codehud-llm': 561 tokens
📄 Crate summaries updated: 5 total crates
🔍 DEBUG: Filtered 1 files for crate codehud-realtime (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime)
⚠️  No subcrate summaries found in combined file for crate: codehud-realtime
🧠 Generating context-aware summary for crate: codehud-realtime (with 5 previous insights)
📄 No subcrates, using all 1 files individually
✅ Context-aware crate summary generated: 541 tokens
✅ Generated context-aware summary for crate 'codehud-realtime': 541 tokens
📄 Crate summaries updated: 6 total crates
🔍 DEBUG: Filtered 15 files for crate codehud-transform (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform)
📂 Loaded 1 subcrate summaries for crate: codehud-transform
🧠 Generating context-aware summary for crate: codehud-transform (with 6 previous insights)
📦 Using subcrate summaries: 1 subcrates, 0 individual files, 15 files in subcrates
✅ Context-aware crate summary generated: 476 tokens
✅ Generated context-aware summary for crate 'codehud-transform': 476 tokens
📄 Crate summaries updated: 7 total crates
🔍 DEBUG: Filtered 2 files for crate codehud-tui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui)
⚠️  No subcrate summaries found in combined file for crate: codehud-tui
🧠 Generating context-aware summary for crate: codehud-tui (with 7 previous insights)
📄 No subcrates, using all 2 files individually
✅ Context-aware crate summary generated: 411 tokens
✅ Generated context-aware summary for crate 'codehud-tui': 411 tokens
📄 Crate summaries updated: 8 total crates
🔍 DEBUG: Filtered 5 files for crate codehud-utils (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils)
📂 Loaded 1 subcrate summaries for crate: codehud-utils
🧠 Generating context-aware summary for crate: codehud-utils (with 8 previous insights)
📦 Using subcrate summaries: 1 subcrates, 4 individual files, 1 files in subcrates
✅ Context-aware crate summary generated: 434 tokens
✅ Generated context-aware summary for crate 'codehud-utils': 434 tokens
📄 Crate summaries updated: 9 total crates
🔍 DEBUG: Filtered 8 files for crate codehud-viz (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz)
📂 Loaded 1 subcrate summaries for crate: codehud-viz
🧠 Generating context-aware summary for crate: codehud-viz (with 9 previous insights)
📦 Using subcrate summaries: 1 subcrates, 2 individual files, 6 files in subcrates
✅ Context-aware crate summary generated: 437 tokens
✅ Generated context-aware summary for crate 'codehud-viz': 437 tokens
📄 Crate summaries updated: 10 total crates
📝 Generating final hierarchical summary...
📝 Generating final hierarchical summary with 12K token budget...
📊 Loaded 10 real crate summaries for hierarchical analysis
🧠 Applying intelligent denoising to 10 crate summaries
🔍 DEBUG: Denoising input: 2057 chars, 278 words
🔍 DEBUG: Found 13 sentences
🔍 DEBUG: Sentence 0: score=6.5 - ## Overall Architecture
The 'codehud-analysis' crate forms a crucial part of the
🔍 DEBUG: Sentence 1: score=6.5 -  It's designed as a Rust library, meaning it provides various functionalities th
🔍 DEBUG: Sentence 2: score=2.0 -  Its design patterns include modularity and componentization - each module withi
🔍 DEBUG: Sentence 3: score=2.5 -  The dependencies are managed using the Cargo package manager, which automatical
🔍 DEBUG: Sentence 4: score=10.5 - 

## What Does It Actually Do
The primary purpose of this crate is to provide an
🔍 DEBUG: Sentence 5: score=5.5 -  This includes two main functionalities: direct and legacy analysis modes, along
🔍 DEBUG: Sentence 6: score=3.5 -  

In the context of direct analysis, it orchestrates all extractors (Python imp
🔍 DEBUG: Sentence 7: score=7.5 -  The pipeline is designed to handle parallel execution of extractors, set an exe
🔍 DEBUG: Sentence 8: score=6.5 - 

The crate also provides a comprehensive module for calculating software health
🔍 DEBUG: Sentence 9: score=6.5 -  It employs exact Python algorithms to replicate their functionality and allows 
🔍 DEBUG: Sentence 10: score=3.5 -  This module can provide individual component scores, calculate weighted overall
🔍 DEBUG: Sentence 11: score=0.0 - ), maintainability score calculations
🔍 DEBUG: Sentence 12: score=9.5 - 

In conclusion, the 'codehud-analysis' crate serves as a central piece of CodeH
🔍 DEBUG: Keeping 8 out of 13 sentences
🔍 DEBUG: Denoising input: 1315 chars, 190 words
🔍 DEBUG: Found 10 sentences
🔍 DEBUG: Sentence 0: score=7.5 - Overall Architecture:
The 'codehud-cli' crate forms an integral part of a larger
🔍 DEBUG: Sentence 1: score=3.5 -  It relies on the Rust programming language for its robustness and performance, 
🔍 DEBUG: Sentence 2: score=2.5 -  The crate is structured as three separate files (main
🔍 DEBUG: Sentence 3: score=1.5 - rs, llm
🔍 DEBUG: Sentence 4: score=-0.5 - rs, direct
🔍 DEBUG: Sentence 5: score=4.0 - rs) each serving a distinct role in the command-line interface of CodeHUD
🔍 DEBUG: Sentence 6: score=4.0 - 

What Does It Actually Do:
The 'codehud-cli' operates as an entry point for var
🔍 DEBUG: Sentence 7: score=13.5 -  Its main purpose is to provide an unified interface with 7+ commands matching P
🔍 DEBUG: Sentence 8: score=6.0 -  The CLI application also provides features for managing developer notes and tra
🔍 DEBUG: Sentence 9: score=0.5 -  It offers an option to export summary reports of all analyses, visualizations, 
🔍 DEBUG: Keeping 6 out of 10 sentences
🔍 DEBUG: Denoising input: 2297 chars, 305 words
🔍 DEBUG: Found 16 sentences
🔍 DEBUG: Sentence 0: score=6.5 - Overall Architecture:
The 'codehud-core' crate forms a core part of the CodeHUD 
🔍 DEBUG: Sentence 1: score=2.0 -  It is designed with modular architecture, ensuring high cohesion and low coupli
🔍 DEBUG: Sentence 2: score=4.5 -  The crate has clear dependencies on other crates like 'codehud-cli', which prov
🔍 DEBUG: Sentence 3: score=3.5 - 

What Does It Actually Do:
The primary function of the 'codehud-core' crate is 
🔍 DEBUG: Sentence 4: score=8.5 -  This includes tasks such as automatic dependency analysis, runtime profiling, s
🔍 DEBUG: Sentence 5: score=0.5 - 

The extractors work harmoniously to provide a comprehensive understanding of t
🔍 DEBUG: Sentence 6: score=-0.5 -  For instance, dependencies
🔍 DEBUG: Sentence 7: score=2.5 - rs assists with automatic dependency analysis across different programming langu
🔍 DEBUG: Sentence 8: score=2.5 - rs provides insights into execution patterns and resource usage
🔍 DEBUG: Sentence 9: score=0.5 -  Together, these tools aid developers in comprehending the impact of their chang
🔍 DEBUG: Sentence 10: score=6.0 - 

The crate also includes pattern detection rules to identify anti-patterns, cod
🔍 DEBUG: Sentence 11: score=3.5 -  It employs a cache mechanism for storing and retrieving data from static analys
🔍 DEBUG: Sentence 12: score=1.5 - , ensuring efficient resource usage during code analyses
🔍 DEBUG: Sentence 13: score=4.5 - 

The crate orchestrates all these analyses into an unified pipeline which can b
🔍 DEBUG: Sentence 14: score=4.5 -  It also provides an interface to users for viewing aggregate metrics like cyclo
🔍 DEBUG: Sentence 15: score=2.0 -  

This makes 'codehud-core' crate an essential part of the CodeHUD project that
🔍 DEBUG: Keeping 10 out of 16 sentences
🔍 DEBUG: Denoising input: 2645 chars, 364 words
🔍 DEBUG: Found 14 sentences
🔍 DEBUG: Sentence 0: score=2.5 - ## Overall Architecture
The 'codehud-gui' crate acts as a central hub for managi
🔍 DEBUG: Sentence 1: score=6.0 -  The main design pattern used is Modular Architecture where each sub-crate serve
🔍 DEBUG: Sentence 2: score=4.0 -  This modularity allows easy updates, maintenance, or troubleshooting of individ
🔍 DEBUG: Sentence 3: score=4.5 - 

The crate has clear dependencies on other crates like 'codehud-analysis', 'cod
🔍 DEBUG: Sentence 4: score=0.5 -  It also employs a security architecture where user credentials are encrypted us
🔍 DEBUG: Sentence 5: score=0.5 -  A cache architecture is used to improve performance by storing frequently acces
🔍 DEBUG: Sentence 6: score=10.5 - 

The GUI sub-crate follows an MVC (Model-View-Controller) pattern where the Mod
🔍 DEBUG: Sentence 7: score=6.5 -  The View presents the user interface and updates based on changes in the Model,
🔍 DEBUG: Sentence 8: score=6.0 - 

The crate's structure is organized into modules representing different functio
🔍 DEBUG: Sentence 9: score=11.5 -  These include 'state', which manages the core engine, LLM (Language Model) engi
🔍 DEBUG: Sentence 10: score=3.5 - 

## What Does It Actually Do
The main functionality of the CodeHUD GUI is to pr
🔍 DEBUG: Sentence 11: score=11.5 -  The crate provides various components such as Analysis Controller for handling 
🔍 DEBUG: Sentence 12: score=3.5 -  

The GUI provides an interactive environment where users can execute commands 
🔍 DEBUG: Sentence 13: score=0.5 -  It also presents a dashboard for visualizing overall codebase health status wit
🔍 DEBUG: Keeping 9 out of 14 sentences
🔍 DEBUG: Denoising input: 2244 chars, 311 words
🔍 DEBUG: Found 18 sentences
🔍 DEBUG: Sentence 0: score=4.5 - Overall Architecture:
The 'codehud-llm' crate, as a subcrate within CodeHUD proj
🔍 DEBUG: Sentence 1: score=3.0 -  It combines modularity and security features, leveraging Rust's strong memory s
🔍 DEBUG: Sentence 2: score=5.5 -  The crate also incorporates caching for enhancing efficiency and reducing redun
🔍 DEBUG: Sentence 3: score=3.0 -  Moreover, it includes robust testing infrastructure for ensuring reliability an
🔍 DEBUG: Sentence 4: score=0.5 -  Logging is used to track activities and issues during runtime
🔍 DEBUG: Sentence 5: score=2.5 -  Monitoring ensures that real-time insights into usage patterns are available
🔍 DEBUG: Sentence 6: score=3.5 -  This modular architecture allows for easier maintenance, updates, or adding new
🔍 DEBUG: Sentence 7: score=4.5 - 

What Does It Actually Do:
The primary feature of 'codehud-llm' is its integrat
🔍 DEBUG: Sentence 8: score=7.5 -  Specifically, it provides an efficient way to analyze Rust projects using nativ
🔍 DEBUG: Sentence 9: score=3.5 -  This is achieved through a suite of code analysis tools that manage and analyze
🔍 DEBUG: Sentence 10: score=0.5 - , configuring installation order, rendering certain sections in the render
🔍 DEBUG: Sentence 11: score=-0.5 - rs header file
🔍 DEBUG: Sentence 12: score=3.5 - 

The crate offers comprehensive insights into Rust projects
🔍 DEBUG: Sentence 13: score=7.5 -  It identifies entry points, manages imports and exports, handles I/O operations
🔍 DEBUG: Sentence 14: score=2.5 -  The toolset is designed to assist Rust developers in understanding and improvin
🔍 DEBUG: Sentence 15: score=6.0 - 

Moreover, the crate includes a comprehensive suite of tests ensuring reliabili
🔍 DEBUG: Sentence 16: score=9.0 -  These tests validate bug fix success rate, zero-degradation compatibility, elim
🔍 DEBUG: Sentence 17: score=2.5 -  This testing infrastructure ensures that all components work correctly together
🔍 DEBUG: Keeping 11 out of 18 sentences
🔍 DEBUG: Denoising input: 2167 chars, 300 words
🔍 DEBUG: Found 15 sentences
🔍 DEBUG: Sentence 0: score=5.0 - Overall Architecture:
The 'codehud-realtime' crate, as a Rust library, forms an 
🔍 DEBUG: Sentence 1: score=6.0 -  It is designed as a real-time file monitoring system that operates at the heart
🔍 DEBUG: Sentence 2: score=7.5 -  This means it provides continuous analysis and tracking of files in a codebase,
🔍 DEBUG: Sentence 3: score=4.0 -  The crate's architecture adheres to design patterns such as Observer pattern fo
🔍 DEBUG: Sentence 4: score=4.5 -  It is dependent on other crates like 'codehud-analysis', 'codehud-core', etc
🔍 DEBUG: Sentence 5: score=1.5 - , providing the necessary functionalities
🔍 DEBUG: Sentence 6: score=6.5 - 

What Does It Actually Do:
The primary function of this Rust library is to prov
🔍 DEBUG: Sentence 7: score=7.5 -  This functionality allows for incremental analysis, where only modified or chan
🔍 DEBUG: Sentence 8: score=7.5 -  

This crate offers features like debouncing (handling rapid file modifications
🔍 DEBUG: Sentence 9: score=2.0 -  It also supports various types of codebase analyses like topology (dependency) 
🔍 DEBUG: Sentence 10: score=-0.5 - )
🔍 DEBUG: Sentence 11: score=10.0 -  

The crate provides functionality to set up a configuration for the real-time 
🔍 DEBUG: Sentence 12: score=6.0 -  The library includes event processing loops, debounced batch processors, releva
🔍 DEBUG: Sentence 13: score=2.5 -  This makes it versatile for various use cases in software development like cont
🔍 DEBUG: Sentence 14: score=7.0 -  The crate also supports skipping certain files during incremental analyses base
🔍 DEBUG: Keeping 9 out of 15 sentences
🔍 DEBUG: Denoising input: 1904 chars, 261 words
🔍 DEBUG: Found 11 sentences
🔍 DEBUG: Sentence 0: score=3.0 - Overall Architecture:
The 'codehud-transform' crate forms a significant part of 
🔍 DEBUG: Sentence 1: score=6.0 -  It utilizes a modular approach to design, with each functionality being encapsu
🔍 DEBUG: Sentence 2: score=3.5 -  This modular nature facilitates easy integration with other components and allo
🔍 DEBUG: Sentence 3: score=10.0 -  The crate is designed around Rust's powerful parsing libraries like nom, which 
🔍 DEBUG: Sentence 4: score=9.0 - 

Functionality:
The primary function of the 'codehud-transform' subcrate is to 
🔍 DEBUG: Sentence 5: score=7.0 - 

Through these modules, the crate enables complex transformations on Rust sourc
🔍 DEBUG: Sentence 6: score=4.5 -  It also provides a history tracking mechanism for easy rollback capabilities in
🔍 DEBUG: Sentence 7: score=2.5 -  The crate integrates with Git for backups ensuring reliability and reproducibil
🔍 DEBUG: Sentence 8: score=4.0 - 

The modular nature of this subcrate allows it to be adapted easily to new prog
🔍 DEBUG: Sentence 9: score=0.5 -  This makes it a versatile tool that can cater to various needs in code transfor
🔍 DEBUG: Sentence 10: score=3.0 -  

In essence, 'codehud-transform' serves as an indispensable component of our R
🔍 DEBUG: Keeping 7 out of 11 sentences
🔍 DEBUG: Denoising input: 1646 chars, 235 words
🔍 DEBUG: Found 17 sentences
🔍 DEBUG: Sentence 0: score=2.5 - ## Overall Architecture
The 'codehud-tui' crate follows a modular architecture w
🔍 DEBUG: Sentence 1: score=2.5 -  It employs design patterns such as Command pattern for handling user input, and
🔍 DEBUG: Sentence 2: score=3.5 -  Dependencies between these modules are managed using Rust's package manager Car
🔍 DEBUG: Sentence 3: score=7.5 -  The crate is structured in a way that separates core functionalities from comma
🔍 DEBUG: Sentence 4: score=7.5 - 

## What Does It Actually Do
The 'codehud-tui' crate serves as the user interfa
🔍 DEBUG: Sentence 5: score=5.5 -  The terminal-based TUI provides a command line interface that allows users to s
🔍 DEBUG: Sentence 6: score=1.5 - 

The main features are: 
1
🔍 DEBUG: Sentence 7: score=2.5 -  Provides interactive TUI modes for better user experience
🔍 DEBUG: Sentence 8: score=1.5 -  It checks terminal capabilities like color support and ensures zero degradation
🔍 DEBUG: Sentence 9: score=-0.5 - 
2
🔍 DEBUG: Sentence 10: score=4.0 -  Supports exporting analysis data in JSON format for later use or sharing with o
🔍 DEBUG: Sentence 11: score=-0.5 - 
3
🔍 DEBUG: Sentence 12: score=0.5 -  Offers various views such as Priority View, Security View, and Quality View to 
🔍 DEBUG: Sentence 13: score=-0.5 - 
4
🔍 DEBUG: Sentence 14: score=4.0 -  Provides features like navigation, filtering, sorting, syntax highlighting, hea
🔍 DEBUG: Sentence 15: score=-0.5 -  
5
🔍 DEBUG: Sentence 16: score=6.0 -  Includes a visualization engine for rendering analysis results as charts or gra
🔍 DEBUG: Keeping 11 out of 17 sentences
🔍 DEBUG: Denoising input: 1738 chars, 253 words
🔍 DEBUG: Found 10 sentences
🔍 DEBUG: Sentence 0: score=7.5 - Overall Architecture:
The 'codehud-utils' crate fits in the larger CodeHUD proje
🔍 DEBUG: Sentence 1: score=3.5 -  It adheres to Rust's modular design principles, with each subcrate focusing on 
🔍 DEBUG: Sentence 2: score=4.0 -  The crate is designed in a way that it can be easily integrated into any CodeHU
🔍 DEBUG: Sentence 3: score=3.5 - 

The dependencies within the 'codehud-utils' crate are managed using Rust’s b
🔍 DEBUG: Sentence 4: score=2.5 -  It relies on various third-party libraries such as tracing and serde for loggin
🔍 DEBUG: Sentence 5: score=7.5 -  The structure of the project is based on a multi-file module system, with each 
🔍 DEBUG: Sentence 6: score=7.0 - 

What Does It Actually Do:
The 'codehud-utils' crate provides utility functions
🔍 DEBUG: Sentence 7: score=9.5 -  The main purpose of this crate is to replicate behaviors and functionalities si
🔍 DEBUG: Sentence 8: score=0.5 - 

It offers a core set of utilities that are used across CodeHUD applications, r
🔍 DEBUG: Sentence 9: score=1.5 -  This makes it an invaluable tool for developers working on Rust projects, provi
🔍 DEBUG: Keeping 6 out of 10 sentences
🔍 DEBUG: Denoising input: 1751 chars, 233 words
🔍 DEBUG: Found 11 sentences
🔍 DEBUG: Sentence 0: score=2.5 - Overall Architecture:
The 'codehud-viz' crate, as a subcrate within the CodeHUD 
🔍 DEBUG: Sentence 1: score=8.0 -  It leverages various features of the broader system, such as caching and securi
🔍 DEBUG: Sentence 2: score=2.5 -  The design pattern employed here is the Model-View-Controller (MVC) which helps
🔍 DEBUG: Sentence 3: score=2.0 - 

The 'codehud-viz' subcrate depends on multiple external dependencies including
🔍 DEBUG: Sentence 4: score=3.0 -  It also utilizes features of the Rust programming language like concurrency thr
🔍 DEBUG: Sentence 5: score=1.0 - , to ensure robustness and efficiency
🔍 DEBUG: Sentence 6: score=2.0 - 

What Does It Actually Do:
The main purpose of 'codehud-viz' is to provide visu
🔍 DEBUG: Sentence 7: score=3.5 -  This includes generating various types of visualizations from the data extracte
🔍 DEBUG: Sentence 8: score=6.5 -  

In essence, this crate provides a way to understand complex software systems 
🔍 DEBUG: Sentence 9: score=0.5 -  It also offers data export capabilities in various output formats as well as te
🔍 DEBUG: Sentence 10: score=0.0 -  This makes it an essential tool for any developer or software analyst who needs
🔍 DEBUG: Keeping 7 out of 11 sentences
✅ Intelligent denoising complete: reduced from 4937 to 3477 total tokens
🧠 Starting multi-pass reasoning (4 passes)...
📋 Pass 1/4: Extracting facts...
✅ Pass 1 complete
🗂️  Pass 2/4: Grouping into functional layers...
