warning: unused import: `std::collections::HashMap`
  --> codehud-core/src/models/view_types.rs:10:5
   |
10 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `anyhow::Context`
  --> codehud-core/src/extractors/dependencies.rs:19:5
   |
19 | use anyhow::Context;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `FileMetrics`
 --> codehud-core/src/extractors/issues.rs:6:32
  |
6 | use super::{BaseDataExtractor, FileMetrics};
  |                                ^^^^^^^^^^^

warning: unused imports: `Deserialize` and `Serialize`
  --> codehud-core/src/extractors/issues.rs:11:13
   |
11 | use serde::{Serialize, Deserialize};
   |             ^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `ExternalTool`
 --> codehud-core/src/extractors/quality.rs:4:50
  |
4 | use crate::external_tools::{ExternalToolManager, ExternalTool};
  |                                                  ^^^^^^^^^^^^

warning: unused import: `ExternalTool`
 --> codehud-core/src/extractors/security.rs:7:50
  |
7 | use crate::external_tools::{ExternalToolManager, ExternalTool};
  |                                                  ^^^^^^^^^^^^

warning: unused import: `warn`
  --> codehud-core/src/extractors/security.rs:17:22
   |
17 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused imports: `Duration` and `Instant`
  --> codehud-core/src/extractors/runtime_profiler.rs:13:17
   |
13 | use std::time::{Duration, Instant};
   |                 ^^^^^^^^  ^^^^^^^

warning: unused import: `Command`
 --> codehud-core/src/external_tools/mod.rs:7:20
  |
7 | use std::process::{Command, Stdio};
  |                    ^^^^^^^

warning: unused import: `Context`
  --> codehud-core/src/external_tools/mod.rs:11:22
   |
11 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/mypy.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/vulture.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/coverage.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/git.rs:10:22
   |
10 | use tracing::{debug, warn};
   |                      ^^^^

warning: unused import: `warn`
  --> codehud-core/src/external_tools/cargo_test.rs:9:22
   |
9  | use tracing::{debug, warn};
   |                      ^^^^
   |
help: if this is a test module, consider adding a `#[cfg(test)]` to the containing module
  --> codehud-core/src/external_tools/mod.rs:27:1
   |
27 | pub mod cargo_test;
   | ^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> codehud-core/src/graph/mod.rs:12:33
   |
12 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused imports: `connected_components` and `has_path_connecting`
  --> codehud-core/src/graph/mod.rs:15:22
   |
15 | use petgraph::algo::{connected_components, has_path_connecting};
   |                      ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `EdgeRef` and `IntoNodeReferences`
  --> codehud-core/src/graph/mod.rs:16:23
   |
16 | use petgraph::visit::{EdgeRef, IntoNodeReferences};
   |                       ^^^^^^^  ^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
  --> codehud-core/src/graph/mod.rs:18:22
   |
18 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `has_path_connecting`
 --> codehud-core/src/graph/analyzer.rs:6:44
  |
6 | use petgraph::algo::{connected_components, has_path_connecting};
  |                                            ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
 --> codehud-core/src/graph/analyzer.rs:8:22
  |
8 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `lazy_static::lazy_static`
  --> codehud-core/src/query_engine.rs:19:5
   |
19 | use lazy_static::lazy_static;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> codehud-core/src/analysis/view_generator.rs:8:5
  |
8 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `import_graph`
   --> codehud-core/src/extractors/dependencies.rs:474:41
    |
474 |     fn analyze_coupling_strength(&self, import_graph: &HashMap<String, HashSet<String>>, internal_imports: &HashMap<String, HashSet<Strin...
    |                                         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_import_graph`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `file_path`
   --> codehud-core/src/extractors/dependencies.rs:607:14
    |
607 |         for (file_path, imports) in import_graph {
    |              ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_file_path`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:212:9
    |
212 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:246:9
    |
246 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:274:9
    |
274 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `edges`
   --> codehud-core/src/extractors/flow.rs:306:9
    |
306 |         edges: &mut Vec<DataFlowEdge>,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: variable does not need to be mutable
   --> codehud-core/src/extractors/quality.rs:755:25
    |
755 |                     let mut issues = extractor.detect_quality_issues(file_path, &file_analyzer, &lines);
    |                         ----^^^^^^
    |                         |
    |                         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `mat`
   --> codehud-core/src/extractors/security.rs:412:21
    |
412 |                 for mat in pattern.find_iter(line) {
    |                     ^^^ help: if this is intentional, prefix it with an underscore: `_mat`

warning: value assigned to `severity` is never read
   --> codehud-core/src/extractors/runtime_profiler.rs:257:21
    |
257 |             let mut severity = "minor";
    |                     ^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: value assigned to `impact_score` is never read
   --> codehud-core/src/extractors/runtime_profiler.rs:258:21
    |
258 |             let mut impact_score = 0.0;
    |                     ^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `end`
   --> codehud-core/src/external_tools/ripgrep.rs:165:25
    |
165 |                     let end = first_match["end"].as_u64().unwrap_or(0) as u32;
    |                         ^^^ help: if this is intentional, prefix it with an underscore: `_end`

warning: unused variable: `source`
   --> codehud-core/src/query_engine.rs:704:9
    |
704 |         source: &str
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `quality_data`
   --> codehud-core/src/analysis/mod.rs:334:37
    |
334 | ...                   quality_data: &Value,
    |                       ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_quality_data`

warning: methods `extract_function_name`, `extract_class_name`, and `extract_dependency` are never used
   --> codehud-core/src/extractors/topology.rs:443:8
    |
23  | impl TopologyExtractor {
    | ---------------------- methods in this implementation
...
443 |     fn extract_function_name(&self, line: &str) -> Option<String> {
    |        ^^^^^^^^^^^^^^^^^^^^^
...
456 |     fn extract_class_name(&self, line: &str) -> Option<String> {
    |        ^^^^^^^^^^^^^^^^^^
...
466 |     fn extract_dependency(&self, line: &str) -> Option<String> {
    |        ^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: field `codebase_path` is never read
   --> codehud-core/src/extractors/topology.rs:719:5
    |
717 | struct PythonAstAnalyzer {
    |        ----------------- field in this struct
718 |     file_path: String,
719 |     codebase_path: PathBuf,
    |     ^^^^^^^^^^^^^

warning: methods `visit_async_function_def` and `visit_import_from` are never used
   --> codehud-core/src/extractors/topology.rs:787:8
    |
726 | impl PythonAstAnalyzer {
    | ---------------------- methods in this implementation
...
787 |     fn visit_async_function_def(&mut self, node: tree_sitter::Node, source: &[u8]) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
843 |     fn visit_import_from(&mut self, node: tree_sitter::Node, source: &[u8]) {
    |        ^^^^^^^^^^^^^^^^^

warning: field `external_tools` is never read
  --> codehud-core/src/extractors/evolution.rs:63:5
   |
60 | pub struct EvolutionExtractor {
   |            ------------------ field in this struct
...
63 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/flow.rs:60:5
   |
57 | pub struct FlowExtractor {
   |            ------------- fields in this struct
...
60 |     parser: Parser,
   |     ^^^^^^
61 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/flow.rs:14:8
   |
14 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `file_path` is never read
  --> codehud-core/src/extractors/orphaned_files.rs:28:5
   |
27 | struct FileUsage {
   |        --------- field in this struct
28 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `FileUsage` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `parser` is never read
  --> codehud-core/src/extractors/orphaned_files.rs:39:5
   |
36 | pub struct OrphanedFilesExtractor {
   |            ---------------------- field in this struct
...
39 |     parser: Parser,
   |     ^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/orphaned_files.rs:11:8
   |
11 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/performance.rs:40:5
   |
37 | pub struct PerformanceExtractor {
   |            -------------------- fields in this struct
...
40 |     parser: Parser,
   |     ^^^^^^
41 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: field `codebase_path` is never read
   --> codehud-core/src/extractors/performance.rs:318:5
    |
316 | struct PerformanceAstAnalyzer {
    |        ---------------------- field in this struct
317 |     file_path: String,
318 |     codebase_path: PathBuf,
    |     ^^^^^^^^^^^^^
    |
    = note: `PerformanceAstAnalyzer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `description` is never read
   --> codehud-core/src/extractors/performance.rs:349:5
    |
345 | struct ExpensiveOperation {
    |        ------------------ field in this struct
...
349 |     description: String,
    |     ^^^^^^^^^^^
    |
    = note: `ExpensiveOperation` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `line`, `function_name`, and `has_termination_check` are never read
   --> codehud-core/src/extractors/performance.rs:354:5
    |
353 | struct RecursiveCall {
    |        ------------- fields in this struct
354 |     line: usize,
    |     ^^^^
355 |     function_name: String,
    |     ^^^^^^^^^^^^^
356 |     has_termination_check: bool,
    |     ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `RecursiveCall` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/performance.rs:12:8
   |
12 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `external_tools` is never read
  --> codehud-core/src/extractors/quality.rs:22:5
   |
18 | pub struct QualityExtractor {
   |            ---------------- field in this struct
...
22 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: field `end_line` is never read
  --> codehud-core/src/extractors/quality.rs:54:5
   |
49 | struct FunctionMetrics {
   |        --------------- field in this struct
...
54 |     end_line: usize,
   |     ^^^^^^^^
   |
   = note: `FunctionMetrics` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: fields `lines` and `end_line` are never read
  --> codehud-core/src/extractors/quality.rs:62:5
   |
59 | struct ClassMetrics {
   |        ------------ fields in this struct
...
62 |     lines: usize,
   |     ^^^^^
63 |     start_line: usize,
64 |     end_line: usize,
   |     ^^^^^^^^
   |
   = note: `ClassMetrics` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: methods `analyze_file_quality`, `run_external_tools_analysis`, and `run_external_tools` are never used
   --> codehud-core/src/extractors/quality.rs:129:14
    |
90  | impl QualityExtractor {
    | --------------------- methods in this implementation
...
129 |     async fn analyze_file_quality(&mut self, file_path: &Path) -> Result<Option<Value>> {
    |              ^^^^^^^^^^^^^^^^^^^^
...
592 |     async fn run_external_tools_analysis(&self, file_path: &Path) -> Result<Vec<Value>> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
690 |     fn run_external_tools(&self) -> HashMap<String, Value> {
    |        ^^^^^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/quality.rs:15:8
   |
15 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:34:5
   |
33 | struct SecurityVulnerability {
   |        --------------------- field in this struct
34 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `SecurityVulnerability` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:46:5
   |
45 | struct SecurityIssue {
   |        ------------- field in this struct
46 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `SecurityIssue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:56:5
   |
55 | struct DangerousFunctionUsage {
   |        ---------------------- field in this struct
56 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `DangerousFunctionUsage` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:65:5
   |
64 | struct SensitiveDataExposure {
   |        --------------------- field in this struct
65 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `SensitiveDataExposure` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `file_path` is never read
  --> codehud-core/src/extractors/security.rs:74:5
   |
73 | struct FilePermissionIssue {
   |        ------------------- field in this struct
74 |     file_path: String,
   |     ^^^^^^^^^
   |
   = note: `FilePermissionIssue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `external_tools` is never read
  --> codehud-core/src/extractors/security.rs:85:5
   |
81 | pub struct SecurityExtractor {
   |            ----------------- field in this struct
...
85 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: method `get_function_severity` is never used
   --> codehud-core/src/extractors/security.rs:493:8
    |
91  | impl SecurityExtractor {
    | ---------------------- method in this implementation
...
493 |     fn get_function_severity(&self, function_name: &str) -> String {
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/security.rs:20:8
   |
20 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/testing.rs:70:5
   |
67 | pub struct TestingExtractor {
   |            ---------------- fields in this struct
...
70 |     parser: Parser,
   |     ^^^^^^
71 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/testing.rs:15:8
   |
15 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: fields `parser` and `external_tools` are never read
  --> codehud-core/src/extractors/runtime_profiler.rs:65:5
   |
62 | pub struct RuntimeProfiler {
   |            --------------- fields in this struct
...
65 |     parser: Parser,
   |     ^^^^^^
66 |     external_tools: ExternalToolManager,
   |     ^^^^^^^^^^^^^^

warning: function `tree_sitter_rust` is never used
  --> codehud-core/src/extractors/runtime_profiler.rs:16:8
   |
16 |     fn tree_sitter_rust() -> Language;
   |        ^^^^^^^^^^^^^^^^

warning: field `codebase_path` is never read
  --> codehud-core/src/external_tools/mod.rs:42:5
   |
31 | pub struct ExternalToolManager {
   |            ------------------- field in this struct
...
42 |     codebase_path: PathBuf,
   |     ^^^^^^^^^^^^^

warning: field `codebase_path` is never read
   --> codehud-core/src/external_tools/mod.rs:286:5
    |
278 | pub struct RustToolManager {
    |            --------------- field in this struct
...
286 |     codebase_path: PathBuf,
    |     ^^^^^^^^^^^^^

warning: field `metrics` is never read
   --> codehud-core/src/external_tools/bandit.rs:225:9
    |
223 | struct BanditJsonOutput {
    |        ---------------- field in this struct
224 |     pub results: Vec<BanditJsonResult>,
225 |     pub metrics: BanditMetrics,
    |         ^^^^^^^
    |
    = note: `BanditJsonOutput` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: fields `version` and `branch_coverage` are never read
   --> codehud-core/src/external_tools/coverage.rs:215:9
    |
213 | struct CoverageMeta {
    |        ------------ fields in this struct
214 |     pub timestamp: String,
215 |     pub version: String,
    |         ^^^^^^^
216 |     pub branch_coverage: Option<bool>,
    |         ^^^^^^^^^^^^^^^
    |
    = note: `CoverageMeta` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: fields `percent_covered` and `percent_covered_display` are never read
   --> codehud-core/src/external_tools/coverage.rs:230:9
    |
227 | struct CoverageFileSummary {
    |        ------------------- fields in this struct
...
230 |     pub percent_covered: f64,
    |         ^^^^^^^^^^^^^^^
...
233 |     pub percent_covered_display: Option<String>,
    |         ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `CoverageFileSummary` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: `codehud-core` (lib) generated 72 warnings (run `cargo fix --lib -p codehud-core` to apply 24 suggestions)
warning: unused imports: `LlmConfig` and `ModelType`
 --> codehud-llm/src/ffi.rs:7:13
  |
7 | use crate::{LlmConfig, ModelType, LlmResult, LlmError, MistakeType, CriticalMistake, CodeLocation};
  |             ^^^^^^^^^  ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `std::collections::HashMap`
  --> codehud-llm/src/ffi.rs:11:5
   |
11 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `GpuType` and `LlmError`
 --> codehud-llm/src/native_stub.rs:6:35
  |
6 | use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError};
  |                                   ^^^^^^^             ^^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> codehud-llm/src/native_stub.rs:9:5
  |
9 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::path::PathBuf`
  --> codehud-llm/src/native_stub.rs:10:5
   |
10 | use std::path::PathBuf;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> codehud-llm/src/native_stub.rs:11:5
   |
11 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `tokio::sync::RwLock`
  --> codehud-llm/src/native_stub.rs:12:5
   |
12 | use tokio::sync::RwLock;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `LlmConfig`
  --> codehud-llm/src/structured.rs:11:13
   |
11 | use crate::{LlmConfig, LlmResult, LlmError, ffi::PythonLlmBridge, native_stub::NativeLlmEngine};
   |             ^^^^^^^^^

warning: unused import: `json`
  --> codehud-llm/src/structured.rs:14:25
   |
14 | use serde_json::{Value, json};
   |                         ^^^^

warning: unused import: `LlmError`
 --> codehud-llm/src/critical.rs:7:24
  |
7 | use crate::{LlmResult, LlmError, ffi::PythonLlmBridge};
  |                        ^^^^^^^^

warning: unused import: `LlmError`
 --> codehud-llm/src/monitoring.rs:1:13
  |
1 | use crate::{LlmError, LlmResult};
  |             ^^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> codehud-llm/src/equivalence.rs:9:5
  |
9 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `QueryEngine`
 --> codehud-llm/src/comment_extractor.rs:9:34
  |
9 | use codehud_core::query_engine::{QueryEngine, get_query_engine, SupportedLanguage};
  |                                  ^^^^^^^^^^^

warning: unused import: `PathBuf`
  --> codehud-llm/src/comment_extractor.rs:12:23
   |
12 | use std::path::{Path, PathBuf};
   |                       ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> codehud-llm/src/comment_extractor.rs:13:5
   |
13 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `codehud_core::query_engine::QueryEngine`
  --> codehud-llm/src/file_processor.rs:17:5
   |
17 | use codehud_core::query_engine::QueryEngine;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CleanedFileAnalysis`
 --> codehud-llm/src/extraction_fsm.rs:8:73
  |
8 | use crate::comment_extractor::{CommentExtractor, FileCommentExtraction, CleanedFileAnalysis};
  |                                                                         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> codehud-llm/src/extraction_fsm.rs:14:24
   |
14 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^

warning: unused import: `aho_corasick::AhoCorasick`
 --> codehud-llm/src/denoiser.rs:9:5
  |
9 | use aho_corasick::AhoCorasick;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ProcessorConfig`
 --> codehud-llm/src/crate_summarizer.rs:6:49
  |
6 | use crate::{LlmResult, LlmError, FileProcessor, ProcessorConfig};
  |                                                 ^^^^^^^^^^^^^^^

warning: unused variable: `python_bridge`
   --> codehud-llm/src/structured.rs:317:25
    |
317 |         if let Some(ref python_bridge) = self.python_bridge {
    |                         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_python_bridge`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `enhanced_prompt`
   --> codehud-llm/src/structured.rs:440:13
    |
440 |         let enhanced_prompt = self.build_enhanced_prompt(prompt, constraints);
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_enhanced_prompt`

warning: unused variable: `python_bridge`
   --> codehud-llm/src/structured.rs:708:25
    |
708 |         if let Some(ref python_bridge) = self.python_bridge {
    |                         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_python_bridge`

warning: unused variable: `python_bridge`
   --> codehud-llm/src/critical.rs:316:25
    |
316 |         if let Some(ref python_bridge) = self.python_bridge {
    |                         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_python_bridge`

warning: unused variable: `rule`
   --> codehud-llm/src/critical.rs:519:9
    |
519 |         rule: &DetectionRule,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_rule`

warning: unused variable: `rule`
   --> codehud-llm/src/critical.rs:652:9
    |
652 |         rule: &DetectionRule,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_rule`

warning: unused variable: `rule`
   --> codehud-llm/src/critical.rs:695:9
    |
695 |         rule: &DetectionRule,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_rule`

warning: unused variable: `code`
   --> codehud-llm/src/critical.rs:806:75
    |
806 |     async fn generate_syntax_correction(&self, mistake: &CriticalMistake, code: &str) -> Option<(String, String)> {
    |                                                                           ^^^^ help: if this is intentional, prefix it with an underscore: `_code`

warning: unused variable: `code`
   --> codehud-llm/src/critical.rs:818:77
    |
818 |     async fn generate_security_correction(&self, mistake: &CriticalMistake, code: &str) -> Option<(String, String)> {
    |                                                                             ^^^^ help: if this is intentional, prefix it with an underscore: `_code`

warning: unused variable: `code`
   --> codehud-llm/src/critical.rs:835:80
    |
835 |     async fn generate_performance_correction(&self, mistake: &CriticalMistake, code: &str) -> Option<(String, String)> {
    |                                                                                ^^^^ help: if this is intentional, prefix it with an underscore: `_code`

warning: unused variable: `duration`
   --> codehud-llm/src/file_processor.rs:520:13
    |
520 |         let duration = start_time.elapsed();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_duration`

warning: unused variable: `extraction`
   --> codehud-llm/src/extraction_fsm.rs:313:28
    |
313 |                 file_path, extraction, summary
    |                            ^^^^^^^^^^ help: try ignoring the field: `extraction: _`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:313:40
    |
313 |                 file_path, extraction, summary
    |                                        ^^^^^^^ help: try ignoring the field: `summary: _`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:363:56
    |
363 |              ExtractionEvent::ProjectSummaryComplete { summary }) => {
    |                                                        ^^^^^^^ help: try ignoring the field: `summary: _`

warning: unused variable: `discovered_crates`
   --> codehud-llm/src/extraction_fsm.rs:382:55
    |
382 |              ExtractionEvent::CrateGroupingComplete { discovered_crates }) => {
    |                                                       ^^^^^^^^^^^^^^^^^ help: try ignoring the field: `discovered_crates: _`

warning: unused variable: `project_path`
   --> codehud-llm/src/extraction_fsm.rs:383:21
    |
383 |                 let project_path = match &*state {
    |                     ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_path`

warning: unused variable: `extraction`
   --> codehud-llm/src/extraction_fsm.rs:474:17
    |
474 |             Ok((extraction, summary)) => {
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_extraction`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:474:29
    |
474 |             Ok((extraction, summary)) => {
    |                             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_summary`

warning: unused variable: `summary`
   --> codehud-llm/src/extraction_fsm.rs:804:16
    |
804 |             Ok(summary) => {
    |                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_summary`

warning: unused variable: `index`
    --> codehud-llm/src/extraction_fsm.rs:1365:14
     |
1365 |         for (index, crate_info) in discovered_crates.iter().enumerate() {
     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_index`

warning: unused variable: `index`
    --> codehud-llm/src/extraction_fsm.rs:1392:14
     |
1392 |         for (index, crate_info) in discovered_crates.iter().enumerate() {
     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_index`

warning: unused variable: `index`
    --> codehud-llm/src/extraction_fsm.rs:1419:14
     |
1419 |         for (index, crate_info) in discovered_crates.iter().enumerate() {
     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_index`

warning: variable `total_tokens` is assigned to, but never used
    --> codehud-llm/src/extraction_fsm.rs:1472:17
     |
1472 |         let mut total_tokens = 0;
     |                 ^^^^^^^^^^^^
     |
     = note: consider using `_total_tokens` instead

warning: unused variable: `project_summary`
    --> codehud-llm/src/extraction_fsm.rs:1513:13
     |
1513 |         let project_summary = ProjectSummary {
     |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_summary`

warning: unused variable: `discovered_crates`
    --> codehud-llm/src/extraction_fsm.rs:2043:68
     |
2043 |     async fn generate_final_summary(&self, project_path: &PathBuf, discovered_crates: &[CrateInfo]) -> LlmResult<()> {
     |                                                                    ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_discovered_crates`

warning: variable `total_tokens` is assigned to, but never used
    --> codehud-llm/src/extraction_fsm.rs:2090:17
     |
2090 |         let mut total_tokens = 0;
     |                 ^^^^^^^^^^^^
     |
     = note: consider using `_total_tokens` instead

warning: unused variable: `subcrate_files`
   --> codehud-llm/src/crate_summarizer.rs:452:14
    |
452 |         let (subcrate_files, individual_files) = if let Some(ref subcrates) = subcrate_summaries {
    |              ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_subcrate_files`

warning: unused import: `std::io::Write`
  --> codehud-llm/src/extraction_fsm.rs:17:5
   |
17 | use std::io::Write;
   |     ^^^^^^^^^^^^^^

warning: unused variable: `memory`
   --> codehud-llm/src/conversation.rs:650:13
    |
650 |         let memory = ProjectAnalysisMemory::new();
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_memory`

warning: unused variable: `project_id`
   --> codehud-llm/src/conversation.rs:676:13
    |
676 |         let project_id = format!("project:{}", project_path);
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_id`

warning: unused variable: `project_path`
   --> codehud-llm/src/conversation.rs:682:45
    |
682 |     pub fn update_project_memory(&mut self, project_path: &str, crate_summary: &CrateSummary) -> LlmResult<()> {
    |                                             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_project_path`

warning: unused variable: `language`
   --> codehud-llm/src/comment_extractor.rs:264:9
    |
264 |         language: &str,
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_language`

warning: unused variable: `file_path`
   --> codehud-llm/src/comment_extractor.rs:295:9
    |
295 |         file_path: &Path,
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_file_path`

warning: unused variable: `end_byte`
   --> codehud-llm/src/comment_extractor.rs:557:70
    |
557 |     fn extract_code_context(&self, content: &str, start_byte: usize, end_byte: usize) -> Option<CodeContext> {
    |                                                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_end_byte`

warning: multiple fields are never read
  --> codehud-llm/src/ffi.rs:20:5
   |
18 | pub struct PythonLlmBridge {
   |            --------------- fields in this struct
19 |     /// Python interpreter instance
20 |     python: Python<'static>,
   |     ^^^^^^
...
24 |     pytorch_pipeline: PyObject,
   |     ^^^^^^^^^^^^^^^^
...
34 |     self_verification: PyObject,
   |     ^^^^^^^^^^^^^^^^^
35 |     /// Python continuous test monitor module
36 |     test_monitor: PyObject,
   |     ^^^^^^^^^^^^
37 |     /// Python behavior analysis module
38 |     behavior_analysis: PyObject,
   |     ^^^^^^^^^^^^^^^^^
...
42 |     guardrails: PyObject,
   |     ^^^^^^^^^^
43 |     /// Python OpenHands bridge module
44 |     openhands_bridge: PyObject,
   |     ^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: methods `get_call_wrapper`, `safe_python_call`, and `safe_python_call_async` are never used
   --> codehud-llm/src/ffi.rs:847:8
    |
845 | impl PythonLlmBridge {
    | -------------------- methods in this implementation
846 |     /// Get the Python call wrapper for this bridge
847 |     fn get_call_wrapper(&self) -> PythonCallWrapper {
    |        ^^^^^^^^^^^^^^^^
...
852 |     fn safe_python_call<F, R>(&self, method_name: &str, f: F) -> LlmResult<R>
    |        ^^^^^^^^^^^^^^^^
...
861 |     async fn safe_python_call_async<F, R>(&self, method_name: &str, f: F) -> LlmResult<R>
    |              ^^^^^^^^^^^^^^^^^^^^^^

warning: multiple fields are never read
   --> codehud-llm/src/ollama.rs:200:5
    |
199 | struct OllamaResponse {
    |        -------------- fields in this struct
200 |     model: String,
    |     ^^^^^
201 |     created_at: String,
    |     ^^^^^^^^^^
202 |     response: String,
203 |     done: bool,
    |     ^^^^
...
207 |     total_duration: Option<u64>,
    |     ^^^^^^^^^^^^^^
208 |     #[serde(skip_serializing_if = "Option::is_none")]
209 |     load_duration: Option<u64>,
    |     ^^^^^^^^^^^^^
210 |     #[serde(skip_serializing_if = "Option::is_none")]
211 |     prompt_eval_count: Option<i32>,
    |     ^^^^^^^^^^^^^^^^^
212 |     #[serde(skip_serializing_if = "Option::is_none")]
213 |     eval_count: Option<i32>,
    |     ^^^^^^^^^^
    |
    = note: `OllamaResponse` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `native_engine` is never read
  --> codehud-llm/src/structured.rs:67:5
   |
61 | pub struct StructuredCodeGenerator {
   |            ----------------------- field in this struct
...
67 |     native_engine: Option<NativeLlmEngine>,
   |     ^^^^^^^^^^^^^

warning: methods `parse_comment_from_highlight`, `parse_comment_from_capture`, `fallback_comment_extraction`, and `determine_comment_type` are never used
   --> codehud-llm/src/comment_extractor.rs:363:8
    |
173 | impl CommentExtractor {
    | --------------------- methods in this implementation
...
363 |     fn parse_comment_from_highlight(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
401 |     fn parse_comment_from_capture(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
412 |     fn fallback_comment_extraction(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
540 |     fn determine_comment_type(&self, raw_comment: &str) -> CommentType {
    |        ^^^^^^^^^^^^^^^^^^^^^^

warning: fields `llm_pipeline`, `constitutional_ai`, `conversation_tracker`, and `llm_monitor` are never read
   --> codehud-llm/src/file_processor.rs:247:5
    |
243 | pub struct FileProcessor {
    |            ------------- fields in this struct
...
247 |     llm_pipeline: Arc<OllamaPipeline>,
    |     ^^^^^^^^^^^^
...
251 |     constitutional_ai: Arc<ConstitutionalAI>,
    |     ^^^^^^^^^^^^^^^^^
252 |     /// Conversation tracker for context management
253 |     conversation_tracker: Arc<ConversationTracker>,
    |     ^^^^^^^^^^^^^^^^^^^^
254 |     /// LLM performance monitor
255 |     llm_monitor: Arc<LlmMonitor>,
    |     ^^^^^^^^^^^

warning: field `patterns` is never read
   --> codehud-llm/src/extraction_fsm.rs:203:5
    |
195 | struct ProjectContext {
    |        -------------- field in this struct
...
203 |     patterns: Vec<String>,
    |     ^^^^^^^^
    |
    = note: `ProjectContext` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `process_single_project_file`, `generate_comprehensive_project_summary`, and `generate_comprehensive_project_summary_from_files` are never used
   --> codehud-llm/src/extraction_fsm.rs:627:14
    |
224 | impl CommentExtractionFSM {
    | ------------------------- methods in this implementation
...
627 |     async fn process_single_project_file(&self, file_path: PathBuf) -> LlmResult<()> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
872 |     async fn generate_comprehensive_project_summary(&self, all_extractions: &[FileCommentExtraction]) -> LlmResult<String> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
905 |     async fn generate_comprehensive_project_summary_from_files(&self, file_summaries: &[(String, String)]) -> LlmResult<String> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: field `denoiser` is never read
  --> codehud-llm/src/crate_summarizer.rs:96:5
   |
92 | pub struct CrateSummarizer {
   |            --------------- field in this struct
...
96 |     denoiser: LlmContextDenoiser,
   |     ^^^^^^^^

warning: methods `build_context_aware_prompt` and `build_reduced_context_prompt` are never used
   --> codehud-llm/src/crate_summarizer.rs:669:8
    |
329 | impl CrateSummarizer {
    | -------------------- methods in this implementation
...
669 |     fn build_context_aware_prompt(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
743 |     fn build_reduced_context_prompt(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: fields `name` and `all_files` are never read
    --> codehud-llm/src/crate_summarizer.rs:1269:5
     |
1268 | struct SubcrateNode {
     |        ------------ fields in this struct
1269 |     name: String,
     |     ^^^^
1270 |     direct_files: Vec<CleanedFileData>,
1271 |     all_files: Vec<CleanedFileData>,
     |     ^^^^^^^^^
     |
     = note: `SubcrateNode` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: unused import: `runtime_profiler::RuntimeProfiler`
  --> codehud-analysis/src/pipeline.rs:19:9
   |
19 |         runtime_profiler::RuntimeProfiler,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: field `config` is never read
  --> codehud-analysis/src/pipeline.rs:35:5
   |
34 | pub struct DirectAnalysisPipeline {
   |            ---------------------- field in this struct
35 |     config: CoreConfig,
   |     ^^^^^^
   |
   = note: `DirectAnalysisPipeline` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: unused import: `Context`
 --> codehud-viz/src/lib.rs:8:14
  |
8 | use anyhow::{Context, Result};
  |              ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `Axis`, `Cell`, `Chart`, `Clear`, `Dataset`, `Line`, `Row`, `Span`, `Table`, `Terminal`, `Text`, and `symbols`
  --> codehud-viz/src/lib.rs:19:5
   |
19 |     symbols,
   |     ^^^^^^^
20 |     text::{Line, Span, Text},
   |            ^^^^  ^^^^  ^^^^
21 |     widgets::{
22 |         Axis, Block, Borders, Chart, Dataset, Gauge, List, ListItem,
   |         ^^^^                  ^^^^^  ^^^^^^^
23 |         Paragraph, BarChart, Clear, Table, Row, Cell, Wrap
   |                              ^^^^^  ^^^^^  ^^^  ^^^^
24 |     },
25 |     Frame, Terminal,
   |            ^^^^^^^^

warning: unused import: `Path`
  --> codehud-viz/src/lib.rs:30:12
   |
30 |     path::{Path, PathBuf},
   |            ^^^^

warning: unused import: `std::collections::HashMap`
  --> codehud-viz/src/call_graph.rs:13:5
   |
13 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `LinesWithEndings`, `Style as SyntectStyle`, `as_24_bit_terminal_escaped`, and `easy::HighlightLines`
  --> codehud-viz/src/lib.rs:36:5
   |
36 |     easy::HighlightLines,
   |     ^^^^^^^^^^^^^^^^^^^^
37 |     highlighting::{ThemeSet, Style as SyntectStyle},
   |                              ^^^^^^^^^^^^^^^^^^^^^
38 |     parsing::SyntaxSet,
39 |     util::{as_24_bit_terminal_escaped, LinesWithEndings},
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^

warning: unused import: `backend::Backend`
  --> codehud-viz/src/lib.rs:16:5
   |
16 |     backend::Backend,
   |     ^^^^^^^^^^^^^^^^

warning: unused variable: `graph_analysis`
   --> codehud-viz/src/lib.rs:926:25
    |
926 |             if let Some(graph_analysis) = data.get("graph_analysis") {
    |                         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_graph_analysis`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `idx`
    --> codehud-viz/src/lib.rs:1149:30
     |
1149 |                         for (idx, issue) in issues_array.iter().enumerate().take(self.config.max_list_items / tool_names.len()) {
     |                              ^^^ help: if this is intentional, prefix it with an underscore: `_idx`

warning: unused variable: `nodes_array`
    --> codehud-viz/src/lib.rs:1319:34
     |
1319 |                     if let (Some(nodes_array), Some(edges_array)) = (nodes.as_array(), edges.as_array()) {
     |                                  ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_nodes_array`

warning: unused variable: `semantic_complexity`
    --> codehud-viz/src/lib.rs:2918:104
     |
2918 | ..._by_type, highlights_summary, semantic_complexity, language_features } = &view.content {
     |                                  ^^^^^^^^^^^^^^^^^^^ help: try ignoring the field: `semantic_complexity: _`

warning: fields `syntax_set` and `theme_set` are never read
  --> codehud-viz/src/lib.rs:45:5
   |
43 | pub struct VisualizationEngine {
   |            ------------------- fields in this struct
44 |     config: VizConfig,
45 |     syntax_set: SyntaxSet,
   |     ^^^^^^^^^^
46 |     theme_set: ThemeSet,
   |     ^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: method `get_risk_color` is never used
    --> codehud-viz/src/lib.rs:3292:8
     |
291  | impl VisualizationEngine {
     | ------------------------ method in this implementation
...
3292 |     fn get_risk_color(&self, risk_level: &str) -> Style {
     |        ^^^^^^^^^^^^^^

warning: `codehud-llm` (lib) generated 65 warnings (run `cargo fix --lib -p codehud-llm` to apply 20 suggestions)
warning: `codehud-analysis` (lib) generated 2 warnings (run `cargo fix --lib -p codehud-analysis` to apply 1 suggestion)
warning: `codehud-viz` (lib) generated 12 warnings (run `cargo fix --lib -p codehud-viz` to apply 5 suggestions)
warning: unused imports: `CommentExtractor`, `GpuType`, `LlmConfig`, `ModelType`, and `ScanResult`
  --> codehud-cli/src/llm.rs:10:37
   |
10 |     FileProcessor, ProcessorConfig, CommentExtractor, ExtractionConfig,
   |                                     ^^^^^^^^^^^^^^^^
11 |     LlmConfig, OllamaConfig, ModelType, GpuType,
   |     ^^^^^^^^^                ^^^^^^^^^  ^^^^^^^
12 |     CommentExtractionFSM, CommentExtractionCLI, ExtractionState, ScanResult,
   |                                                                  ^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `skip_system_summary`
   --> codehud-cli/src/llm.rs:264:5
    |
264 |     skip_system_summary: bool,
    |     ^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_skip_system_summary`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `extensions`
   --> codehud-cli/src/llm.rs:265:5
    |
265 |     extensions: Vec<String>,
    |     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_extensions`

warning: unused variable: `cli`
   --> codehud-cli/src/llm.rs:352:5
    |
352 |     cli: &Cli,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_cli`

warning: unused variable: `cli`
   --> codehud-cli/src/llm.rs:374:5
    |
374 |     cli: &Cli,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_cli`

warning: unused variable: `cli`
   --> codehud-cli/src/llm.rs:402:5
    |
402 |     cli: &Cli,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_cli`

warning: unused variable: `session`
   --> codehud-cli/src/llm.rs:404:5
    |
404 |     session: Option<PathBuf>,
    |     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_session`

warning: unused variable: `max_tokens`
   --> codehud-cli/src/llm.rs:406:5
    |
406 |     max_tokens: u32,
    |     ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_tokens`

warning: `codehud-cli` (bin "codehud-llm") generated 8 warnings (run `cargo fix --bin "codehud-llm"` to apply 1 suggestion)
    Finished `release` profile [optimized] target(s) in 0.20s
     Running `target/release/codehud-llm scan-project .`
🚀 CodeHUD LLM - Project Scanner
🤖 Backend: ollama
🔍 FSM DEBUG: ProjectSelected event received for: .
🔍 FSM DEBUG: Current state: Discriminant(0)
🔍 🔍 🔍 CRATE DISCOVERY STARTING: .
🔍 🔍 🔍 CRATE DISCOVERY STARTING: .
🔍 DEBUG: Searching for Cargo.toml files in: .
🔍 DEBUG: Found Cargo.toml at: ./codehud-tui/Cargo.toml
📦 Discovered crate: codehud-tui at ./codehud-tui
🔍 DEBUG: Found Cargo.toml at: ./codehud-viz/Cargo.toml
📦 Discovered crate: codehud-viz at ./codehud-viz
🔍 DEBUG: Found Cargo.toml at: ./codehud-cli/Cargo.toml
📦 Discovered crate: codehud-cli at ./codehud-cli
🔍 DEBUG: Found Cargo.toml at: ./test_project_hierarchical/codehud-tui/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./test_project_hierarchical/codehud-viz/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./test_project_hierarchical/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./codehud-realtime/Cargo.toml
📦 Discovered crate: codehud-realtime at ./codehud-realtime
🔍 DEBUG: Found Cargo.toml at: ./codehud-core/Cargo.toml
📦 Discovered crate: codehud-core at ./codehud-core
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/ruby/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/c/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/rust/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/php/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/typescript/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/python/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/c-sharp/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/swift/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/cpp/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/kotlin/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/javascript/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/java/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./tree-sitter-grammars/go/Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./codehud-gui/Cargo.toml
📦 Discovered crate: codehud-gui at ./codehud-gui
🔍 DEBUG: Found Cargo.toml at: ./codehud-utils/Cargo.toml
📦 Discovered crate: codehud-utils at ./codehud-utils
🔍 DEBUG: Found Cargo.toml at: ./codehud-transform/Cargo.toml
📦 Discovered crate: codehud-transform at ./codehud-transform
🔍 DEBUG: Found Cargo.toml at: ./Cargo.toml
⚠️  Failed to parse ./Cargo.toml: Configuration error: No [package] section in Cargo.toml
🔍 DEBUG: Found Cargo.toml at: ./codehud-analysis/Cargo.toml
📦 Discovered crate: codehud-analysis at ./codehud-analysis
🔍 DEBUG: Found Cargo.toml at: ./codehud-llm/Cargo.toml
📦 Discovered crate: codehud-llm at ./codehud-llm
🔍 DEBUG: Found Cargo.toml at: ./test_hierarchical/Cargo.toml
📦 Found 10 crates for hierarchical analysis
  - codehud-analysis (Analysis pipeline and rendering system - Zero degradation from Python)
  - codehud-cli (Command-line interfaces (4 CLI systems) - Zero degradation from Python)
  - codehud-core (Core analysis engine with 11+ extractors - Zero degradation from Python)
  - codehud-gui (No description)
  - codehud-llm (LLM integration (29+ components) - Zero degradation from Python)
  - codehud-realtime (Real-time monitoring and file watching - Zero degradation from Python)
  - codehud-transform (Code transformation and refactoring engine - Zero degradation from Python)
  - codehud-tui (Terminal user interface with Textual compatibility - Zero degradation from Python)
  - codehud-utils (Utility functions with Python compatibility - Zero degradation from Python)
  - codehud-viz (Visualization system (10+ view types) - Zero degradation from Python)
🧠 Starting hierarchical crate processing...
🖥️  Spawned progress window with gnome-terminal

📝 PHASE 1: Extracting comments and generating file summaries for all crates...

🔍 DEBUG: Crate path for codehud-analysis: ./codehud-analysis
🔍 Processing 3 files from crate codehud-analysis
🔍 DEBUG: First 5 files discovered for crate codehud-analysis:
  1. ./codehud-analysis/src/lib.rs
  2. ./codehud-analysis/src/health_score.rs
  3. ./codehud-analysis/src/pipeline.rs
🔍 Loading Rust Imports query: 1261 chars
✅ Successfully compiled Rust Imports query
🔍 Loading Rust Functions query: 289 chars
✅ Successfully compiled Rust Functions query
🔍 Loading Rust Complexity query: 1116 chars
✅ Successfully compiled Rust Complexity query
🔍 Loading Rust Highlights query: 3489 chars
❌ Failed to compile Highlights query for Rust: Query error at 112:2. Invalid node type gen
[2m2025-10-02T06:02:32.021964Z[0m [33m WARN[0m Failed to compile Highlights query for Rust: Query error at 112:2. Invalid node type gen
🔍 Loading Rust Tags query: 1194 chars
✅ Successfully compiled Rust Tags query
⚠️ No query file found for Rust References
🔍 Loading Rust Comments query: 194 chars
✅ Successfully compiled Rust Comments query
🔍 Loading Python Imports query: 1434 chars
❌ Failed to compile Imports query for Python: Query error at 34:3. Impossible pattern:
  name: (wildcard_import)) @wildcard_import
  ^
[2m2025-10-02T06:02:32.027179Z[0m [33m WARN[0m Failed to compile Imports query for Python: Query error at 34:3. Impossible pattern:
  name: (wildcard_import)) @wildcard_import
  ^
🔍 Loading Python Functions query: 673 chars
✅ Successfully compiled Python Functions query
🔍 Loading Python Complexity query: 639 chars
✅ Successfully compiled Python Complexity query
🔍 Loading Python Highlights query: 1957 chars
✅ Successfully compiled Python Highlights query
🔍 Loading Python Tags query: 350 chars
✅ Successfully compiled Python Tags query
⚠️ No query file found for Python References
🔍 Loading Python Comments query: 399 chars
✅ Successfully compiled Python Comments query
⚠️ No query file found for JavaScript Imports
⚠️ No query file found for JavaScript Functions
⚠️ No query file found for JavaScript Complexity
🔍 Loading JavaScript Highlights query: 2739 chars
✅ Successfully compiled JavaScript Highlights query
🔍 Loading JavaScript Tags query: 2218 chars
✅ Successfully compiled JavaScript Tags query
⚠️ No query file found for JavaScript References
🔍 Loading JavaScript Comments query: 54 chars
✅ Successfully compiled JavaScript Comments query
⚠️ No query file found for TypeScript Imports
⚠️ No query file found for TypeScript Functions
⚠️ No query file found for TypeScript Complexity
🔍 Loading TypeScript Highlights query: 515 chars
✅ Successfully compiled TypeScript Highlights query
🔍 Loading TypeScript Tags query: 573 chars
✅ Successfully compiled TypeScript Tags query
⚠️ No query file found for TypeScript References
🔍 Loading TypeScript Comments query: 54 chars
✅ Successfully compiled TypeScript Comments query
⚠️ No query file found for Java Imports
⚠️ No query file found for Java Functions
⚠️ No query file found for Java Complexity
🔍 Loading Java Highlights query: 2064 chars
✅ Successfully compiled Java Highlights query
🔍 Loading Java Tags query: 499 chars
✅ Successfully compiled Java Tags query
⚠️ No query file found for Java References
🔍 Loading Java Comments query: 78 chars
✅ Successfully compiled Java Comments query
📋 Query Engine Initialized:
   Loaded 5 parsers
   Loaded 19 queries
   - Rust Functions query loaded
   - Python Highlights query loaded
   - JavaScript Comments query loaded
   - TypeScript Comments query loaded
   - Rust Imports query loaded
   - JavaScript Tags query loaded
   - TypeScript Highlights query loaded
   - Java Tags query loaded
   - Java Highlights query loaded
   - Rust Comments query loaded
   - Rust Complexity query loaded
   - Rust Tags query loaded
   - Python Comments query loaded
   - Python Tags query loaded
   - JavaScript Highlights query loaded
   - Python Complexity query loaded
   - Python Functions query loaded
   - Java Comments query loaded
   - TypeScript Tags query loaded
🔍 DEBUG: Generating structural insights for ./codehud-analysis/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-analysis/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-analysis/src/health_score.rs
✅ DEBUG: Narrator method succeeded for ./codehud-analysis/src/health_score.rs
🔍 DEBUG: Generating structural insights for ./codehud-analysis/src/pipeline.rs
✅ DEBUG: Narrator method succeeded for ./codehud-analysis/src/pipeline.rs
💾 Comments JSON updated: 3 total files (3 from codehud-analysis)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-analysis...
🤖 Analyzing 3 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (3 files)...
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (1/3) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-analysis/src/lib.rs
Language: rust
Comments found: 6

STRUCTURAL CONTEXT:
exports: pub use health_score::{HealthScoreCalculator, HealthScore};., pub use pipeline::{
imports: Imports: pub use health_score::{HealthScoreCalculator, HealthScore};., Imports: pub use pipeline::{

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Analysis - Pipeline and Rendering System
Line 3: ! This crate provides the analysis pipeline and rendering system for CodeHUD,
Line 4: ! implementing both direct and legacy analysis modes with comprehensive
Line 5: ! markdown export capabilities.
Line 12: Re-export main types for convenience
Line 19: Result type for analysis operations

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1062 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (2/3) - health_score.rs...🔍 DEBUG PROMPT for health_score.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-analysis/src/health_score.rs
Language: rust
Comments found: 40

STRUCTURAL CONTEXT:
structure: calls serde_json::Map::new., calls HealthScoreCalculator::default., calls serde_json::Value::Object., calculate_functionality_score is a wrapper for Ok (lines 171)., calculate_performance_score is a wrapper for Ok (lines 259)., calculate_security_score is a wrapper for Ok (lines 233)., calls HashMap::new., calls Error::Analysis.
imports: Imports: use super::*;., Imports: use serde::{Serialize, Deserialize};., Imports: use codehud_core::{Result, Error};., Imports: use std::collections::HashMap;., use super::*;.

COMMENTS TO ANALYZE:
Line 1: ! Health Score Calculation - Exact Python Algorithm Implementation
Line 3: ! This module implements the health score calculation system to match
Line 4: ! Python algorithms exactly as required by zero-degradation plan.
Line 10: Health score calculator matching Python HealthScoreCalculator
Line 19: Complete health score result matching Python structure
Line 32: Complexity metrics for health calculation
Line 44: Issue severity levels matching Python classification
Line 54: Security vulnerability types
Line 64: Performance hotspot data
Line 76: Default weights matching Python implementation
Line 87: Create new health score calculator with custom weights
Line 102: Calculate complete health score from analysis data
Line 107: Extract metrics from analysis data
Line 113: Calculate individual scores using exact Python algorithms
Line 119: Calculate weighted overall score (exact Python formula)
Line 127: Create score breakdown
Line 134: Count critical issues
Line 144: Generate recommendations based on scores
Line 165: Calculate functionality score (exact Python algorithm)
Line 195: Calculate maintainability score (exact Python algorithm)
Line 202: Cyclomatic complexity penalty (Python thresholds)
Line 209: Cognitive complexity penalty
Line 214: Function length penalty
Line 219: Maximum function complexity penalty
Line 227: Calculate security score (exact Python algorithm)
Line 253: Calculate performance score (exact Python algorithm)
Line 265: Penalty based on complexity and execution frequency
Line 269: Additional penalty for high memory usage
Line 278: Extract complexity metrics from analysis data
Line 314: Extract issues from analysis data
Line 324: Combine all issue types
Line 346: Extract vulnerabilities from analysis data
Line 382: Extract performance hotspots from analysis data
Line 416: Generate health recommendations based on scores
Line 466: No issues should give perfect score
Line 470: Critical issues should heavily penalize
Line 483: Low complexity should give high score
Line 497: High complexity should penalize
Line 509: Should be heavily penalized

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3140 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (3/3) - pipeline.rs...🔍 DEBUG PROMPT for pipeline.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-analysis/src/pipeline.rs
Language: rust
Comments found: 55

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::thread::available_parallelism() (lines 419).
structure: calls serde_yaml::to_string., calls serde_json::to_value., calls Duration::from_secs., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 95)., calls Utc::now., calls Error::Analysis., calls Self::get_memory_usage., calls PerformanceExtractor::new., calls QualityExtractor::new., calls FlowExtractor::new., calls Self::get_total_memory_gb., calls Self::get_disk_space_gb., calls Self::run_single_extractor., calls serde_json::to_string_pretty., calls Error::Config., calls TestingExtractor::new., calls HashMap::new., calls HealthScoreCalculator::default., calls EvolutionExtractor::new., calls Error::Json., calls IssuesExtractor::new., calls codehud_core::query_engine::QueryEngine::new., calls DependenciesExtractor::new., calls SecurityExtractor::new., calls TopologyExtractor::new., calls Self::get_available_memory_gb.
imports: Imports: use std::path::{Path, PathBuf};., Imports: use chrono::{DateTime, Utc};., Imports: use tokio::time::{timeout, Duration};., Imports: use serde::{Serialize, Deserialize};., Imports: use crate::health_score::{HealthScoreCalculator, HealthScore};., Imports: use codehud_core::{, Imports: use std::collections::HashMap;., use crate::health_score::{HealthScoreCalculator, HealthScore};., Imports: use codehud_utils::logging::get_logger;.

COMMENTS TO ANALYZE:
Line 1: ! Direct Analysis Pipeline - Core orchestration matching Python direct_pipeline.py
Line 3: ! This module implements the direct analysis pipeline that coordinates
Line 4: ! all extractors and produces comprehensive analysis results with zero degradation
Line 5: ! from the Python implementation.
Line 32: Direct analysis pipeline orchestrating all extractors
Line 42: Analysis result from the direct pipeline
Line 57: Metadata about the analysis execution
Line 68: Performance metrics for individual extractors
Line 78: System information during analysis
Line 90: Create a new direct analysis pipeline
Line 101: Initialize all extractors as enabled by default
Line 118: 5 minutes default
Line 119: Match Python default
Line 123: Configure which extractors to run
Line 125: Disable all extractors first
Line 130: Enable specified extractors
Line 138: Set execution timeout
Line 144: Enable or disable parallel execution
Line 150: Run the direct analysis pipeline
Line 182: Run extractors based on configuration
Line 189: Calculate health score using extracted data (Python-compatible)
Line 193: Default fallback score
Line 203: Calculate final metrics
Line 217: Run extractors in parallel for maximum performance
Line 225: Spawn tasks for each enabled extractor
Line 275: Run extractors sequentially for debugging and reliability
Line 315: Run a single extractor and measure performance
Line 361: This is handled by a different system, return empty for now
Line 365: Use the enhanced query engine for tree-sitter analysis
Line 370: Convert serde_json::Value to HashMap
Line 383: Return empty result on failure
Line 389: Return empty result on failure
Line 401: TODO: Track this in extractors
Line 416: Create initial analysis metadata
Line 441: Calculate analysis coverage percentage
Line 453: Get current memory usage in bytes (placeholder implementation)
Line 455: TODO: Implement actual memory usage tracking
Line 459: Get total system memory in GB (placeholder implementation)
Line 461: TODO: Implement actual system memory detection
Line 465: Get available system memory in GB (placeholder implementation)
Line 467: TODO: Implement actual available memory detection
Line 471: Get disk space in GB for the given path (placeholder implementation)
Line 473: TODO: Implement actual disk space detection
Line 478: Export analysis results to various formats
Line 482: Export analysis results to JSON
Line 488: Export analysis results to YAML
Line 494: Export analysis results to comprehensive markdown report
Line 548: Errors and Warnings
Line 565: Detailed Results (summary of each view)
Line 570: Extract summary information from each view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4561 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (3/3) - Complete!
✅ Phase 2 complete: 3 files analyzed with enhanced context
📄 File summaries updated: 3 total files (3 from codehud-analysis)
📄 Analysis metadata updated: 1 crates processed
🔍 DEBUG: Crate path for codehud-cli: ./codehud-cli
🔍 Processing 4 files from crate codehud-cli
🔍 DEBUG: First 5 files discovered for crate codehud-cli:
  1. ./codehud-cli/src/main.rs
  2. ./codehud-cli/src/llm.rs
  3. ./codehud-cli/src/direct.rs
  4. ./codehud-cli/src/data.rs
🔍 DEBUG: Generating structural insights for ./codehud-cli/src/main.rs
✅ DEBUG: Narrator method succeeded for ./codehud-cli/src/main.rs
🔍 DEBUG: Generating structural insights for ./codehud-cli/src/llm.rs
✅ DEBUG: Narrator method succeeded for ./codehud-cli/src/llm.rs
🔍 DEBUG: Generating structural insights for ./codehud-cli/src/direct.rs
✅ DEBUG: Narrator method succeeded for ./codehud-cli/src/direct.rs
🔍 DEBUG: Generating structural insights for ./codehud-cli/src/data.rs
✅ DEBUG: Narrator method succeeded for ./codehud-cli/src/data.rs
💾 Comments JSON updated: 7 total files (4 from codehud-cli)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-cli...
🤖 Analyzing 4 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (4 files)...
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (1/4) - main.rs...🔍 DEBUG PROMPT for main.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-cli/src/main.rs
Language: rust
Comments found: 127

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::write(&main_output, (lines 987)., this scope performs file I/O via std::fs::write(&json_file, (lines 1170)., this scope performs file I/O via std::fs::write("call_graph.txt", (lines 455)., this scope performs file I/O via std::fs::write(&text_file, (lines 1175)., this scope performs file I/O via std::fs::write(&report_path, (lines 799)., this scope performs file I/O via std::fs::write(&output_path, (lines 354, 396)., this scope performs file I/O via std::fs::read_to_string(&notes_file) (lines 829)., this scope performs file I/O via std::fs::write(&view_output, (lines 1001)., this scope performs file I/O via writeln!(output, (lines 1190–1193, 1197–1199, 1201, 1203–1204, 1206, 1210–1213, 1215, 1219–1220, 1222–1223, 1225, 1230–1232, 1235–1236)., this scope performs file I/O via std::fs::write(&summary_output, (lines 1021)., this scope performs file I/O via std::fs::write(&readme_output, (lines 1059)., this scope performs file I/O via std::fs::write(&notes_file, (lines 848).
entrypoint: Entrypoint script (lines 318).
imports: Imports: use std::fmt::Write;., Imports: use codehud_core::{Result, ViewType, Pipeline};., Imports: use codehud_core::models::ViewType;., Imports: use codehud_viz::CallGraph;., Imports: use std::path::PathBuf;., Imports: use clap::{Parser, Subcommand, ValueEnum};.
structure: calls Ok::<., calls Cli::parse., calls codehud_core::analysis::AnalysisPipeline::run_view., calls serde_json::to_value., calls codehud_core::CoreConfig::default., calls codehud_core::models::AnalysisResult::new., calls serde_json::from_str., calls codehud_viz::VisualizationEngine::new., calls codehud_core::analysis::ViewGenerator::new., calls codehud_analysis::pipeline::DirectAnalysisPipeline::new., calls serde_json::to_string_pretty., calls codehud_core::analysis::AnalysisPipeline::run., calls codehud_viz::CallGraph::new., calls codehud_utils::logging::basic_config., calls codehud_core::Error::Analysis.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Main CLI Entry Point
Line 3: ! Main entry point providing unified interface with 7+ commands matching Python exactly
Line 21: Run comprehensive codebase analysis with visualization
Line 23: Path to codebase to analyze
Line 26: View type for analysis output
Line 30: Analysis pipeline to use
Line 34: Output file path for results
Line 38: Focus on specific entity (file, class, function)
Line 42: Configuration file path
Line 46: Enable debug mode
Line 50: Files to analyze (glob patterns)
Line 55: Export visualizations to text files (no TUI required)
Line 57: Path to codebase to analyze
Line 60: Output directory for visualization files
Line 64: View types to export (comma-separated: quality,security,topology,dependencies)
Line 69: Launch interactive LLM interface for AI-powered analysis
Line 71: Path to codebase
Line 74: LLM backend to use
Line 78: Model to use for analysis
Line 82: Enable GPU acceleration
Line 86: Session file for conversation persistence
Line 91: Launch graphical user interface
Line 93: Path to codebase
Line 96: Initial view to display
Line 100: Window geometry (WIDTHxHEIGHT+X+Y)
Line 104: Enable fullscreen mode
Line 109: Generate call graph visualization
Line 111: Path to codebase to analyze (optional - uses sample data if not provided)
Line 113: Output format (text, terminal, or both)
Line 118: Interactive file editing with AI assistance
Line 120: Path to codebase
Line 123: File to edit
Line 126: Description of changes to make
Line 129: Backup before editing
Line 133: Editor to use
Line 138: Issues inspection and management
Line 140: Path to codebase
Line 143: Issue category to focus on
Line 151: Auto-fix issues where possible
Line 155: Generate issue report
Line 160: Developer notes and fix tracking
Line 162: Path to codebase
Line 165: Add new note
Line 169: List all notes
Line 182: Full comprehensive analysis with all views
Line 184: Path to codebase
Line 187: Output directory for all reports
Line 191: Include performance profiling
Line 195: Generate only specified views (comma-separated)
Line 199: Skip cache and force fresh analysis
Line 205: Use the Pipeline type from codehud-core instead of defining our own
Line 207: Extract real call graph data from codebase analysis
Line 213: Run dependencies analysis to get coupling matrix
Line 218: Extract coupling matrix (file-to-file relationships)
Line 223: Extract module name from file path
Line 226: Create relationships based on coupling strength
Line 234: Extract dependency clusters for inter-cluster relationships
Line 243: Create intra-cluster relationships
Line 255: Fallback to topology-based relationships
Line 264: Create relationships with neighboring files
Line 280: If still no meaningful data, create some sample relationships with main modules
Line 293: Extract a clean module name from a file path
Line 299: Handle special cases
Line 301: Try to get the parent directory name for context
Line 305: Remove "codehud-" prefix
Line 344: Generate specific view
Line 352: Save to output file if specified
Line 361: Run comprehensive analysis for other views or fallback
Line 382: Generate view-specific output
Line 386: Save to output file if specified
Line 389: Focus mode - output specific view
Line 392: Full mode - output complete analysis
Line 454: Save to file
Line 554: Resolve file path relative to codebase if needed
Line 566: Create backup if requested
Line 575: Show description if provided
Line 580: Run analysis on the file first
Line 583: Run quality analysis on the specific file
Line 588: Extract metrics for this specific file
Line 623: Run analysis again to show changes
Line 676: Run security and quality analysis to find issues
Line 685: Extract issues from analysis results
Line 688: Extract security issues
Line 695: Filter by category if specified
Line 702: Filter by severity if specified
Line 714: Extract quality issues
Line 721: Filter by category if specified
Line 728: Filter by severity if specified
Line 742: Group issues by category and severity
Line 761: Display detailed issues
Line 824: Notes file path
Line 827: Load existing notes
Line 836: Add new note
Line 853: List all notes
Line 907: Show summary by default
Line 914: Group by category
Line 950: Create output directory
Line 956: Determine which views to generate
Line 971: Default: all available views
Line 979: Run comprehensive analysis first
Line 985: Save main analysis results
Line 990: Generate each view
Line 998: Save view data
Line 1007: Generate summary report
Line 1023: Generate human-readable summary
Line 1090: Export visualizations to text and JSON files
Line 1097: Create output directory
Line 1100: Parse view types
Line 1122: Run analysis for each view type
Line 1144: Run analysis for a specific view type and export results
Line 1146: Use the existing direct pipeline with default config
Line 1152: Convert to core AnalysisResult for viz engine
Line 1155: Set view data from pipeline result
Line 1159: Create viz engine
Line 1166: Export as JSON
Line 1172: Export as readable text
Line 1179: Show summary in terminal
Line 1185: Format visualization as readable text
Line 1243: Show visualization summary in terminal

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 7659 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (2/4) - llm.rs...🔍 DEBUG PROMPT for llm.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-cli/src/llm.rs
Language: rust
Comments found: 83

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., Imports: use clap::{Parser, Subcommand, ValueEnum};., Imports: use std::path::PathBuf;., use super::*;., Imports: use codehud_llm::{, Imports: use codehud_core::{Result, ViewType};.
structure: calls codehud_utils::logging::basic_config., calls Cli::parse., handle_scan_file is a wrapper for Ok (lines 494)., calls PathBuf::from., calls OllamaConfig::default., calls tokio::time::sleep., calls FileProcessor::new., calls CommentExtractionFSM::new., calls tokio::time::Duration::from_millis., calls ExtractionConfig::default., calls CommentExtractionCLI::new., calls codehud_core::Error::Io.
entrypoint: Entrypoint script (lines 190).

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD LLM CLI - LLM-Powered Features
Line 3: ! Interactive LLM interface for AI-powered code analysis, bug fixing,
Line 4: ! and development assistance. Matches Python cli_llm.py exactly.
Line 22: Subcommand to execute
Line 26: LLM backend to use
Line 30: Model name to use for analysis
Line 34: Enable GPU acceleration
Line 38: Temperature for LLM responses (0.0-2.0)
Line 42: Configuration file path
Line 46: Enable debug mode
Line 53: Extract and analyze comments for codebase understanding
Line 55: Path to the codebase directory to analyze
Line 58: Output directory for analysis files
Line 62: Skip system summary generation (faster for large codebases)
Line 66: Focus on specific file extensions
Line 70: Use cached comment extraction if available
Line 74: Maximum tokens per file analysis
Line 78: Maximum tokens for system summary
Line 83: Interactive comment exploration mode
Line 85: Path to the codebase directory to explore
Line 88: Start with specific file or directory
Line 93: Generate documentation from comment analysis
Line 95: Path to the codebase directory
Line 98: Template for documentation generation
Line 102: Output format (markdown, html, json)
Line 106: Output file for generated documentation
Line 111: Interactive LLM session (legacy mode)
Line 113: Path to the codebase directory to analyze
Line 116: Session file for conversation persistence
Line 120: Initial view context for the LLM
Line 124: Maximum tokens for responses
Line 128: Enable constitutional AI guardrails
Line 132: Enable bug fixing mode with high success rate
Line 136: Enable code generation mode
Line 141: Scan a single file with FSM interface
Line 143: File path to scan (will show picker if not provided)
Line 147: Scan an entire project with FSM interface
Line 149: Project directory to scan (will show picker if not provided)
Line 152: Use structural insights only mode (ultra token-efficient)
Line 168: Local Ollama backend (recommended)
Line 172: OpenHands external integration
Line 196: Validate temperature range
Line 259: Handle comment analysis command (implements the three-phase workflow)
Line 278: Create processor configuration
Line 302: Create Ollama configuration
Line 305: Create file processor
Line 311: Process the codebase
Line 350: Handle interactive comment exploration
Line 368: TODO: Implement interactive exploration
Line 372: Handle documentation generation
Line 396: TODO: Implement documentation generation
Line 400: Handle interactive LLM session (legacy mode)
Line 424: TODO: Implement interactive session
Line 428: Validate codebase path
Line 441: Handle single file scan command using FSM
Line 449: Create processor configuration
Line 466: Single file mode
Line 473: Create Ollama configuration
Line 476: Create FSM (scan file doesn't use insights_only mode)
Line 483: Create CLI interface
Line 486: Execute scan file command
Line 489: Check if we need file picker
Line 501: If we have a file path, process it directly
Line 503: Process the file directly
Line 542: Handle project scan command using FSM
Line 554: Create processor configuration for project scanning
Line 558: Slightly smaller per file for project mode
Line 559: Larger system summary for projects
Line 571: Sequential for project context accumulation
Line 578: Create Ollama configuration
Line 588: Create CLI interface
Line 591: Execute scan project command - the FSM handles everything through events
Line 594: Wait for the FSM to complete hierarchical processing
Line 609: Exit cleanly after completion
Line 617: Still processing, wait a bit and check again
Line 644: Valid temperatures should work

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4780 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (3/4) - direct.rs...🔍 DEBUG PROMPT for direct.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-cli/src/direct.rs
Language: rust
Comments found: 34

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::write(&md_path, (lines 217)., this scope performs file I/O via std::fs::write(&json_path, (lines 211).
structure: calls Cli::parse., calls AnalysisExporter::to_json., calls codehud_utils::logging::basic_config., calls codehud_utils::logging::get_logger., calls CoreConfig::default., calls DirectAnalysisPipeline::new., calls Duration::from_secs., calls AnalysisExporter::to_markdown.
entrypoint: Entrypoint script (lines 75).
imports: Imports: use codehud_core::{Result, ViewType, Pipeline, CoreConfig};., Imports: use std::path::PathBuf;., Imports: use codehud_analysis::{DirectAnalysisPipeline, AnalysisExporter};., Imports: use tokio::time::Duration;., Imports: use clap::{Parser, ValueEnum};., Imports: use super::*;., use super::*;.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Direct CLI - Direct Analysis Pipeline
Line 3: ! Enhanced CLI supporting both direct extraction and legacy CLI analysis,
Line 4: ! matching Python cli_direct.py exactly.
Line 19: Path to the codebase directory to analyze (optional - interactive picker if not provided)
Line 22: Path to CodeHUD configuration file
Line 26: Focus on specific entity (file, function, or class)
Line 30: Initial view to display
Line 34: Analysis pipeline to use
Line 38: Enable debug mode
Line 46: Fast AST-based analysis (recommended)
Line 48: CLI tool-based analysis (comprehensive but slower)
Line 50: Automatically choose best pipeline
Line 59: Auto maps to Hybrid
Line 82: Handle missing codebase path - launch interactive picker
Line 97: TODO: Implement interactive directory picker
Line 142: TODO: Implement focus functionality
Line 145: TODO: Launch the polymorphic HUD interface
Line 152: Run the direct analysis pipeline
Line 156: Create core configuration
Line 159: Configure based on CLI arguments
Line 161: Limit for debug mode
Line 164: Configure specific view if requested
Line 172: Create and configure pipeline
Line 208: Export to JSON
Line 214: Export to Markdown
Line 221: Display view-specific information
Line 225: Extract key metrics from each view
Line 246: Show focus information if applicable
Line 249: TODO: Implement focus-specific analysis

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2659 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (4/4) - data.rs...🔍 DEBUG PROMPT for data.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-cli/src/data.rs
Language: rust
Comments found: 47

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::write(&output_path, (lines 237, 241).
structure: calls Arg::new., calls serde_json::to_string_pretty., handle_export is a wrapper for Ok (lines 251)., calls matches.get_many::<String>., calls codehud_utils::logging::basic_config., calls matches.get_one::<PathBuf>., calls Command::new., calls matches.get_one::<String>., calls matches.get_many::<PathBuf>., calls serde_yaml::to_string.
imports: Imports: use anyhow::Result;., Imports: use clap::{Arg, ArgMatches, Command};., Imports: use std::path::PathBuf;., Imports: use codehud_utils::logging::{get_logger, LogLevel};., Imports: use codehud_core::{Pipeline, CoreConfig};., Imports: use serde_json::Value;.
entrypoint: Entrypoint script (lines 15).

COMMENTS TO ANALYZE:
Line 1: ! Data Analysis CLI - Data export and manipulation interface
Line 3: ! This module provides command-line interfaces for data analysis operations
Line 4: ! matching Python cli_data.py functionality exactly.
Line 13: Main entry point for data CLI
Line 38: Build the CLI command structure
Line 185: Handle export command
Line 197: Create output path if not specified
Line 207: TODO: Implement actual export logic matching Python behavior
Line 208: This would involve:
Line 209: 1. Loading analysis data from input
Line 210: 2. Filtering by specified views if provided
Line 211: 3. Converting to target format
Line 212: 4. Optionally compressing
Line 213: 5. Writing to output
Line 228: Write export data
Line 232: TODO: Implement compression
Line 244: TODO: Implement CSV export
Line 249: TODO: Implement Parquet export
Line 262: Handle import command
Line 272: TODO: Implement actual import logic matching Python behavior
Line 273: This would involve:
Line 274: 1. Reading data from source in specified format
Line 275: 2. Validating data structure
Line 276: 3. Converting to internal format
Line 277: 4. Optionally merging with existing analysis
Line 283: Handle convert command
Line 294: TODO: Implement actual conversion logic
Line 295: This would involve:
Line 296: 1. Reading data in source format
Line 297: 2. Converting to internal representation
Line 298: 3. Writing in target format
Line 304: Handle validate command
Line 314: TODO: Implement actual validation logic
Line 315: This would involve:
Line 316: 1. Reading the file
Line 317: 2. Checking basic structure
Line 318: 3. Validating against schema if provided
Line 319: 4. Reporting validation results
Line 329: Handle merge command
Line 339: TODO: Implement actual merge logic
Line 340: This would involve:
Line 341: 1. Reading all input files
Line 342: 2. Applying merge strategy
Line 343: 3. Resolving conflicts
Line 344: 4. Writing merged result

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3177 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (4/4) - Complete!
✅ Phase 2 complete: 4 files analyzed with enhanced context
📄 File summaries updated: 7 total files (4 from codehud-cli)
📄 Analysis metadata updated: 2 crates processed
🔍 DEBUG: Crate path for codehud-core: ./codehud-core
🔍 Processing 52 files from crate codehud-core
🔍 DEBUG: First 5 files discovered for crate codehud-core:
  1. ./codehud-core/src/models/semantic_nodes.rs
  2. ./codehud-core/src/models/mod.rs
  3. ./codehud-core/src/models/analysis_result.rs
  4. ./codehud-core/src/models/view_types.rs
  5. ./codehud-core/src/extractors/dependencies.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/models/semantic_nodes.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/models/semantic_nodes.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/models/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/models/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/models/analysis_result.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/models/analysis_result.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/models/view_types.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/models/view_types.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/dependencies.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/dependencies.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/runtime_profiler.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/runtime_profiler.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/topology.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/topology.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/performance.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/performance.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/flow.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/flow.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/orphaned_files.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/orphaned_files.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/quality.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/quality.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/testing.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/testing.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/evolution.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/evolution.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/issues.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/issues.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/extractors/security.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/extractors/security.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/bin/test_security.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/bin/test_security.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/bin/test_quality.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/bin/test_quality.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/bin/test_dependencies.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/bin/test_dependencies.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/constants/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/constants/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/constants/complexity_thresholds.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/constants/complexity_thresholds.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/constants/health_score_thresholds.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/constants/health_score_thresholds.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/graph/algorithms.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/graph/algorithms.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/graph/metrics.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/graph/metrics.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/graph/algorithms_minimal.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/graph/algorithms_minimal.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/graph/edges.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/graph/edges.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/graph/nodes.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/graph/nodes.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/graph/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/graph/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/graph/analyzer.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/graph/analyzer.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/query_engine.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/query_engine.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/pattern/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/pattern/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/cargo_test.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/cargo_test.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/ruff.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/ruff.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/coverage.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/coverage.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/radon.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/radon.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/rustfmt.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/rustfmt.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/mypy.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/mypy.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/cargo_audit.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/cargo_audit.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/pylint.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/pylint.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/vulture.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/vulture.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/ripgrep.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/ripgrep.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/bandit.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/bandit.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/clippy.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/clippy.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/external_tools/git.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/external_tools/git.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/cache/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/cache/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/analysis/view_generator.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/analysis/view_generator.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/analysis/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/analysis/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/analysis/health_calculator.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/analysis/health_calculator.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/src/analysis/pipeline.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/src/analysis/pipeline.rs
🔍 DEBUG: Generating structural insights for ./codehud-core/benches/extraction_benchmarks.rs
✅ DEBUG: Narrator method succeeded for ./codehud-core/benches/extraction_benchmarks.rs
💾 Comments JSON updated: 59 total files (52 from codehud-core)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-core...
🤖 Analyzing 52 files with enhanced context and improved token limits...
📦 Processing batch 1/11 (5 files)...
🤖 Analyzing: [░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   1% (1/52) - semantic_nodes.rs...🔍 DEBUG PROMPT for semantic_nodes.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-core/src/models/semantic_nodes.rs
Language: rust
Comments found: 43

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::collections::HashMap;., use super::*;., Imports: use chrono::{DateTime, Utc};.
structure: calls ClassDefinition::new., calls GraphBundle::new., calls serde_json::to_string., calls FunctionSignature::new., calls HashMap::new., calls Self::new., calls Utc::now., calls serde_json::from_str.

COMMENTS TO ANALYZE:
Line 1: ! Semantic node models for code analysis and graph construction.
Line 3: ! This module provides data structures for representing code elements
Line 4: ! and their relationships in a semantic graph structure.
Line 10: Function signature with comprehensive semantic information.
Line 12: This struct exactly matches the Python FunctionSignature dataclass
Line 13: to ensure complete compatibility in function analysis.
Line 29: Extensions for CodeHUD integration
Line 37: Create a new function signature with required fields
Line 65: Check if function has side effects
Line 70: Check if function is a property/getter based on decorators
Line 75: Get function signature as string (Python-like format)
Line 79: Add regular arguments
Line 101: Class definition with inheritance and semantic analysis.
Line 103: This struct exactly matches the Python ClassDefinition dataclass
Line 104: to ensure complete compatibility in class analysis.
Line 117: Extensions for CodeHUD
Line 124: Create a new class definition with required fields
Line 146: Check if class inherits from a specific base class
Line 151: Check if class is abstract based on methods or decorators
Line 157: Get total lines of code for the class
Line 163: Universal semantic code node for graph construction.
Line 165: This struct exactly matches the Python SemanticNode dataclass
Line 166: to ensure complete compatibility in semantic analysis.
Line 170: function, class, import, variable, call
Line 175: full qualified path
Line 181: Create a new semantic node
Line 204: Add a relationship to another node
Line 212: Get relationships of a specific type
Line 217: Add metadata entry
Line 222: Check if node is a function
Line 227: Check if node is a class
Line 232: Get the module name from file path
Line 234: Convert file path to module-like name
Line 242: Collection of analysis graphs.
Line 244: This struct represents the graph bundle used throughout CodeHUD
Line 245: for storing various types of analysis graphs.
Line 248: Note: In Rust we'll use petgraph::Graph instead of NetworkX
Line 249: but maintain the same logical structure
Line 261: Create a new empty graph bundle
Line 274: Check if bundle is empty
Line 284: Get total number of nodes across all graphs

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3148 characters
🤖 Analyzing: [█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   3% (2/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-core/src/models/mod.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
exports: pub use semantic_nodes::{FunctionSignature, ClassDefinition, SemanticNode, GraphBundle};., pub use analysis_result::{AnalysisResult, CodeMetrics};., pub use view_types::ViewType;.
imports: Imports: pub use analysis_result::{AnalysisResult, CodeMetrics};., Imports: pub use view_types::ViewType;., Imports: pub use semantic_nodes::{FunctionSignature, ClassDefinition, SemanticNode, GraphBundle};.

COMMENTS TO ANALYZE:
Line 1: ! Data models module for CodeHUD core
Line 3: ! This module contains all data structures used for representing
Line 4: ! code analysis results, semantic information, and visualization data.

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1112 characters
🤖 Analyzing: [██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   5% (3/52) - analysis_result.rs...🔍 DEBUG PROMPT for analysis_result.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-core/src/models/analysis_result.rs
Language: rust
Comments found: 36

STRUCTURAL CONTEXT:
structure: calls CodeMetrics::default., calls AnalysisResult::new., calls serde_json::Value::String., calls Utc::now., calls HashMap::new.
imports: Imports: use serde::{Serialize, Deserialize};., Imports: use std::collections::HashMap;., Imports: use super::*;., use super::*;., Imports: use chrono::{DateTime, Utc};.

COMMENTS TO ANALYZE:
Line 1: ! Analysis Result Model
Line 3: ! Complete analysis result structure matching Python implementation exactly
Line 9: Complete analysis result for a codebase - matches Python AnalysisResult exactly
Line 12: Path to the analyzed codebase
Line 14: Number of files that were analyzed
Line 16: Timestamp when analysis was performed
Line 18: Duration of analysis in seconds
Line 21: Core analysis data
Line 22: Overall code metrics
Line 24: Overall health score (0.0 to 100.0)
Line 26: Critical issues that need immediate attention
Line 28: Recommendations for focus areas
Line 31: Direct extraction data (new pipeline)
Line 32: Extracted view data organized by view type
Line 35: Optional detailed data (for legacy pipeline Phase 2+)
Line 36: Parsed file data (optional for legacy pipeline)
Line 38: Graph data (optional for legacy pipeline)
Line 40: Static analysis results (optional for legacy pipeline)
Line 44: Code metrics structure matching Python implementation
Line 47: Total lines of code
Line 49: Lines of executable code (excluding comments/whitespace)
Line 51: Number of functions
Line 53: Number of classes
Line 55: Number of files
Line 57: Average cyclomatic complexity
Line 59: Maximum cyclomatic complexity found
Line 61: Technical debt ratio
Line 63: Code coverage percentage (if available)
Line 87: Create a new analysis result
Line 105: Add a critical issue to the analysis result
Line 110: Add a focus recommendation
Line 115: Set extracted view data for a specific view type
Line 120: Get view data for a specific view type
Line 125: Check if analysis has critical issues
Line 130: Get severity distribution of issues

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2481 characters
🤖 Analyzing: [███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   7% (4/52) - view_types.rs...🔍 DEBUG PROMPT for view_types.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-core/src/models/view_types.rs
Language: rust
Comments found: 19

STRUCTURAL CONTEXT:
structure: calls serde_json::to_string., calls ViewType::all., calls ViewType::from_str., calls serde_json::from_str., calls Self::from_str.
imports: Imports: use serde::{Deserialize, Serialize};., Imports: use super::*;., Imports: use std::fmt;., Imports: use std::collections::HashMap;., use super::*;.

COMMENTS TO ANALYZE:
Line 1: ! Core data models for CodeHUD analysis and visualization.
Line 3: ! This module provides the fundamental data structures used throughout CodeHUD
Line 4: ! for representing code analysis results, visualization types, and semantic information.
Line 6: ! This is a 1:1 translation from Python src/codehud/core/models.py
Line 7: ! to ensure zero degradation in data model behavior.
Line 13: Available visualization view types.
Line 15: This enum exactly matches the Python ViewType enum to ensure
Line 16: complete compatibility across all visualization systems.
Line 28: New view type
Line 29: LLM fix tracking
Line 30: Enhanced tree-sitter semantic analysis
Line 34: Get all available view types
Line 51: Get the string representation matching Python behavior
Line 68: Parse from string, matching Python behavior exactly
Line 86: Get display name for UI
Line 103: Check if this view supports focus functionality
Line 132: Test all view types round-trip correctly
Line 142: Ensure exact string matching with Python enum values
Line 186: Ensure we have all 10 view types from Python

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1910 characters
🤖 Analyzing: [████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   9% (5/52) - dependencies.rs...🔍 DEBUG PROMPT for dependencies.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/dependencies.rs
Language: rust
Comments found: 40

STRUCTURAL CONTEXT:
structure: calls crate::Error::Config., calls Utc::now., calls SupportedLanguage::from_path., calls DependencyAnalysis::default., calls HashMap::new., calls serde_json::Map::new., calls Value::Object., import_to_file_path is a wrapper for Some.format.path_parts.join (lines 298)., calls fs::read_dir., calls HashSet::new., analyze_file_dependencies is a wrapper for Ok.None (lines 127)., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 68).
imports: Imports: use std::path::{Path, PathBuf};., Imports: use std::collections::{HashMap, HashSet};., Imports: use super::BaseDataExtractor;., use crate::Result;., Imports: use serde_json::{json, Value};., Imports: use crate::Result;., Imports: use anyhow::Context;., Imports: use crate::query_engine::{get_query_engine, SupportedLanguage};., use super::BaseDataExtractor;., Imports: use std::fs;., use crate::query_engine::{get_query_engine, SupportedLanguage};., Imports: use chrono::{DateTime, Utc};.
file_i/o: this scope performs file I/O via fs::read_dir(dir) (lines 97)., this scope performs file I/O via fs::read_dir(&self.codebase_path) (lines 82)., this scope performs file I/O via vec![ (lines 529).

COMMENTS TO ANALYZE:
Line 1: ! Dependencies Data Extractor - Automatic dependency analysis using tree-sitter queries
Line 3: ! This module extracts comprehensive dependency analysis including:
Line 4: ! - Automatic language detection and parsing
Line 5: ! - Query-based import extraction
Line 6: ! - Dependency graph construction with petgraph
Line 7: ! - Circular dependency detection
Line 8: ! - Coupling metrics calculation
Line 9: ! - Cross-language analysis support
Line 43: "import" or "from_import"
Line 101: Check if this file is supported by our query engine
Line 125: Check if file is supported by query engine
Line 130: Use query engine for automatic analysis
Line 137: Extract import information from query results
Line 144: Convert query results to our format
Line 153: Create import detail
Line 164: Categorize as from_import if it has an item
Line 171: Calculate metrics using the extracted data
Line 305: Old manual AST analyzer removed - now using query engine automatically
Line 311: Get all source files
Line 317: Create a mutable copy for analysis - query engine handles languages automatically
Line 323: Analyze each file
Line 331: Build dependency graph
Line 337: Note: Graph analysis now handled by query engine
Line 339: Categorize as internal vs external
Line 351: Note: from_imports graph analysis now handled by query engine
Line 363: Detect circular dependencies
Line 366: Calculate dependency metrics
Line 369: Analyze coupling strength
Line 372: Graph analysis now integrated with query engine
Line 381: External dependencies analysis
Line 387: Most influential files
Line 498: Sort strong couplings by strength
Line 524: Sort by count
Line 528: Standard library modules
Line 594: Sort by cluster size

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3414 characters
📦 Processing batch 2/11 (5 files)...
🤖 Analyzing: [█████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  11% (6/52) - runtime_profiler.rs...🔍 DEBUG PROMPT for runtime_profiler.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/runtime_profiler.rs
Language: rust
Comments found: 33

STRUCTURAL CONTEXT:
imports: use super::BaseDataExtractor;., Imports: use chrono::{DateTime, Utc};., Imports: use std::fs;., Imports: use std::process::Command;., Imports: use super::BaseDataExtractor;., Imports: use tree_sitter::{Language, Parser};., Imports: use serde_json::{json, Value};., Imports: use std::collections::{HashMap, HashSet};., use crate::external_tools::ExternalToolManager;., Imports: use serde::{Serialize, Deserialize};., Imports: use crate::external_tools::ExternalToolManager;., Imports: use std::path::{Path, PathBuf};., Imports: use std::time::{Duration, Instant};.
network_i/o: this scope calls metrics.iter().filter(|m| (lines 336)., this scope calls m.function_name.contains("fetch") (lines 337).
structure: calls crate::Error::Analysis., calls HashMap::new., calls crate::Error::Config., extract_data is a wrapper for Ok.result (lines 459)., calls ExternalToolManager::new., calls Utc::now., calls Command::new., calls tree_sitter_rust::language., calls fs::read_to_string., calls Parser::new., calls crate::Error::Io., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 73)., calls fs::read_dir.
file_i/o: this scope performs file I/O via func_source.matches("read_csv") (lines 246)., this scope performs file I/O via func_source.matches("read_csv").count() (lines 246)., this scope performs file I/O via func_source.matches("open(").count() (lines 218)., this scope performs file I/O via func_source.matches("read_json").count() (lines 247)., this scope performs file I/O via m.function_name.contains("open") (lines 345)., this scope performs file I/O via metrics (lines 401)., this scope performs file I/O via fs::read_dir(dir) (lines 98)., this scope performs file I/O via func_source.matches("open(") (lines 218)., this scope performs file I/O via metrics.iter().filter(|m| (lines 332, 344)., this scope performs file I/O via m.function_name.contains("write") (lines 333, 403)., this scope performs file I/O via func_source.matches("read_json") (lines 247)., this scope performs file I/O via m.function_name.contains("read") (lines 333, 403)., this scope performs file I/O via fs::read_to_string(file_path) (lines 131).

COMMENTS TO ANALYZE:
Line 1: ! Runtime Profiler Data Extractor - Analyzes runtime performance and execution patterns
Line 35: "critical", "major", "minor"
Line 59: "high", "medium", "low"
Line 161: Analyze function complexity as a proxy for runtime cost
Line 172: Default, would be updated with actual profiling
Line 181: Recursively process child nodes
Line 193: Count control flow statements
Line 201: Count function calls (potential performance impact)
Line 204: Count list comprehensions and generators
Line 213: Base time in milliseconds
Line 215: Heuristics for execution time based on code patterns
Line 234: Base memory in MB
Line 236: Heuristics for memory usage
Line 245: Large data operations
Line 260: High execution time bottlenecks
Line 287: High memory usage bottlenecks
Line 316: Sort by impact score (highest first)
Line 331: Estimate resource operations based on function analysis
Line 362: Pattern 1: High-memory functions
Line 381: Pattern 2: CPU-intensive functions
Line 400: Pattern 3: IO-bound operations
Line 423: Try to run Python profiling tools if available
Line 462: Analyze runtime metrics
Line 468: Analyze resource usage
Line 471: Identify execution patterns
Line 474: Try actual profiling

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5089 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  13% (7/52) - topology.rs...🔍 DEBUG PROMPT for topology.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/topology.rs
Language: rust
Comments found: 82

STRUCTURAL CONTEXT:
structure: calls PythonAstAnalyzer::new., calls serde_json::to_value., calls tree_sitter_python::language., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 36)., extract_rust_parameters is a wrapper for params_str.split.map.p.Some.colon_pos.p.find.p.colon_pos.trim.to_string.p.trim.to_string.filter.p.p.is_empty.p.p.p.collect (lines 362)., calls TopologyExtractor::new., calls crate::Error::Analysis., calls crate::Error::Io., calls crate::Error::Config., calls Utc::now., calls Parser::new., calls regex::Regex::new., extract_js_parameters is a wrapper for params_str.split.map.p.p.trim.split.next.unwrap_or.trim.to_string.filter.p.p.is_empty.collect (lines 225)., extract_rust_return_type is a wrapper for Some.return_type.to_string (lines 391)., calls HashMap::new., extract_js_return_type is a wrapper for Some.return_type.to_string (lines 241)., extract_rust_derives is a wrapper for derives_str.split.map.d.d.trim.to_string.filter.d.d.is_empty.collect (lines 403).
file_i/o: this scope performs file I/O via std::fs::read_to_string(file_path) (lines 103, 130, 262, 415).
imports: Imports: use std::collections::{HashMap, HashSet};., Imports: use std::path::{Path, PathBuf};., Imports: use chrono::{DateTime, Utc};., Imports: use std::fs;., Imports: use crate::Result;., Imports: use tree_sitter::Parser;., Imports: use super::{BaseDataExtractor, FileMetrics};., Imports: use tempfile::tempdir;., Imports: use tracing::{info, warn};., Imports: use super::*;., Imports: use serde::{Serialize, Deserialize};., use super::*;., use super::{BaseDataExtractor, FileMetrics};., use crate::Result;., Imports: use regex;.

COMMENTS TO ANALYZE:
Line 1: ! Topology Data Extractor
Line 3: ! Extracts codebase topology information including file structure,
Line 4: ! classes, functions, and architectural overview.
Line 6: ! This is a zero-degradation Rust translation of topology_extractor.py
Line 17: Extract codebase topology and architecture data
Line 24: Create a new topology extractor
Line 48: Analyze a single file (Python _analyze_file equivalent)
Line 59: Check if this is a test file
Line 65: Python-specific analysis using tree-sitter
Line 90: Basic analysis for other file types
Line 99: Analyze Python file using tree-sitter AST (Python _analyze_python_file equivalent)
Line 106: Initialize tree-sitter parser for Python
Line 112: Parse the file
Line 128: Analyze JavaScript/TypeScript file using regex-based parsing
Line 136: Function detection patterns
Line 146: Class detection pattern
Line 220: Extract JavaScript function parameters
Line 235: Extract JavaScript return type from TypeScript annotations
Line 248: Extract JavaScript extends clause
Line 260: Analyze Rust file using regex-based parsing
Line 264: Structs/enums in Rust
Line 268: Function detection patterns
Line 276: Struct/enum detection patterns (treating as classes)
Line 314: Detect structs/enums as classes
Line 329: Detect use statements/dependencies
Line 357: Extract Rust function parameters
Line 365: Extract parameter name before colon
Line 379: Extract Rust return type
Line 388: Handle single line functions
Line 398: Extract Rust derive traits as base classes
Line 413: Calculate basic complexity based on control flow keywords
Line 425: Minimum complexity of 1
Line 430: Check if a file is a test file based on naming conventions
Line 442: Extract function name from a function definition line
Line 444: Simple pattern: "def function_name(" or "async def function_name("
Line 455: Extract class name from a class definition line
Line 457: Simple pattern: "class ClassName:" or "class ClassName("
Line 465: Extract dependency from import statement
Line 474: from module import ...
Line 483: Calculate summary statistics (Python _calculate_summary equivalent)
Line 492: Calculate language distribution
Line 500: Calculate complexity distribution
Line 520: Analyze project structure (Python _analyze_project_structure equivalent)
Line 530: Count files per directory
Line 546: Calculate coupling metrics (Python _calculate_coupling equivalent)
Line 557: Find most coupled files
Line 581: Get all source files
Line 584: Analyze each file
Line 593: Collect classes and functions
Line 614: Calculate summary statistics
Line 617: Analyze project structure
Line 620: Calculate coupling metrics
Line 623: Convert to the expected format
Line 649: Data structures matching Python implementation
Line 716: Tree-sitter AST analyzer for Python files (equivalent to PythonASTAnalyzer in Python)
Line 756: Recursively visit children
Line 777: Basic complexity, will be updated by complexity analysis
Line 780: TODO: Extract return type annotation
Line 815: Extract base classes
Line 821: Extract methods (will be updated when we visit function definitions)
Line 826: Will be populated by function visitor
Line 837: Extract the root module name
Line 846: Extract the root module name

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6580 characters
🤖 Analyzing: [███████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  15% (8/52) - performance.rs...🔍 DEBUG PROMPT for performance.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/performance.rs
Language: rust
Comments found: 24

STRUCTURAL CONTEXT:
imports: Imports: use std::collections::HashMap;., Imports: use crate::external_tools::ExternalToolManager;., use crate::external_tools::ExternalToolManager;., Imports: use serde_json::{json, Value};., Imports: use tree_sitter::{Language, Parser};., Imports: use serde::{Serialize, Deserialize};., Imports: use std::path::{Path, PathBuf};., Imports: use std::fs;., Imports: use super::BaseDataExtractor;., Imports: use chrono::{DateTime, Utc};., use super::BaseDataExtractor;.
file_i/o: this scope performs file I/O via fs::read_dir(&self.codebase_path) (lines 68)., this scope performs file I/O via fs::read_to_string(file_path) (lines 105)., this scope performs file I/O via function_call.contains("urlopen") (lines 555)., this scope performs file I/O via fs::read_dir(dir) (lines 83).
structure: calls fs::read_to_string., calls tree_sitter_rust::language., calls crate::Error::Config., calls ExternalToolManager::new., calls fs::read_dir., calls crate::Error::Io., calls Parser::new., calls PerformanceAstAnalyzer::new., calls crate::Error::Analysis., calls HashMap::new., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 48)., calls Utc::now.

COMMENTS TO ANALYZE:
Line 144: Complex functions with high performance impact
Line 182: File I/O operations without proper handling
Line 230: Large string concatenations
Line 243: List comprehensions vs loops
Line 275: Penalize complex functions
Line 282: Penalize nested loops
Line 289: Penalize expensive operations
Line 292: Penalize recursive calls without termination checks
Line 381: Visit child nodes
Line 394: Calculate complexity and lines
Line 442: Detect expensive operations
Line 466: Check for recursive calls
Line 482: Add complexity for control structures
Line 519: Simple check for .append() calls within the loop
Line 525: Simple heuristic: look for repeated expensive function calls
Line 528: Count occurrences of potentially expensive operations
Line 562: Simplified check - in a real implementation, would analyze surrounding context

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3731 characters
🤖 Analyzing: [████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  17% (9/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/mod.rs
Language: rust
Comments found: 28

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::write(temp_path.join("main.rs"), (lines 273)., this scope performs file I/O via std::fs::write(temp_path.join("regular.py"), (lines 291)., this scope performs file I/O via std::fs::read_to_string(file_path) (lines 108)., this scope performs file I/O via std::fs::write(pycache_dir.join("cached.py"), (lines 288)., this scope performs file I/O via std::fs::write(temp_path.join("test.py"), (lines 272).
structure: calls walkdir::WalkDir::new., calls HashMap::new.
imports: Imports: use crate::Result;., Imports: pub use orphaned_files::OrphanedFilesExtractor;., Imports: pub use issues::IssuesExtractor;., Imports: pub use testing::TestingExtractor;., Imports: pub use topology::TopologyExtractor;., Imports: use std::collections::{HashMap, HashSet};., Imports: use super::*;., Imports: use chrono::{DateTime, Utc};., Imports: pub use dependencies::DependenciesExtractor;., Imports: pub use performance::PerformanceExtractor;., Imports: pub use flow::FlowExtractor;., Imports: use std::path::{Path, PathBuf};., Imports: pub use security::SecurityExtractor;., Imports: use tempfile::tempdir;., Imports: pub use evolution::EvolutionExtractor;., Imports: pub use quality::QualityExtractor;., use super::*;., Imports: pub use runtime_profiler::RuntimeProfiler;., use crate::Result;., Imports: use serde::{Serialize, Deserialize};.
exports: pub use testing::TestingExtractor;., pub use performance::PerformanceExtractor;., pub use topology::TopologyExtractor;., pub use dependencies::DependenciesExtractor;., pub use orphaned_files::OrphanedFilesExtractor;., pub use runtime_profiler::RuntimeProfiler;., pub use security::SecurityExtractor;., pub use evolution::EvolutionExtractor;., pub use flow::FlowExtractor;., pub use issues::IssuesExtractor;., pub use quality::QualityExtractor;.

COMMENTS TO ANALYZE:
Line 1: ! Data extractors for CodeHUD analysis
Line 3: ! This module provides the 11+ data extractors that match the Python
Line 4: ! implementation exactly for zero degradation compatibility.
Line 12: Base trait for all CodeHUD data extractors
Line 14: Matches the Python BaseDataExtractor abstract class exactly
Line 16: Extract raw data for this analysis type
Line 19: Get extractor type name
Line 22: Get codebase path
Line 25: Get extraction timestamp
Line 28: Get common metadata for all extractors
Line 42: Extract data and include metadata (Python extract_with_metadata equivalent)
Line 63: Get source files matching given extensions (Python _get_source_files equivalent)
Line 83: Skip if any parent directory is excluded
Line 94: Check file extension
Line 106: Calculate basic metrics for a file (Python _calculate_file_metrics equivalent)
Line 161: Result of data extraction with metadata
Line 170: Metadata for data extraction
Line 186: File metrics structure matching Python implementation
Line 198: Get Python files excluding backup and cache directories
Line 199: Static method equivalent from Python BaseDataExtractor
Line 215: Skip if any parent directory is excluded
Line 226: Check for .py extension
Line 235: Module declarations for individual extractors
Line 248: Re-export the main extractors for convenience
Line 271: Create some test files
Line 285: Create excluded directory with Python file
Line 290: Create regular Python file

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5002 characters
🤖 Analyzing: [█████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  19% (10/52) - flow.rs...🔍 DEBUG PROMPT for flow.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/flow.rs
Language: rust
Comments found: 22

STRUCTURAL CONTEXT:
structure: new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 68)., calls HashMap::new., calls crate::Error::Analysis., calls value.parse::<i64>., calls tree_sitter_rust::language., extract_data is a wrapper for Ok.result (lines 534)., calls fs::read_dir., calls fs::read_to_string., calls HashSet::new., calls crate::Error::Config., calls value.parse::<f64>., calls Parser::new., calls ExternalToolManager::new., calls Utc::now., calls crate::Error::Io.
file_i/o: this scope performs file I/O via fs::read_dir(dir) (lines 93)., this scope performs file I/O via fs::read_to_string(file_path) (lines 129).
imports: Imports: use tree_sitter::{Language, Parser};., Imports: use std::collections::{HashMap, HashSet};., Imports: use serde::{Serialize, Deserialize};., Imports: use serde_json::{json, Value};., Imports: use crate::external_tools::ExternalToolManager;., Imports: use chrono::{DateTime, Utc};., use crate::external_tools::ExternalToolManager;., use super::BaseDataExtractor;., Imports: use super::BaseDataExtractor;., Imports: use std::path::{Path, PathBuf};., Imports: use std::fs;.

COMMENTS TO ANALYZE:
Line 1: ! Flow Data Extractor - Analyzes data flow patterns in Python codebases
Line 20: function, variable, class, module
Line 32: assignment, function_call, parameter, return_value
Line 188: Recursively process child nodes
Line 349: Pattern 1: Deep nested function calls
Line 361: Pattern 2: Circular data dependencies
Line 373: Pattern 3: Unused variables
Line 397: Threshold for deep nesting
Line 407: Simplified circular dependency detection
Line 418: Simple cycle detection using DFS
Line 421: Get file path from edges involving this node
Line 456: Count variable usage
Line 463: Find variables used only once (likely unused)
Line 478: Group nodes by variable name and file
Line 486: Analyze lifecycle for each variable
Line 503: Determine scope depth (simplified)
Line 537: Analyze data flow
Line 543: Analyze variable lifecycles

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3671 characters
📦 Processing batch 3/11 (5 files)...
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  21% (11/52) - orphaned_files.rs...🔍 DEBUG PROMPT for orphaned_files.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im
- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/orphaned_files.rs
Language: rust
Comments found: 30

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via fs::read_to_string(file_path) (lines 138, 197, 379)., this scope performs file I/O via fs::read_dir(dir) (lines 68).
imports: Imports: use std::path::{Path, PathBuf};., Imports: use std::collections::{HashMap, HashSet};., Imports: use chrono::{DateTime, Utc};., Imports: use std::os::unix::fs::PermissionsExt;., Imports: use tree_sitter::{Language, Parser};., Imports: use super::BaseDataExtractor;., Imports: use std::fs;., Imports: use serde_json::{json, Value};., Imports: use serde::{Serialize, Deserialize};., use super::BaseDataExtractor;.
structure: calls HashSet::new., calls fs::read_to_string., calls tree_sitter_rust::language., calls fs::metadata., calls fs::read_dir., calls crate::Error::Analysis., calls HashMap::new., calls crate::Error::Io., calls crate::Error::Config., calls Parser::new., extract_data is a wrapper for Ok.result (lines 400)., resolve_import_to_file is a wrapper for Some.file_path.clone (lines 189)., calls Utc::now., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 46).

COMMENTS TO ANALYZE:
Line 91: Initialize all files
Line 104: Analyze imports for each file
Line 109: Check if file has main function
Line 116: Map imports to actual files
Line 121: Add to usage tracking
Line 158: Extract the module path from use declaration
Line 170: Visit child nodes
Line 179: Try to match import to actual file
Line 187: Check if import matches directory structure
Line 205: Check if file is likely an entry point based on naming conventions
Line 219: Check if file has executable permissions (Unix-like systems)
Line 227: On non-Unix systems, check for shebang or entry point patterns
Line 243: Threshold for considering a file orphaned
Line 265: Sort by confidence score (highest first)
Line 274: No imports from other files
Line 279: Not an entry point
Line 289: Reduce confidence for special file types
Line 291: Tests might not be imported but are still needed
Line 295: Config files often aren't imported
Line 299: Documentation files aren't imported
Line 302: Small files might be utilities
Line 304: Files smaller than 1KB
Line 385: Less than 5 meaningful lines
Line 403: Analyze file usage patterns
Line 406: Identify orphaned files
Line 416: Calculate file usage statistics

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5069 characters
🤖 Analyzing: [███████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  23% (12/52) - quality.rs...🔍 DEBUG PROMPT for quality.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im
- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/quality.rs
Language: rust
Comments found: 88

STRUCTURAL CONTEXT:
imports: Imports: use chrono::{DateTime, Utc};., Imports: use std::fs;., Imports: use tree_sitter::{Language, Parser};., Imports: use super::BaseDataExtractor;., use crate::Result;., Imports: use anyhow::Context;., Imports: use crate::Result;., use crate::external_tools::{ExternalToolManager, ExternalTool};., Imports: use std::path::{Path, PathBuf};., Imports: use std::collections::HashMap;., Imports: use crate::external_tools::{ExternalToolManager, ExternalTool};., use super::BaseDataExtractor;., Imports: use serde_json::{json, Value};.
structure: calls QualityAnalyzer::default., calls Parser::new., calls ExternalToolManager::new., calls fs::read_dir., calls tree_sitter_rust::language., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 71)., calls crate::Error::Parse., calls Utc::now., calls fs::read_to_string., calls crate::Error::Config., calls crate::Error::Io., run_external_tools_analysis is a wrapper for Ok.issues (lines 598)., calls HashMap::new.
file_i/o: this scope performs file I/O via fs::read_dir(&self.codebase_path) (lines 93)., this scope performs file I/O via fs::read_dir(dir) (lines 108)., this scope performs file I/O via fs::read_to_string(file_path) (lines 130)., this scope performs file I/O via std::fs::read_to_string(file_path).unwrap_or_default() (lines 731)., this scope performs file I/O via std::fs::read_to_string(file_path) (lines 731).

COMMENTS TO ANALYZE:
Line 1: ! Quality Data Extractor - Code quality metrics and health scores
Line 137: Basic line analysis
Line 153: Run external tools analysis on this file
Line 223: Count methods in class
Line 248: Recursively analyze children
Line 305: Analyze Rust-specific quality patterns
Line 307: Count unsafe blocks (negative impact on quality)
Line 309: Unsafe code increases complexity
Line 311: Count Result<T, E> usage (positive pattern)
Line 314: Count Option<T> usage (positive pattern)
Line 317: Count unwrap() usage (negative pattern - should use proper error handling)
Line 320: Count expect() usage (better than unwrap but still not ideal)
Line 323: Count ? operator usage (positive pattern for error handling)
Line 326: Count lifetime annotations (indicates complex borrowing)
Line 329: Count trait implementations (positive pattern)
Line 332: Store Rust-specific metrics
Line 346: Enhanced complexity algorithm for Rust including Rust-specific patterns
Line 352: Average function complexity (base algorithm)
Line 356: Penalize high individual complexities (exact Python formula)
Line 361: Nesting depth penalty (exact Python formula)
Line 368: Rust-specific complexity adjustments
Line 372: Unsafe blocks significantly increase complexity
Line 375: Excessive unwrap() calls increase complexity (should use proper error handling)
Line 378: Lifetime annotations indicate borrowing complexity
Line 381: Positive adjustments for good Rust patterns (reduce complexity score)
Line 382: ? operator is good
Line 383: Good error handling
Line 390: Final complexity score (enhanced for Rust)
Line 395: CRITICAL: Exact Python maintainability algorithm for zero-degradation compliance
Line 397: Base score from lines of code (exact Python formula)
Line 400: Complexity penalty (exact Python formula)
Line 403: Comment bonus (exact Python formula)
Line 406: Function size penalty (exact Python formula)
Line 411: Calculate final score (exact Python formula)
Line 414: Return score clamped to 0-100 range (exact Python behavior)
Line 524: CRITICAL: Exact Python algorithm implementation for zero-degradation compliance
Line 527: Weight different factors (exact Python values)
Line 533: Calculate component scores exactly as Python
Line 539: Complexity score (inverted - lower is better, exact Python formula)
Line 546: Issues score (inverted - fewer is better, exact Python formula)
Line 553: Documentation score (exact Python formula)
Line 558: Cap at 100
Line 560: Calculate weighted score (exact Python formula)
Line 566: Determine grade and status (exact Python thresholds)
Line 580: Round to 1 decimal place like Python
Line 595: CRITICAL: Only analyze Rust files with external tools
Line 601: Run ruff analysis - CRITICAL for zero-degradation compliance
Line 623: Ruff failed, log but continue
Line 628: Run pylint analysis - CRITICAL for zero-degradation compliance
Line 651: Pylint failed, log but continue
Line 656: TODO: Run bandit security analysis - CRITICAL for zero-degradation compliance
Line 657: Temporarily disabled to get basic ruff/pylint working first
Line 658: match self.external_tools.bandit_integration.analyze_file(file_path).await { Ok(bandit_result) => { for issue in bandit_result.issues { issues.push(json!({ "type": "security_issue", "severity": issue.issue_severity.to_lowercase(), "confidence": issue.issue_confidence.to_lowercase(), "message": issue.issue_text, "line": issue.line_number, "tool": "bandit", "test_id": issue.test_id, "test_name": issue.test_name, "code": issue.code, "file": issue.filename })); } } Err(e) => { // Bandit failed, log but continue println!("Bandit analysis failed for {}: {}", file_path.display(), e); } }
Line 683: TODO: Add mypy type checking integration
Line 684: TODO: Add radon complexity analysis integration
Line 693: Run ruff analysis
Line 694: External tool integration placeholder - actual integration will be async
Line 698: Run other tools as they become available
Line 707: Get all source files
Line 710: Analyze each file
Line 714: Create a mutable copy for analysis
Line 727: For now, skip async external tool analysis to avoid runtime issues
Line 728: TODO: Refactor BaseDataExtractor trait to support async methods
Line 741: Calculate comment ratio for the analyzer (exact Python formula)
Line 750: Analyze Rust-specific patterns
Line 757: Add external tool analysis - CRITICAL for zero-degradation compliance
Line 760: TODO: External tool integration per file - requires async trait support
Line 761: For now, skip file-level external tool integration to avoid runtime conflicts
Line 762: External tools are run at the codebase level instead
Line 785: Add Rust-specific metrics if available
Line 798: Calculate Rust quality score
Line 802: Penalize unsafe code heavily
Line 805: Penalize unwrap() usage
Line 808: Slightly penalize expect() usage (better than unwrap but not ideal)
Line 811: Reward good error handling patterns
Line 815: Neutral for lifetime annotations (complexity but necessary)
Line 816: Reward trait implementations (good design)
Line 847: Generate summary statistics
Line 850: Calculate health score using exact Python algorithm
Line 853: TODO: External tool integration at codebase level - requires async pipeline support
Line 854: For now, provide placeholder results with structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 9487 characters
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (13/52) - testing.rs...🔍 DEBUG PROMPT for testing.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im
- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/testing.rs
Language: rust
Comments found: 23

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via fs::read_to_string(file_path) (lines 141)., this scope performs file I/O via fs::read_dir(dir) (lines 105).
imports: Imports: use std::fs;., Imports: use std::process::Command;., use crate::external_tools::ExternalToolManager;., Imports: use tree_sitter::{Language, Parser};., Imports: use chrono::{DateTime, Utc};., Imports: use crate::external_tools::ExternalToolManager;., Imports: use super::BaseDataExtractor;., Imports: use serde::{Serialize, Deserialize};., use super::BaseDataExtractor;., Imports: use serde_json::{json, Value};., Imports: use std::collections::{HashMap, HashSet};., Imports: use std::path::{Path, PathBuf};.
structure: calls tree_sitter_rust::language., calls fs::read_to_string., calls crate::Error::Analysis., calls fs::read_dir., calls ExternalToolManager::new., calls Utc::now., calls Command::new., extract_data is a wrapper for Ok.result (lines 506)., calls crate::Error::Io., calls crate::Error::Config., calls serde_json::from_str::<Value>., calls HashMap::new., calls Parser::new., calls PathBuf::from., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 78).

COMMENTS TO ANALYZE:
Line 1: ! Testing Data Extractor - Analyzes test coverage, patterns, and quality
Line 51: "good", "warning", "error"
Line 216: Check for decorators
Line 251: Check for mock usage
Line 260: Recursively process child nodes
Line 281: Try to get coverage from pytest-cov or coverage.py
Line 308: No branches = 100% coverage
Line 340: Pattern 1: Tests without assertions
Line 357: Pattern 2: Large test files
Line 374: Pattern 3: Good use of mocks
Line 391: Pattern 4: Parametrized tests
Line 422: Skip test files themselves
Line 427: Check if it's a main module or important file
Line 469: Simplified detection for slow/flaky tests
Line 472: Heuristic for potentially slow tests
Line 478: Many skipped tests might indicate flakiness
Line 509: Analyze test files
Line 517: Get test coverage

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4750 characters
🤖 Analyzing: [█████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  26% (14/52) - evolution.rs...🔍 DEBUG PROMPT for evolution.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im
- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/evolution.rs
Language: rust
Comments found: 31

STRUCTURAL CONTEXT:
structure: calls fs::read_dir., calls crate::Error::Io., calls Command::new., calls parts[0].parse::<i32>., calls crate::Error::Config., extract_data is a wrapper for Ok.result (lines 444)., analyze_file_evolution is a wrapper for Err.Error.Analysis.to_string (lines 179)., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 71)., calls ExternalToolManager::new., calls Utc::now., calls crate::Error::Analysis., calls HashSet::new., calls NaiveDateTime::parse_from_str., calls parts[1].parse::<i32>., calls HashMap::new., analyze_git_history is a wrapper for Ok.Vec.new.Vec.new.Vec.new (lines 114).
file_i/o: this scope performs file I/O via fs::read_dir(dir) (lines 92).
imports: Imports: use super::BaseDataExtractor;., Imports: use std::path::{Path, PathBuf};., use crate::external_tools::ExternalToolManager;., Imports: use std::process::Command;., Imports: use crate::external_tools::ExternalToolManager;., Imports: use serde_json::{json, Value};., Imports: use serde::{Serialize, Deserialize};., Imports: use std::fs;., use super::BaseDataExtractor;., Imports: use std::collections::{HashMap, HashSet};., Imports: use chrono::{DateTime, Utc, NaiveDateTime};.

COMMENTS TO ANALYZE:
Line 1: ! Evolution Data Extractor - Analyzes code evolution patterns and version history
Line 21: commits per month
Line 25: "increasing", "decreasing", "stable"
Line 34: "weekdays", "weekends", "late_night", etc.
Line 35: "small", "medium", "large"
Line 122: Analyze each file's evolution
Line 129: Analyze overall commit patterns
Line 134: Extract author metrics from file evolutions
Line 168: Get git log for this file
Line 197: Get line statistics
Line 200: Calculate primary author (most commits)
Line 212: Calculate commit frequency (commits per month)
Line 235: Calculate stability score (lower is more stable)
Line 238: Determine complexity trend (simplified)
Line 313: Analyze commit size based on message
Line 322: Analyze time patterns (simplified)
Line 331: Create patterns based on analysis
Line 361: Calculate risk score based on multiple factors
Line 366: Bug proneness heuristic (high change frequency + multiple authors)
Line 377: Overall risk score calculation
Line 382: Threshold for hotspot
Line 394: Sort by risk score (highest first)
Line 403: Code churn metrics
Line 424: Overall health score
Line 447: Analyze git history
Line 453: Calculate project health metrics

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5183 characters
🤖 Analyzing: [██████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  28% (15/52) - issues.rs...🔍 DEBUG PROMPT for issues.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- semantic_nodes.rs: This Rust file serves as the foundation for semantic analysis and graph construction in CodeHUD, a comprehensive code analysis tool. It provides data structures (structs) representing different types 
- mod.rs: The file ./codehud-core/src/models/mod.rs in Rust contains all the data structures and models used by CodeHUD for representing code analysis results, semantic information, and visualization data. The 
- analysis_result.rs: This file, `analysis_result.rs` in the Rust project `codehud-core/src/models`, is responsible for managing and representing the analysis results of a codebase. It provides detailed information about t
- view_types.rs: This Rust file, `view_types.rs`, is a crucial part of CodeHUD's core data models for code analysis and visualization. The module provides fundamental data structures used throughout the application fo
- dependencies.rs: This file provides a comprehensive dependency analysis system for codebases, utilizing tree-sitter queries and petgraph for constructing dependency graphs. It features automatic language detection, im
- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/issues.rs
Language: rust
Comments found: 16

STRUCTURAL CONTEXT:
structure: calls serde_json::from_str::<serde_json::Value>., run_pylint is a wrapper for Ok.serde_json.json (lines 123)., calls serde_json::Value::Array., calls Utc::now., calls serde_json::from_slice::<serde_json::Value>., run_bandit is a wrapper for Ok.serde_json.json (lines 201)., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 23)., calls crate::Error::Config., calls tokio::runtime::Runtime::new., run_ruff is a wrapper for Ok.serde_json.json (lines 162)., calls HashMap::new., run_mypy is a wrapper for Ok.serde_json.json (lines 247)., calls tokio::process::Command::new.
imports: Imports: use crate::Result;., Imports: use chrono::{DateTime, Utc};., Imports: use std::path::{Path, PathBuf};., Imports: use serde::{Serialize, Deserialize};., Imports: use super::{BaseDataExtractor, FileMetrics};., Imports: use std::collections::HashMap;., use super::{BaseDataExtractor, FileMetrics};., use crate::Result;.

COMMENTS TO ANALYZE:
Line 1: ! Issues Data Extractor
Line 3: ! Categorizes and analyzes code issues using external tools
Line 4: ! like pylint, ruff, bandit, and other static analysis tools.
Line 42: Run external tools using async runtime since extract_data is not async
Line 46: Run all external tools in parallel for efficiency
Line 53: Run in parallel and collect results, handling errors gracefully
Line 62: Calculate total issues across all tools
Line 74: Create comprehensive issue summary with real data
Line 111: Run pylint and parse output to JSON
Line 129: Fallback: create structured data from stderr text
Line 150: Run ruff and parse output to JSON
Line 188: Run bandit for security analysis
Line 206: Extract results from bandit's JSON structure
Line 234: Run mypy for type checking
Line 250: MyPy outputs one JSON object per line

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4566 characters
📦 Processing batch 4/11 (5 files)...
🤖 Analyzing: [███████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  30% (16/52) - security.rs...🔍 DEBUG PROMPT for security.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function
- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/extractors/security.rs
Language: rust
Comments found: 37

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via fs::read_to_string(file_path) (lines 183, 646)., this scope performs file I/O via fs::read_dir(&self.codebase_path) (lines 143)., this scope performs file I/O via fs::read_dir(dir) (lines 158)., this scope performs file I/O via function_name.ends_with("Popen") (lines 287).
imports: Imports: use serde_json::{json, Value};., Imports: use tree_sitter::{Language, Parser};., use crate::Result;., Imports: use std::fs;., Imports: use crate::Result;., Imports: use crate::external_tools::{ExternalToolManager, ExternalTool};., Imports: use regex::Regex;., use super::BaseDataExtractor;., Imports: use anyhow::Context;., Imports: use std::collections::HashMap;., Imports: use tracing::{debug, warn};., Imports: use super::BaseDataExtractor;., Imports: use chrono::{DateTime, Utc};., Imports: use std::path::{Path, PathBuf};., use crate::external_tools::{ExternalToolManager, ExternalTool};.
structure: calls Utc::now., calls ExternalToolManager::new., calls Regex::new., calls HashMap::<String, usize>::new., calls tree_sitter_rust::language., calls Parser::new., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 95)., calls fs::read_to_string., calls SecurityAnalyzer::default., calls crate::Error::Parse., calls crate::Error::Config., calls HashMap::new., calls crate::Error::Io., calls fs::read_dir.

COMMENTS TO ANALYZE:
Line 1: ! Security Data Extractor - Security vulnerabilities and potential security issues
Line 3: ! This module extracts security vulnerabilities using both AST analysis and bandit integration
Line 4: ! to maintain zero-degradation compliance with the Python implementation.
Line 105: Initialize security patterns - match Python exactly
Line 194: Pattern-based analysis - match Python's line-by-line approach
Line 254: Recursively analyze children
Line 269: Check for dangerous functions - match Python exactly (only eval, exec, compile, __import__)
Line 279: Python sets all these to high
Line 285: Check for subprocess calls with shell=True - more precise matching
Line 305: Check for pickle.loads usage
Line 319: Check for yaml.load usage
Line 341: Check for sensitive data patterns - match Python line-by-line logic
Line 365: Check for insecure imports
Line 397: Check sensitive patterns - match Python exactly
Line 410: Check file permission patterns
Line 424: Additional security checks - match Python's _check_additional_security_issues
Line 435: Check for use of HTTP instead of HTTPS
Line 448: Check for potential XSS vulnerabilities
Line 469: Check for potential directory traversal
Line 530: Weight by severity - match Python exactly
Line 543: Calculate score (0-100, higher is more risky)
Line 544: Normalize based on number of files analyzed - match Python algorithm
Line 554: Determine risk level - match Python thresholds
Line 568: Round to 1 decimal place
Line 641: For Rust, we focus on different security patterns than Python
Line 644: Analyze each file for Rust-specific security issues
Line 652: Check for unsafe blocks
Line 666: Check for unwrap() calls
Line 680: Check for expect() calls
Line 711: Get all source files
Line 714: Analyze each file
Line 722: Create a mutable copy for analysis
Line 740: Collect all issues from this file
Line 767: Combine all issues for analysis
Line 772: Run Rust-specific security analysis
Line 775: Recalculate analysis with bandit results included

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6166 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  32% (17/52) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function
- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/lib.rs
Language: rust
Comments found: 38

STRUCTURAL CONTEXT:
exports: pub use constants::{, pub use models::{
file_i/o: this scope performs file I/O via std::thread::available_parallelism().map(|p| (lines 152)., this scope performs file I/O via std::thread::available_parallelism() (lines 152).
imports: Imports: pub use constants::{, Imports: pub use models::{

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Core - Analysis Engine and Data Structures
Line 3: ! This crate provides the core analysis engine for CodeHUD, including:
Line 4: ! - Data models and semantic structures
Line 5: ! - Analysis extractors and algorithms
Line 6: ! - Graph analysis and pattern detection
Line 7: ! - Caching and performance optimization
Line 9: ! This is a zero-degradation Rust translation of the Python CodeHUD core,
Line 10: ! designed to maintain 100% compatibility while achieving 60%+ performance improvements.
Line 20: Common in large dependency trees
Line 21: Often necessary for clarity
Line 34: Re-export commonly used types for convenience
Line 45: Re-export Pipeline for easy access (commented out to avoid name conflict)
Line 46: pub use Pipeline;
Line 48: Result type used throughout CodeHUD core
Line 51: Error types for CodeHUD core operations
Line 54: I/O operation failed
Line 74: External tool error
Line 86: JSON serialization error
Line 91: Analysis pipeline types matching Python implementation exactly
Line 95: Direct analysis pipeline (fast, modern approach)
Line 97: Legacy analysis pipeline (compatibility with older Python behavior)
Line 99: Hybrid pipeline (combines direct and legacy modes)
Line 126: Global configuration for CodeHUD core
Line 129: Maximum number of files to analyze
Line 131: Enable parallel processing
Line 133: Number of worker threads
Line 139: File extensions to analyze
Line 141: Patterns to exclude
Line 143: Default analysis pipeline to use

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4569 characters
🤖 Analyzing: [█████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  34% (18/52) - test_security.rs...🔍 DEBUG PROMPT for test_security.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function
- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/bin/test_security.rs
Language: rust
Comments found: 5

STRUCTURAL CONTEXT:
entrypoint: Entrypoint script (lines 4).
structure: calls SecurityExtractor::new.
imports: Imports: use codehud_core::extractors::BaseDataExtractor;., Imports: use codehud_core::extractors::security::SecurityExtractor;.

COMMENTS TO ANALYZE:
Line 25: Print risk assessment
Line 31: Print file count and issues
Line 65: Print bandit results

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3108 characters
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  36% (19/52) - test_quality.rs...🔍 DEBUG PROMPT for test_quality.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function
- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/bin/test_quality.rs
Language: rust
Comments found: 5

STRUCTURAL CONTEXT:
structure: calls QualityExtractor::new.
entrypoint: Entrypoint script (lines 4).
imports: Imports: use codehud_core::extractors::quality::QualityExtractor;., Imports: use codehud_core::extractors::BaseDataExtractor;.

COMMENTS TO ANALYZE:
Line 25: Print health score
Line 30: Print file count and issues
Line 38: Show first few issues as examples
Line 44: Print external tool results

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3151 characters
🤖 Analyzing: [███████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  38% (20/52) - test_dependencies.rs...🔍 DEBUG PROMPT for test_dependencies.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- runtime_profiler.rs: This Rust file, `runtime_profiler.rs`, is a data extractor specifically designed for runtime performance and execution patterns analysis in CodeHUD, a comprehensive code analysis tool. It leverages ex
- topology.rs: This Rust file, `topology.rs` in the `codehud-core/src/extractors` directory of a CodeHUD project, is an essential component for extracting and analyzing codebase topology information including file s
- performance.rs: This Rust file, performance.rs in the ./codehud-core/src/extractors directory of CodeHUD's source code repository, is designed for profiling and performance analysis of a given codebase. It utilizes t
- mod.rs: This file, `mod.rs` in the Rust project `codehud-core/src/extractors`, is responsible for providing data extractors for CodeHUD analysis. It matches the Python implementation exactly for zero degradat
- flow.rs: The file ./codehud-core/src/extractors/flow.rs in the CodeHUD Rust project is responsible for data flow analysis and pattern detection in Python codebases, focusing on specific semantics like function
- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/bin/test_dependencies.rs
Language: rust
Comments found: 5

STRUCTURAL CONTEXT:
entrypoint: Entrypoint script (lines 4).
imports: Imports: use codehud_core::extractors::dependencies::DependenciesExtractor;., Imports: use codehud_core::extractors::BaseDataExtractor;.
structure: calls DependenciesExtractor::new.

COMMENTS TO ANALYZE:
Line 25: Print dependency metrics
Line 31: Print coupling analysis
Line 37: Print file count and dependencies

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3136 characters
📦 Processing batch 5/11 (5 files)...
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (21/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using
- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/constants/mod.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
exports: pub use complexity_thresholds::{ComplexityThresholds, CyclomaticComplexityThresholds};., pub use health_score_thresholds::{HealthScoreThresholds, QualityThresholds};.
imports: Imports: pub use health_score_thresholds::{HealthScoreThresholds, QualityThresholds};., Imports: pub use complexity_thresholds::{ComplexityThresholds, CyclomaticComplexityThresholds};.

COMMENTS TO ANALYZE:
Line 1: ! Constants module for CodeHUD core
Line 3: ! This module contains all threshold values, configuration constants,
Line 4: ! and other static values used throughout the analysis engine.

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3360 characters
🤖 Analyzing: [█████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  42% (22/52) - complexity_thresholds.rs...🔍 DEBUG PROMPT for complexity_thresholds.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using
- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/constants/complexity_thresholds.rs
Language: rust
Comments found: 61

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., Imports: use serde::{Deserialize, Serialize};., Imports: use proptest::prelude::*;., use super::*;.

COMMENTS TO ANALYZE:
Line 1: ! Complexity Analysis Thresholds
Line 3: ! Constants for measuring and categorizing code complexity metrics.
Line 4: ! These thresholds help identify overly complex code that may need refactoring.
Line 6: ! This is a 1:1 translation from Python src/codehud/constants/complexity_thresholds.py
Line 7: ! to ensure zero degradation in complexity analysis behavior.
Line 11: General code complexity thresholds
Line 16: Base complexity thresholds
Line 17: Low complexity threshold
Line 18: Moderate complexity threshold
Line 19: High complexity threshold
Line 20: Excessive complexity threshold
Line 21: Critical complexity threshold
Line 24: Function complexity warning
Line 25: Function complexity critical
Line 28: Class complexity warning
Line 29: Class complexity critical
Line 31: Get complexity status description
Line 34: `complexity` - The complexity score to evaluate
Line 37: A string describing the complexity level
Line 48: Determine if code needs refactoring based on complexity
Line 51: `complexity` - The complexity score to evaluate
Line 52: `context` - The context ("function", "class", or other)
Line 55: `true` if the code needs refactoring, `false` otherwise
Line 65: Cyclomatic complexity specific thresholds
Line 70: McCabe complexity thresholds (widely accepted industry standards)
Line 71: Simple, no branching
Line 72: Low risk, simple procedure
Line 73: Moderate risk, complex procedure
Line 74: High risk, very complex procedure
Line 75: Untestable, extremely complex
Line 78: Easy to understand and maintain
Line 79: Maintainable with effort
Line 80: Difficult to maintain
Line 83: Get risk level based on cyclomatic complexity
Line 86: `cyclomatic_complexity` - The cyclomatic complexity score
Line 89: A string describing the risk level
Line 100: Get maintainability assessment based on cyclomatic complexity
Line 103: `cyclomatic_complexity` - The cyclomatic complexity score
Line 106: A string describing the maintainability level
Line 117: Determine if complexity requires immediate attention
Line 120: `cyclomatic_complexity` - The cyclomatic complexity score
Line 123: `true` if complexity requires immediate attention
Line 181: Property-based tests to ensure mathematical equivalence with Python
Line 191: Verify status matches expected boundaries

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5238 characters
🤖 Analyzing: [██████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  44% (23/52) - health_score_thresholds.rs...🔍 DEBUG PROMPT for health_score_thresholds.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using
- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/constants/health_score_thresholds.rs
Language: rust
Comments found: 57

STRUCTURAL CONTEXT:
imports: use super::*;., Imports: use super::*;., Imports: use serde::{Deserialize, Serialize};., Imports: use proptest::prelude::*;.

COMMENTS TO ANALYZE:
Line 1: ! Health Score and Quality Thresholds
Line 3: ! Constants for calculating and categorizing codebase health metrics.
Line 4: ! These thresholds determine the boundaries between different health levels
Line 5: ! and quality categories.
Line 7: ! This is a 1:1 translation from Python src/codehud/constants/health_score_thresholds.py
Line 8: ! to ensure zero degradation in health scoring behavior.
Line 12: Thresholds for overall codebase health scoring
Line 17: Health score percentage thresholds (0.0 to 1.0)
Line 18: Excellent health threshold
Line 19: Good health threshold
Line 20: Acceptable health threshold
Line 21: Poor health threshold
Line 23: Alternative named thresholds for readability
Line 29: Get health status description based on score
Line 32: `health_score` - The health score to evaluate (0.0 to 1.0)
Line 35: A string describing the health status with emoji
Line 45: Get color coding for health score display
Line 48: `health_score` - The health score to evaluate (0.0 to 1.0)
Line 51: A string representing the color for display
Line 61: Determine if health score requires immediate attention
Line 64: `health_score` - The health score to evaluate (0.0 to 1.0)
Line 67: `true` if the health score requires immediate attention
Line 73: Thresholds for code quality metrics
Line 78: Test coverage thresholds
Line 79: 90% coverage or above
Line 80: 80% coverage threshold
Line 81: 70% coverage threshold
Line 82: 50% minimum coverage
Line 84: Code duplication thresholds
Line 85: 5% duplication or less
Line 86: 10% duplication threshold
Line 87: 15% duplication threshold
Line 89: Documentation coverage thresholds
Line 90: 85% documentation coverage
Line 91: 70% documentation coverage
Line 92: 50% minimum documentation
Line 94: Get coverage status description
Line 97: `coverage` - The coverage ratio to evaluate (0.0 to 1.0)
Line 100: A string describing the coverage status
Line 111: Get code duplication status description
Line 114: `duplication` - The duplication ratio to evaluate (0.0 to 1.0)
Line 117: A string describing the duplication status
Line 171: Boundary tests to ensure exact Python equivalence
Line 174: Health score boundaries
Line 187: Property-based tests for mathematical equivalence
Line 199: Verify status and color alignment

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5231 characters
🤖 Analyzing: [███████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░]  46% (24/52) - algorithms.rs...🔍 DEBUG PROMPT for algorithms.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using
- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/graph/algorithms.rs
Language: rust
Comments found: 46

STRUCTURAL CONTEXT:
imports: Imports: use petgraph::{Graph, Directed};., Imports: use std::collections::{HashMap, HashSet, VecDeque};., Imports: use super::*;., Imports: use super::{GraphNodeId, CentralityMetrics, NetworkMetrics};., Imports: use petgraph::graph::{NodeIndex, EdgeIndex};., Imports: use petgraph::algo::{connected_components, has_path_connecting, dijkstra};., use super::*;., use super::{GraphNodeId, CentralityMetrics, NetworkMetrics};., Imports: use petgraph::Graph;., Imports: use petgraph::visit::{EdgeRef, IntoNodeReferences, IntoEdgeReferences};.
structure: calls Self::single_source_shortest_path_length., calls CentralityAlgorithms::degree_centrality., calls VecDeque::new., calls CycleDetection::find_all_cycles., calls HashMap::new., calls Self::clustering_coefficient., calls CentralityAlgorithms::single_source_shortest_path_length., calls HashSet::new., calls NetworkAnalysis::clustering_coefficient., calls Self::dfs_cycles., calls Graph::new., calls NetworkAnalysis::graph_density., calls CentralityAlgorithms::pagerank_centrality.

COMMENTS TO ANALYZE:
Line 1: ! Graph algorithms for CodeHUD analysis
Line 3: ! NetworkX-equivalent implementations of graph algorithms:
Line 4: ! - Centrality calculations (betweenness, closeness, degree, eigenvector, PageRank)
Line 5: ! - Cycle detection
Line 6: ! - Strongly connected components
Line 7: ! - Shortest paths
Line 8: ! - Clustering coefficients
Line 17: Centrality algorithm implementations
Line 21: Calculate degree centrality for all nodes
Line 22: Degree centrality = degree(node) / (n - 1) where n is total nodes
Line 44: Calculate betweenness centrality using Brandes' algorithm
Line 45: Measures how often a node appears on shortest paths between other nodes
Line 50: Initialize centrality to 0 for all nodes
Line 55: For each node, calculate shortest paths to all other nodes
Line 77: BFS to find shortest paths
Line 84: First time we see this node
Line 90: Shortest path to neighbor via current
Line 98: Accumulation - back-propagate dependencies
Line 111: Normalize for directed graphs
Line 122: Calculate closeness centrality
Line 123: Closeness centrality = (n-1) / sum(shortest_path_lengths)
Line 144: Calculate PageRank centrality using power iteration
Line 159: Initialize PageRank values
Line 172: Sum contributions from incoming edges
Line 185: Check for convergence
Line 204: Calculate single-source shortest path lengths using BFS
Line 232: Cycle detection algorithms
Line 236: Find all simple cycles in the graph using Johnson's algorithm
Line 241: For simplicity, we'll use a basic DFS-based approach
Line 242: In a production system, Johnson's algorithm would be more efficient
Line 252: DFS-based cycle detection helper
Line 262: Found a cycle back to start
Line 284: Network analysis algorithms
Line 288: Calculate clustering coefficient for a node
Line 312: Calculate average clustering coefficient for the entire graph
Line 327: Calculate graph density
Line 336: For directed graphs: max edges = n * (n - 1)
Line 341: Calculate average path length using BFS from all nodes
Line 372: Calculate graph diameter (longest shortest path)
Line 406: Node 2 should have highest centrality (connected to both others)
Line 424: All nodes should have similar PageRank in this symmetric case
Line 469: No edges - density should be 0
Line 474: One edge between two nodes - density should be 0.5

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6144 characters
🤖 Analyzing: [████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░]  48% (25/52) - metrics.rs...🔍 DEBUG PROMPT for metrics.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- orphaned_files.rs: This Rust file, `orphaned_files.rs` in the CodeHUD Rust project is designed for analyzing and managing orphaned files in a codebase. Orphaned files are those that do not contribute any functionality t
- quality.rs: This file, quality.rs, implements a Quality Data Extractor for CodeHUD in Rust. It analyzes the codebase and provides various metrics such as code quality scores, health statuses, line analysis, exter
- testing.rs: The file `testing.rs` in the `./codehud-core/src/extractors` directory of a Rust project is designed specifically for testing code analysis and quality assessment. It leverages various tools and techn
- evolution.rs: This Rust file, `evolution.rs` in the `codehud-core/src/extractors` directory of CodeHUD's source code repository, serves as an evolution data extractor for CodeHUD analysis. It analyzes code evolutio
- issues.rs: The file `issues.rs` in the Rust project `codehud-core/src/extractors` serves as an issues data extractor for CodeHUD, a comprehensive code analysis tool. It categorizes and analyzes code issues using
- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/graph/metrics.rs
Language: rust
Comments found: 47

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., Imports: use serde::{Serialize, Deserialize};., use super::GraphNodeId;., use super::*;., Imports: use super::GraphNodeId;., Imports: use std::collections::HashMap;., Imports: use petgraph::graph::NodeIndex;.
structure: calls CentralityMetrics::new., calls CouplingMetrics::new., calls NetworkMetrics::new., calls NodeIndex::new., calls HashMap::new., calls Self::new.

COMMENTS TO ANALYZE:
Line 1: ! Graph metrics for CodeHUD analysis
Line 3: ! Implements NetworkX-equivalent metrics calculations:
Line 4: ! - Centrality metrics (betweenness, closeness, degree, eigenvector)
Line 5: ! - Coupling metrics (afferent, efferent, instability)
Line 6: ! - Graph structural metrics
Line 12: Centrality metrics for graph nodes
Line 15: Betweenness centrality for each node
Line 17: Closeness centrality for each node
Line 19: Degree centrality for each node
Line 21: Eigenvector centrality for each node
Line 23: PageRank scores for each node
Line 28: Create empty centrality metrics
Line 39: Get the most central node by betweenness centrality
Line 47: Get the most central node by closeness centrality
Line 55: Get the highest degree node
Line 63: Get top N nodes by PageRank
Line 70: Calculate average centrality values
Line 88: Average centrality values
Line 98: Coupling metrics for measuring module dependencies
Line 101: Afferent coupling (Ca) - number of incoming dependencies
Line 103: Efferent coupling (Ce) - number of outgoing dependencies
Line 105: Instability (I) - Ce / (Ca + Ce)
Line 107: Abstractness (A) - ratio of abstract classes to total classes
Line 109: Distance from main sequence (D) - |A + I - 1|
Line 114: Create empty coupling metrics
Line 125: Calculate instability for a node
Line 139: Calculate distance from main sequence for a node
Line 148: Get most coupled nodes (highest afferent + efferent)
Line 163: Get most unstable nodes
Line 170: Calculate all coupling metrics for all nodes
Line 180: Get summary statistics
Line 199: Summary statistics for coupling metrics
Line 210: Network analysis metrics
Line 215: Average clustering coefficient
Line 217: Average path length
Line 219: Diameter of the graph
Line 221: Number of connected components
Line 223: Largest component size
Line 228: Create new network metrics
Line 240: Check if the network is sparse
Line 245: Check if the network is dense
Line 250: Get network complexity score (0-1 scale)
Line 270: Helper function to calculate average of HashMap values
Line 279: Helper function to calculate average of HashMap usize values
Line 328: Ce / (Ca + Ce) = 2 / (3 + 2)
Line 353: 0.5 = 1/2.0

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5381 characters
📦 Processing batch 6/11 (5 files)...
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (26/52) - algorithms_minimal.rs...🔍 DEBUG PROMPT for algorithms_minimal.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto
- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/graph/algorithms_minimal.rs
Language: rust
Comments found: 36

STRUCTURAL CONTEXT:
structure: calls Self::local_clustering_coefficient., calls HashMap::new., calls VecDeque::new., calls Self::single_source_shortest_path_length., calls Self::dfs_find_cycles., calls f64::max., calls HashSet::new., pagerank_centrality is a wrapper for HashMap.new (lines 191)., calls CentralityAlgorithms::single_source_shortest_path_length.
imports: Imports: use petgraph::visit::EdgeRef;., Imports: use petgraph::{Graph, Directed, Direction};., Imports: use std::collections::{HashMap, HashSet, VecDeque};., Imports: use petgraph::graph::NodeIndex;., Imports: use petgraph::algo::{tarjan_scc, is_cyclic_directed};.

COMMENTS TO ANALYZE:
Line 1: ! Full graph algorithms implementation - NetworkX equivalent functionality
Line 3: ! Complete implementation of centrality metrics, cycle detection, and graph analysis
Line 4: ! with mathematical equivalence to NetworkX algorithms
Line 12: Complete centrality algorithms implementation equivalent to NetworkX
Line 16: Calculate degree centrality for all nodes (NetworkX equivalent)
Line 25: Degree centrality = degree / (n-1) where n is number of nodes
Line 41: Calculate betweenness centrality using Brandes algorithm (NetworkX equivalent)
Line 46: Initialize centrality to 0
Line 57: Brandes algorithm for betweenness centrality
Line 79: BFS to find shortest paths
Line 119: Normalize (for directed graphs, divide by (n-1)(n-2))
Line 130: Calculate closeness centrality (NetworkX equivalent)
Line 153: Single-source shortest path length calculation
Line 180: Calculate PageRank centrality with power iteration (NetworkX equivalent)
Line 194: Initialize PageRank values
Line 200: Build adjacency information
Line 223: Sum contributions from incoming edges
Line 237: Check for convergence
Line 243: Convert to string keys
Line 250: Complete cycle detection implementation using DFS and Tarjan's algorithm
Line 254: Find all cycles in a directed graph using DFS
Line 301: Found a cycle - extract it from the path
Line 317: Complete network analysis with graph metrics
Line 321: Find strongly connected components using Tarjan's algorithm
Line 334: Calculate graph density (NetworkX equivalent)
Line 343: For directed graphs: density = m / (n * (n-1))
Line 348: Calculate average clustering coefficient
Line 376: Count edges between neighbors
Line 386: Clustering coefficient = actual_edges / possible_edges
Line 391: Calculate average shortest path length
Line 419: Calculate graph diameter (longest shortest path)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5268 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  51% (27/52) - edges.rs...🔍 DEBUG PROMPT for edges.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto
- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/graph/edges.rs
Language: rust
Comments found: 38

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., use super::*;., Imports: use serde::{Serialize, Deserialize};.
structure: calls DependencyEdge::new., calls InheritanceEdge::new., calls CallEdge::with_weight., calls CallEdge::new., calls EdgeMetadata::new.

COMMENTS TO ANALYZE:
Line 1: ! Graph edge definitions for CodeHUD graph analysis
Line 3: ! Defines the edge types used in different graph representations:
Line 4: ! - CallEdge: Function call relationships
Line 5: ! - DependencyEdge: Module dependency relationships
Line 6: ! - InheritanceEdge: Class inheritance relationships
Line 10: Edge representing a function call relationship
Line 13: Number of times this call is made
Line 15: Weight of this edge for graph algorithms
Line 20: Create a new call edge
Line 28: Create a call edge with custom weight
Line 36: Get the call frequency (calls per unit, normalized)
Line 42: Edge representing a module dependency relationship
Line 45: Type of import (import, from_import, etc.)
Line 47: Weight of this dependency for graph algorithms
Line 52: Create a new dependency edge
Line 60: Create a dependency edge with custom weight
Line 68: Check if this is a specific import type
Line 73: Get dependency strength (weight)
Line 79: Edge representing a class inheritance relationship
Line 82: Type of inheritance (extends, implements, etc.)
Line 84: Weight of this inheritance for graph algorithms
Line 89: Create a new inheritance edge
Line 97: Create an inheritance edge with custom weight
Line 105: Check if this is a specific inheritance type
Line 110: Get inheritance strength (weight)
Line 116: Trait for graph edges to provide common functionality
Line 118: Get the weight of this edge
Line 121: Get the edge type as string
Line 124: Check if this edge is significant (weight above threshold)
Line 160: Edge metadata for analysis
Line 163: Source file of the edge
Line 165: Target file of the edge
Line 167: Line number where relationship is defined
Line 174: Create new edge metadata
Line 184: Add line number information
Line 190: Add metadata key-value pair
Line 196: Check if files are in same directory

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4894 characters
🤖 Analyzing: [██████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░]  53% (28/52) - nodes.rs...🔍 DEBUG PROMPT for nodes.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto
- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/graph/nodes.rs
Language: rust
Comments found: 28

STRUCTURAL CONTEXT:
imports: use super::*;., Imports: use super::*;., Imports: use serde::{Serialize, Deserialize};.
structure: calls ClassNode::new., calls ModuleNode::new., calls CallNode::new.

COMMENTS TO ANALYZE:
Line 1: ! Graph node definitions for CodeHUD graph analysis
Line 3: ! Defines the node types used in different graph representations:
Line 4: ! - CallNode: Function calls in call graphs
Line 5: ! - ModuleNode: Modules/files in dependency graphs
Line 6: ! - ClassNode: Classes in inheritance graphs
Line 10: Node representing a function in the call graph
Line 15: File path where function is defined
Line 17: Line number where function is defined
Line 22: Create a new call node
Line 31: Get the qualified function name (file::function)
Line 37: Node representing a module in the dependency graph
Line 42: File path of the module
Line 44: Whether this is an external dependency
Line 49: Create a new module node
Line 58: Check if this is an internal module
Line 63: Get module type as string
Line 73: Node representing a class in the inheritance graph
Line 78: File path where class is defined
Line 80: Line number where class is defined
Line 85: Create a new class node
Line 94: Get the qualified class name (file::class)
Line 100: Trait for graph nodes to provide common functionality
Line 102: Get the display name for this node
Line 105: Get the file path for this node
Line 108: Get the line number for this node (if applicable)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4226 characters
🤖 Analyzing: [███████████████████████████░░░░░░░░░░░░░░░░░░░░░░░]  55% (29/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto
- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/graph/mod.rs
Language: rust
Comments found: 57

STRUCTURAL CONTEXT:
exports: pub use algorithms_minimal as algorithms;., pub use nodes::{CallNode, ModuleNode, ClassNode};., pub use edges::{CallEdge, DependencyEdge, InheritanceEdge};., pub use metrics::{CouplingMetrics, CentralityMetrics, NetworkMetrics};., pub use analyzer::GraphAnalyzer;.
structure: calls GraphAnalyzer::new., calls Self::new., calls GraphBuilder::new., calls CallGraph::new., calls DependencyGraph::new., calls InheritanceGraph::new., calls NodeMappings::default.
imports: Imports: pub use algorithms_minimal as algorithms;., use super::*;., Imports: pub use edges::{CallEdge, DependencyEdge, InheritanceEdge};., Imports: use petgraph::{Graph, Directed};., Imports: use petgraph::visit::{EdgeRef, IntoNodeReferences};., Imports: pub use analyzer::GraphAnalyzer;., Imports: use std::collections::{HashMap, HashSet};., Imports: use super::*;., Imports: use serde::{Serialize, Deserialize};., Imports: use petgraph::algo::{connected_components, has_path_connecting};., Imports: use anyhow::{Result, Context};., Imports: pub use nodes::{CallNode, ModuleNode, ClassNode};., Imports: pub use metrics::{CouplingMetrics, CentralityMetrics, NetworkMetrics};., Imports: use petgraph::graph::{NodeIndex, EdgeIndex};.

COMMENTS TO ANALYZE:
Line 1: ! Graph Analysis Engine - NetworkX equivalent for CodeHUD
Line 3: ! Provides zero-degradation compatibility with Python NetworkX for:
Line 4: ! - Call graph analysis
Line 5: ! - Dependency graph analysis
Line 6: ! - Inheritance graph analysis
Line 7: ! - Centrality calculations
Line 8: ! - Cycle detection
Line 9: ! - Strongly connected components
Line 10: ! - Coupling metrics
Line 26: Re-export minimal algorithms as algorithms for compatibility
Line 34: Type aliases for different graph types
Line 39: Node identifier type - using string for serialization compatibility
Line 42: Edge identifier type
Line 45: Graph analysis results combining all metrics
Line 48: Call graph centrality metrics
Line 50: Dependency graph centrality metrics
Line 52: Inheritance graph centrality metrics
Line 54: Detected cycles in all graphs
Line 56: Strongly connected components
Line 58: Coupling metrics for the codebase
Line 64: Cycle detection results
Line 67: Cycles in call graph (node names)
Line 69: Cycles in dependency graph (node names)
Line 71: Cycles in inheritance graph (node names)
Line 73: Total cycle count
Line 77: Strongly connected components analysis
Line 80: Components in call graph (node names)
Line 82: Components in dependency graph (node names)
Line 84: Components in inheritance graph (node names)
Line 86: Total component count
Line 93: Call graph stats
Line 95: Dependency graph stats
Line 97: Inheritance graph stats
Line 101: Individual graph statistics
Line 104: Number of nodes
Line 106: Number of edges
Line 108: Graph density (edges / max_possible_edges)
Line 110: Whether the graph is cyclic
Line 116: Graph builder for constructing graphs from extracted data
Line 124: Mappings between string identifiers and graph node indices
Line 127: Function name -> call graph node index
Line 129: Module name -> dependency graph node index
Line 131: Class name -> inheritance graph node index
Line 136: Create a new graph builder
Line 146: Add a function call relationship
Line 160: Add a module dependency relationship
Line 174: Add a class inheritance relationship
Line 188: Build the final graph analyzer
Line 197: Get or create a call graph node
Line 204: Will be populated later
Line 213: Get or create a dependency graph node
Line 229: Get or create an inheritance graph node
Line 298: Add same call relationship twice
Line 302: Should have 2 nodes but 2 edges

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6414 characters
🤖 Analyzing: [████████████████████████████░░░░░░░░░░░░░░░░░░░░░░]  57% (30/52) - analyzer.rs...🔍 DEBUG PROMPT for analyzer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- security.rs: This file, security.rs in the ./codehud-core/src/extractors directory of a Rust project is designed specifically for security analysis and quality assessment of codebases. It uses both AST analysis an
- lib.rs: This file, lib.rs in the `codehud-core/src` directory of CodeHUD's Rust source code repository, serves as the core analysis engine and data structures for CodeHUD. It provides a variety of features in
- test_security.rs: This Rust file, `test_security.rs`, is an entry point script for a CodeHUD project that specializes in security analysis and risk assessment of codebases. The script imports two modules - 'BaseDataExt
- test_quality.rs: The file `./codehud-core/src/bin/test_quality.rs` in the CodeHUD Rust project serves as a script for testing and quality assessment of code analysis tools. It utilizes various data extractors provided
- test_dependencies.rs: This file, `test_dependencies.rs` in the Rust project at './codehud-core/src/bin', is an entrypoint script for a CodeHUD analysis tool. It uses several data extractors from the 'codehud_core::extracto
- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/graph/analyzer.rs
Language: rust
Comments found: 48

STRUCTURAL CONTEXT:
structure: calls NetworkAnalysis::strongly_connected_components., calls CycleDetection::find_all_cycles., calls Dfs::new., calls CentralityAlgorithms::degree_centrality., calls CouplingMetrics::new., calls GraphBuilder::new., calls CentralityAlgorithms::betweenness_centrality., calls NetworkAnalysis::graph_diameter., calls NetworkAnalysis::average_path_length., calls HashSet::new., calls CentralityAlgorithms::pagerank_centrality., calls NetworkAnalysis::graph_density., calls NetworkAnalysis::average_clustering_coefficient., calls CentralityMetrics::new., calls HashMap::new., calls CentralityAlgorithms::closeness_centrality.
imports: Imports: use petgraph::visit::Dfs;., Imports: use crate::graph::{GraphBuilder, CallNode, ModuleNode, ClassNode};., Imports: use super::*;., Imports: use petgraph::visit::EdgeRef;., Imports: use petgraph::algo::{connected_components, has_path_connecting};., Imports: use std::collections::HashSet;., Imports: use std::collections::HashMap;., use super::*;., use crate::graph::{GraphBuilder, CallNode, ModuleNode, ClassNode};., Imports: use anyhow::{Result, Context};., Imports: use super::{, use super::{

COMMENTS TO ANALYZE:
Line 1: ! Graph Analyzer - Main entry point for graph analysis
Line 3: ! Orchestrates all graph analysis operations and provides NetworkX-equivalent functionality
Line 17: Main graph analyzer that orchestrates all analysis operations
Line 25: Create a new graph analyzer
Line 38: Perform complete graph analysis and return all results
Line 51: Calculate centrality metrics for call graph
Line 60: Note: Eigenvector centrality would require additional implementation
Line 61: For now, we'll use PageRank as a proxy
Line 67: Calculate centrality metrics for dependency graph
Line 80: Calculate centrality metrics for inheritance graph
Line 93: Detect cycles in all graphs (NetworkX equivalent)
Line 109: Find strongly connected components in all graphs (NetworkX equivalent)
Line 111: Use the minimal NetworkAnalysis implementation for now
Line 126: Calculate coupling metrics (NetworkX equivalent)
Line 130: Calculate coupling based on dependency graph
Line 132: Convert NodeIndex to String key
Line 135: Afferent coupling (Ca) - incoming dependencies
Line 139: Efferent coupling (Ce) - outgoing dependencies
Line 143: Calculate abstractness (simplified - would need class analysis for real implementation)
Line 144: For now, assume 0.5 as default abstractness
Line 148: Calculate derived metrics
Line 154: Calculate graph statistics
Line 163: Calculate statistics for a single graph
Line 172: For directed graphs
Line 186: Check if a graph has cycles (simplified implementation)
Line 188: Simple DFS-based cycle detection
Line 202: DFS helper for cycle detection
Line 228: Get call graph reference
Line 233: Get dependency graph reference
Line 238: Get inheritance graph reference
Line 243: Calculate network metrics for all graphs
Line 247: Call graph metrics
Line 258: Dependency graph metrics
Line 269: Inheritance graph metrics
Line 283: Calculate the size of the largest connected component
Line 308: Check if graphs have problematic patterns
Line 312: Check for problematic cycles
Line 332: Check coupling metrics
Line 349: Check graph density
Line 388: Add some relationships
Line 397: Should have calculated centrality for all graphs
Line 401: Should have detected cycles and components
Line 405: Should have calculated statistics
Line 414: Create a dependency chain
Line 422: Module C should have high afferent coupling (imported by A and B)
Line 423: Module A should have high efferent coupling (imports B and C)
Line 432: Create a dependency cycle
Line 440: Should detect the cycle as an issue

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6470 characters
📦 Processing batch 7/11 (5 files)...
🤖 Analyzing: [█████████████████████████████░░░░░░░░░░░░░░░░░░░░░]  59% (31/52) - query_engine.rs...🔍 DEBUG PROMPT for query_engine.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/query_engine.rs
Language: rust
Comments found: 100

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::read_to_string(path) (lines 363)., this scope performs file I/O via std::fs::read_to_string(file_path) (lines 429).
structure: calls SupportedLanguage::from_path., calls WalkDir::new., calls tree_sitter_typescript::language_typescript., calls Parser::new., calls QueryCursor::new., calls HashMap::new., calls tree_sitter_javascript::language., calls Self::all_languages., calls Query::new., load_query_file is a wrapper for Some.content (lines 364)., from_path is a wrapper for Some.lang (lines 187)., extract_with_query is a wrapper for Ok.None (lines 489)., calls tree_sitter_rust::language., calls tree_sitter_python::language., calls tree_sitter_java::language.
imports: Imports: use std::path::Path;., Imports: use lazy_static::lazy_static;., Imports: use anyhow::{Result, Context};., Imports: use serde_json::{Value, json};., Imports: use tree_sitter::{Language, Parser, Query, QueryCursor, Tree};., Imports: use std::sync::{Arc, Mutex};., Imports: use std::collections::HashMap;., Imports: use walkdir::WalkDir;.

COMMENTS TO ANALYZE:
Line 1: ! Tree-Sitter Query Engine
Line 3: ! Automatically detects file languages and applies appropriate tree-sitter queries
Line 4: ! for code analysis. Uses established community grammars for maximum compatibility.
Line 6: ! CRITICAL FIX APPLIED (2025-01-25): Added query limits to prevent infinite loops
Line 7: ! in comment extraction that was causing system hangs:
Line 8: ! - cursor.set_match_limit(5000): Limits tree-sitter query matches per file
Line 9: ! - max_comments = 10000: Prevents infinite comment processing loops
Line 10: ! - Error handling for invalid UTF-8 text to avoid crashes
Line 11: ! This fix resolved hanging issues when processing large Rust codebases (206 files).
Line 22: Comprehensive language support using community tree-sitter grammars
Line 25: Tier 1 - Core general-purpose
Line 40: Tier 2 - Scripting / Systems
Line 49: Tier 3 - Web / Data / Markup
Line 62: Tier 4 - Build / DevOps / Config
Line 71: Language grammar registry with metadata and extension mappings
Line 83: Get tree-sitter language for this enum
Line 86: Tier 1 - Core languages
Line 92: For now, fallback to existing parsers for other languages
Line 93: TODO: Add actual parsers as we integrate more grammars
Line 98: Get comprehensive file extensions for this language
Line 148: Get all supported languages in priority order
Line 151: Tier 1 - Most important
Line 167: Detect language from file path with comprehensive extension matching
Line 171: Handle special cases first
Line 175: Special filename detection
Line 194: Get grammar metadata for this language
Line 237: TODO: Add actual grammar info for other languages
Line 250: Query types for different analysis purposes
Line 258: Community highlights.scm for semantic analysis
Line 259: Community tags.scm for symbol extraction
Line 263: Comment extraction queries
Line 284: Main query engine that handles all tree-sitter operations
Line 291: Create new query engine with all languages and queries pre-loaded
Line 298: Initialize parsers for all supported languages
Line 308: Pre-compile all queries for performance
Line 311: Debug: Print loaded queries
Line 322: Load and compile all query files
Line 349: Load query file content with comprehensive path resolution
Line 354: Priority paths for query files
Line 368: Try downloading from community repo if not found locally
Line 372: Get standardized language name for file paths
Line 415: Try to download community query patterns (future enhancement)
Line 417: TODO: Implement automatic download of community queries
Line 418: For now, return None - queries must be present locally
Line 422: Analyze a single file automatically detecting language and applying appropriate queries
Line 424: Automatically detect language
Line 428: Read file content
Line 432: Parse with appropriate language parser
Line 439: Apply all available queries for this language
Line 446: Extract imports using enhanced semantic approach
Line 461: Extract symbols using community tags.scm
Line 466: Extract semantic highlights using community highlights.scm
Line 471: Extract comments using comment-specific queries
Line 479: Extract information using a specific query type
Line 489: Query not available for this language
Line 493: Set reasonable limits to prevent infinite processing
Line 508: Process import matches using proper tree-sitter semantic approach
Line 522: Aggregate all captures by type for semantic analysis
Line 538: Process captures semantically
Line 542: Full import declarations - create detailed records
Line 553: Individual imported items
Line 618: Absolute path markers
Line 627: Other captures - store for debugging
Line 656: Process function query matches into structured data
Line 699: Process complexity query matches into metrics
Line 722: Each match arm adds complexity
Line 742: Analyze multiple files in a directory automatically
Line 757: Update language statistics
Line 783: Process community tags.scm queries for symbol extraction
Line 821: Process community highlights.scm queries for semantic analysis
Line 864: Process comment query matches into structured comment data
Line 872: Dynamic limit based on file size - prevent infinite loops while allowing large files
Line 874: At least 50k, or 2x lines in file
Line 879: Prevent infinite processing
Line 889: Skip invalid UTF-8
Line 896: Determine comment type
Line 943: Get the global query engine instance

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8254 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  61% (32/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/pattern/mod.rs
Language: rust
Comments found: 48

STRUCTURAL CONTEXT:
structure: calls PatternStatistics::default., calls Self::load_code_smell_rules., calls Self::get_line_number., calls Self::load_anti_pattern_rules., calls Self::load_arch_pattern_rules., calls Self::new., calls Self::load_security_pattern_rules., calls PatternDetector::filter_by_severity., calls PatternDetector::get_statistics., calls Regex::new., calls HashMap::new., calls crate::Error::Config.
imports: Imports: use serde::{Serialize, Deserialize};., Imports: use std::collections::HashMap;., Imports: use super::*;., use super::*;., Imports: use regex::Regex;.

COMMENTS TO ANALYZE:
Line 1: ! Pattern detection module for CodeHUD core
Line 3: ! This module provides pattern detection capabilities for identifying
Line 4: ! anti-patterns, code smells, architectural patterns, and security patterns.
Line 6: ! The pattern detection must produce identical results to the Python implementation
Line 7: ! to ensure zero degradation in analysis accuracy.
Line 13: Types of patterns that can be detected
Line 25: Severity levels for detected patterns
Line 35: A detected pattern with location and metadata
Line 45: 0.0 to 1.0
Line 49: Rule for pattern detection
Line 60: Pattern detector that identifies various code patterns
Line 69: Anti-pattern detection rule
Line 76: Code smell detection rule
Line 83: Architectural pattern detection rule
Line 90: Security pattern detection rule
Line 98: Create a new pattern detector with default rules
Line 108: Detect all patterns in the given code
Line 115: Detect code smells
Line 118: Detect architectural patterns
Line 121: Detect security patterns
Line 127: Detect anti-patterns in code
Line 133: Calculate line numbers (Python-compatible)
Line 154: Detect code smells
Line 180: Detect architectural patterns
Line 206: Detect security patterns
Line 232: Get line number for a byte position in the code (1-indexed like Python)
Line 237: Load anti-pattern detection rules
Line 241: God Object anti-pattern
Line 255: Long parameter list
Line 286: Load code smell detection rules
Line 290: Dead code (unused imports)
Line 335: Load architectural pattern detection rules
Line 384: Load security pattern detection rules
Line 388: SQL injection vulnerability
Line 447: Filter patterns by severity
Line 454: Filter patterns by type
Line 461: Get pattern statistics
Line 493: Statistics about detected patterns

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5130 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  63% (33/52) - cargo_test.rs...🔍 DEBUG PROMPT for cargo_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/cargo_test.rs
Language: rust
Comments found: 17

STRUCTURAL CONTEXT:
structure: calls parts[i-1].parse::<usize>., calls fs::write., calls CargoTestIntegration::new., calls fs::create_dir_all., get_version is a wrapper for Err.anyhow.anyhow (lines 151)., calls chrono::Utc::now., calls Command::new., calls Stdio::null., calls Path::new.
file_i/o: this scope performs file I/O via fs::write(temp_dir.path().join("Cargo.toml"), (lines 198, 210)., this scope performs file I/O via fs::write(src_dir.join("lib.rs"), (lines 215).
imports: Imports: use super::*;., Imports: use tempfile::tempdir;., Imports: use anyhow::{Result, Context};., use super::*;., Imports: use std::fs;., Imports: use serde::{Serialize, Deserialize};., Imports: use std::path::{Path, PathBuf};., Imports: use tracing::{debug, warn};., Imports: use std::process::{Command, Stdio};.

COMMENTS TO ANALYZE:
Line 1: ! Cargo Test Integration - Rust test runner equivalent to pytest
Line 3: ! Provides integration with cargo test for Rust test execution and analysis
Line 11: Cargo test integration for Rust test analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 50: First, run tests in quiet mode to get basic results
Line 66: Parse test results
Line 72: Simple parsing - cargo test output format can vary
Line 75: Extract summary line: "test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"
Line 93: Individual test result lines
Line 101: Would need more parsing to extract
Line 108: Check for compilation errors that prevent tests from running
Line 112: Calculate test coverage (simplified - would need actual coverage tools)
Line 158: Cargo test analysis result
Line 172: Individual test case result
Line 176: "ok", "FAILED", "ignored"
Line 197: Create a Cargo.toml to simulate a Rust project
Line 209: Create a minimal Rust project

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4588 characters
🤖 Analyzing: [████████████████████████████████░░░░░░░░░░░░░░░░░░]  65% (34/52) - ruff.rs...🔍 DEBUG PROMPT for ruff.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/ruff.rs
Language: rust
Comments found: 26

STRUCTURAL CONTEXT:
imports: Imports: use tempfile::tempdir;., Imports: use anyhow::{Result, Context};., Imports: use serde::{Serialize, Deserialize};., Imports: use super::*;., Imports: use super::ExternalTool;., Imports: use std::path::{Path, PathBuf};., Imports: use tokio::process::Command;., use super::ExternalTool;., use super::*;., Imports: use std::fs;., Imports: use tracing::{debug, warn};.
file_i/o: this scope performs file I/O via fs::write(&python_file, (lines 275).
structure: calls serde_json::from_str., calls fs::write., calls RuffIntegration::new., calls Command::new., calls Path::new., get_version is a wrapper for Err.anyhow.anyhow (lines 176)., analyze_file is a wrapper for Ok.issues.Vec.new.total_issues.error_count.warning_count.info_count.fixed_count (lines 50)., analyze is a wrapper for Ok.issues.Vec.new.total_issues.error_count.warning_count.info_count.fixed_count (lines 126).

COMMENTS TO ANALYZE:
Line 1: ! Ruff Python Linter Integration
Line 3: ! Zero-degradation integration with Ruff linter matching Python static_analyzer.py behavior
Line 12: Ruff linter integration
Line 24: Analyze a single file with ruff - CRITICAL for zero-degradation compliance
Line 39: Exit code 1 is expected when issues are found
Line 47: Parse JSON output
Line 49: No issues found
Line 60: Parse ruff JSON output format
Line 68: Categorize issues by severity
Line 74: Default to info
Line 83: We don't run with --fix
Line 115: Exit code 1 is expected when issues are found
Line 123: Parse JSON output
Line 125: No issues found
Line 136: Parse ruff JSON output format
Line 144: Categorize issues by severity
Line 150: Default to info
Line 159: We don't run with --fix
Line 184: Ruff analysis result matching Python static_analyzer.py format
Line 195: Individual ruff issue/violation
Line 208: Location information for ruff issues
Line 238: Test basic functionality
Line 241: Test availability check (may or may not be installed)
Line 263: Should succeed even with empty directory
Line 273: Create a Python file with linting issues
Line 300: Should find some issues in the poorly written Python code

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4883 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  67% (35/52) - coverage.rs...🔍 DEBUG PROMPT for coverage.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- mod.rs: This file, `./codehud-core/src/constants/mod.rs` in the CodeHUD Rust project is a module that provides various constant values and threshold configurations for use throughout the analysis engine. It c
- complexity_thresholds.rs: This file, `complexity_thresholds.rs` in the CodeHUD Rust project provides constants for measuring and categorizing code complexity metrics. These thresholds help identify overly complex code that may
- health_score_thresholds.rs: This file, health_score_thresholds.rs, is a Rust implementation of constants for calculating and categorizing codebase health metrics. It sets thresholds for different health levels based on the overa
- algorithms.rs: This file, `algorithms.rs` in the `./codehud-core/src/graph` directory of a Rust project is designed for graph analysis and computation of various network metrics such as centrality measures (degree, 
- metrics.rs: This file, metrics.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for performing comprehensive network analysis and centrality calculations on a gra
- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/coverage.rs
Language: rust
Comments found: 12

STRUCTURAL CONTEXT:
imports: Imports: use tokio::process::Command;., use super::*;., Imports: use super::*;., use super::ExternalTool;., Imports: use super::ExternalTool;., Imports: use std::path::{Path, PathBuf};., Imports: use serde::{Serialize, Deserialize};., Imports: use tempfile::tempdir;., Imports: use tracing::{debug, warn};., Imports: use std::fs;., Imports: use anyhow::{Result, Context};.
structure: calls CoverageIntegration::new., get_coverage_report is a wrapper for Ok.CoverageResult.default (lines 90)., calls Command::new., get_version is a wrapper for Err.anyhow.anyhow (lines 64)., run_tests_with_coverage is a wrapper for Ok.result (lines 117)., calls Path::new., calls CoverageResult::default., calls serde_json::from_str.

COMMENTS TO ANALYZE:
Line 1: ! Coverage.py Test Coverage Integration
Line 3: ! Zero-degradation integration with Coverage.py for test coverage analysis
Line 39: Try to get existing coverage data first
Line 45: If no existing coverage data, try to run tests with coverage
Line 74: Get JSON coverage report
Line 93: Parse coverage JSON report
Line 101: Try to run tests with coverage (common patterns)
Line 115: Test execution completed, try to get report
Line 122: If all attempts fail, return empty result
Line 181: Calculate coverage quality metrics
Line 205: Coverage.py JSON report structures
Line 292: Test availability (may or may not be installed)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4174 characters
📦 Processing batch 8/11 (5 files)...
🤖 Analyzing: [██████████████████████████████████░░░░░░░░░░░░░░░░]  69% (36/52) - radon.rs...🔍 DEBUG PROMPT for radon.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional
- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/radon.rs
Language: rust
Comments found: 17

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via fs::write(&python_file, (lines 415).
structure: calls RadonIntegration::new., calls serde_json::from_str., get_version is a wrapper for Err.anyhow.anyhow (lines 85)., calls Path::new., run_cyclomatic_complexity is a wrapper for Ok.CyclomaticComplexityResult.default (lines 115)., run_maintainability_index is a wrapper for Ok.MaintainabilityResult.default (lines 177)., calls CyclomaticComplexityResult::default., calls MaintainabilityResult::default., run_halstead_analysis is a wrapper for Ok.HalsteadResult.default (lines 227)., calls Command::new., calls HalsteadResult::default.
imports: Imports: use tempfile::tempdir;., Imports: use super::*;., Imports: use anyhow::{Result, Context};., Imports: use tokio::process::Command;., use super::ExternalTool;., Imports: use super::ExternalTool;., use super::*;., Imports: use tracing::{debug, warn};., Imports: use std::fs;., Imports: use std::path::{Path, PathBuf};., Imports: use serde::{Serialize, Deserialize};.

COMMENTS TO ANALYZE:
Line 1: ! Radon Complexity Analyzer Integration
Line 3: ! Zero-degradation integration with Radon complexity analyzer matching Python behavior
Line 39: Run cyclomatic complexity analysis
Line 42: Run maintainability index analysis
Line 45: Run halstead complexity analysis
Line 98: Show all functions
Line 110: Parse radon CC JSON output
Line 121: Parse the nested JSON structure
Line 172: Parse radon MI JSON output
Line 222: Parse radon Halstead JSON output
Line 393: Test availability (may or may not be installed)
Line 413: Create a Python file with varying complexity
Line 501: Should find some functions with varying complexity

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4428 characters
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  71% (37/52) - rustfmt.rs...🔍 DEBUG PROMPT for rustfmt.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional
- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/rustfmt.rs
Language: rust
Comments found: 12

STRUCTURAL CONTEXT:
structure: calls fs::write., analyze is a wrapper for Ok.total_files.files_needing_formatting.properly_formatted_files.formatting_issues.Vec.new.analysis_timestamp.chrono.Utc.now.to_rfc3339.scan_successful.error_message.None (lines 81)., calls chrono::Utc::now., calls Command::new., calls Stdio::null., calls RustfmtIntegration::new., calls fs::create_dir_all., calls Path::new., get_version is a wrapper for Err.anyhow.anyhow (lines 163).
file_i/o: this scope performs file I/O via fs::write(src_dir.join("main.rs"), (lines 248)., this scope performs file I/O via fs::write(src_dir.join("lib.rs"), (lines 225, 249)., this scope performs file I/O via fs::write(temp_dir.path().join("Cargo.toml"), (lines 208, 220)., this scope performs file I/O via std::fs::read_dir(dir) (lines 36).
imports: Imports: use serde::{Serialize, Deserialize};., Imports: use std::process::{Command, Stdio};., Imports: use super::*;., Imports: use tempfile::tempdir;., Imports: use anyhow::{Result, Context};., Imports: use std::path::{Path, PathBuf};., Imports: use std::fs;., use super::*;., Imports: use tracing::{debug, warn};.

COMMENTS TO ANALYZE:
Line 1: ! Rustfmt Integration - Rust code formatter
Line 3: ! Provides integration with rustfmt for Rust code formatting analysis
Line 11: Rustfmt integration for Rust code formatting analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 28: Get all Rust files in the project
Line 95: Check each Rust file for formatting issues
Line 108: Get the diff to show what needs to be formatted
Line 170: Rustfmt analysis result
Line 182: Individual formatting issue found by rustfmt
Line 207: Create a Cargo.toml to simulate a Rust project
Line 219: Create a Rust project with poorly formatted code
Line 245: Create some Rust files

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4557 characters
🤖 Analyzing: [████████████████████████████████████░░░░░░░░░░░░░░]  73% (38/52) - mypy.rs...🔍 DEBUG PROMPT for mypy.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional
- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/mypy.rs
Language: rust
Comments found: 15

STRUCTURAL CONTEXT:
imports: Imports: use serde::{Serialize, Deserialize};., use super::*;., Imports: use super::ExternalTool;., Imports: use std::fs;., Imports: use anyhow::{Result, Context};., Imports: use std::path::{Path, PathBuf};., Imports: use tokio::process::Command;., Imports: use tempfile::tempdir;., Imports: use super::*;., Imports: use tracing::{debug, warn};., use super::ExternalTool;.
structure: calls Path::new., calls Command::new., calls MypyIntegration::new., analyze is a wrapper for Ok.total_errors.total_notes.errors.Vec.new (lines 59)., get_version is a wrapper for Err.anyhow.anyhow (lines 112).
file_i/o: this scope performs file I/O via fs::write(&python_file, (lines 234).

COMMENTS TO ANALYZE:
Line 1: ! MyPy Type Checker Integration
Line 3: ! Zero-degradation integration with MyPy type checker matching Python behavior
Line 54: Combine stdout and stderr as mypy can output to both
Line 58: No issues found
Line 66: Parse mypy output line by line
Line 77: Skip lines that are not error/note messages
Line 82: Parse mypy error format: filename:line:column: error: message [error-code]
Line 122: Parse format: filename:line:column: error: message [error-code]
Line 134: Extract severity and message
Line 142: Default to error
Line 145: Extract error code if present [error-code]
Line 212: Test availability (may or may not be installed)
Line 232: Create a Python file with type issues
Line 265: Should find some type errors
Line 274: Test parsing different mypy output formats

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4248 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (39/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional
- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/mod.rs
Language: rust
Comments found: 47

STRUCTURAL CONTEXT:
imports: Imports: use serde::{Serialize, Deserialize};., Imports: use std::path::{Path, PathBuf};., Imports: use tokio::process::Command as TokioCommand;., Imports: use std::process::{Command, Stdio};., Imports: use anyhow::{Result, Context};., Imports: use tracing::{info, warn, debug};., Imports: use super::*;., Imports: use std::collections::HashMap;., use super::*;., Imports: use tempfile::tempdir;.
structure: calls mypy::MypyIntegration::new., calls coverage::CoverageIntegration::new., calls radon::RadonIntegration::new., calls clippy::ClippyIntegration::new., calls bandit::BanditIntegration::new., calls pylint::PylintIntegration::new., calls RustQualityAnalysisResult::default., calls vulture::VultureIntegration::new., calls ExternalToolManager::new., calls cargo_test::CargoTestIntegration::new., calls SecurityAnalysisResult::default., calls git::GitIntegration::new., calls cargo_audit::CargoAuditIntegration::new., calls QualityAnalysisResult::default., calls RustSecurityAnalysisResult::default., calls Stdio::null., calls HashMap::new., calls TokioCommand::new., calls rustfmt::RustfmtIntegration::new., calls ripgrep::RipgrepTool::new., calls ruff::RuffIntegration::new.

COMMENTS TO ANALYZE:
Line 1: ! External Tool Integration System
Line 3: ! Manages integration with external code analysis tools (ruff, pylint, mypy, bandit, etc.)
Line 4: ! providing zero-degradation compatibility with Python implementation.
Line 30: External tool manager coordinating all static analysis tools
Line 46: Create new external tool manager
Line 65: Check availability of all external tools
Line 95: Check if a specific tool is available
Line 109: Get available tools
Line 119: Run all available quality analysis tools
Line 125: Run ruff if available
Line 136: Run pylint if available
Line 147: Run mypy if available
Line 158: Run bandit if available
Line 169: Run radon if available
Line 180: Run vulture if available
Line 191: Run coverage if available
Line 202: Run git analysis if available
Line 213: Run ripgrep if available
Line 227: Run security analysis with available tools
Line 233: Bandit is the primary security tool
Line 247: Get bandit integration if available
Line 257: Combined results from all quality analysis tools
Line 271: Security analysis results
Line 277: Rust-specific tool manager coordinating Rust static analysis tools
Line 290: Create new Rust tool manager
Line 306: Check availability of all Rust tools
Line 338: Check if a cargo subcommand is available
Line 355: Check if a specific tool is available
Line 369: Get available tools
Line 379: Run all available Rust quality analysis tools
Line 385: Run clippy if available
Line 396: Run rustfmt if available
Line 407: Run cargo test if available
Line 418: Run git analysis if available
Line 429: Run ripgrep if available
Line 443: Run security analysis with available Rust tools
Line 449: Cargo audit is the primary security tool for Rust
Line 464: Combined results from all Rust quality analysis tools
Line 474: Rust security analysis results
Line 480: Base trait for all external tool integrations
Line 485: Check if the tool is available
Line 488: Run the analysis
Line 491: Get the tool name
Line 494: Get the tool version
Line 508: Check tool availability
Line 511: Should not crash even if no tools are available

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6065 characters
🤖 Analyzing: [██████████████████████████████████████░░░░░░░░░░░░]  76% (40/52) - cargo_audit.rs...🔍 DEBUG PROMPT for cargo_audit.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- algorithms_minimal.rs: This file, `algorithms_minimal.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, provides a comprehensive set of graph algorithms and centrality calculations eq
- edges.rs: This file, `edges.rs` in the CodeHUD Rust project's graph directory, serves as a module for defining edge types used in different graph representations and performing various operations on these edges
- nodes.rs: This file, nodes.rs in the ./codehud-core/src/graph directory of CodeHUD's Rust source code repository, is designed for graph analysis and computation of various network metrics such as centrality mea
- mod.rs: This file serves as the core engine for graph analysis and computation of various network metrics such as centrality measures (degree, betweenness centrality), cycle detection, strongly connected comp
- analyzer.rs: This file, `analyzer.rs` in the `./codehud-core/src/graph` directory of CodeHUD's Rust source code repository, is designed as a comprehensive tool for graph analysis and provides equivalent functional
- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/cargo_audit.rs
Language: rust
Comments found: 16

STRUCTURAL CONTEXT:
network_i/o: this scope calls Command::new("cargo") (lines 50).
structure: calls CargoAuditIntegration::new., analyze is a wrapper for Ok.total_vulnerabilities.high_severity.medium_severity.low_severity.vulnerabilities.Vec.new.analysis_timestamp.chrono.Utc.now.to_rfc3339.scan_successful.error_message.Some.stderr.to_string (lines 68)., calls Path::new., calls fs::write., get_version is a wrapper for Err.anyhow.anyhow (lines 144)., calls Stdio::null., calls serde_json::from_str., calls Command::new., calls chrono::Utc::now.
imports: use super::*;., Imports: use anyhow::{Result, Context};., Imports: use std::path::{Path, PathBuf};., Imports: use std::process::{Command, Stdio};., Imports: use tracing::{debug, warn};., Imports: use serde::{Serialize, Deserialize};., Imports: use super::*;., Imports: use tempfile::tempdir;., Imports: use std::fs;.
file_i/o: this scope performs file I/O via fs::write(temp_dir.path().join("Cargo.toml"), (lines 240, 252).

COMMENTS TO ANALYZE:
Line 1: ! Cargo Audit Integration - Rust security scanner equivalent to bandit
Line 3: ! Provides integration with cargo audit for Rust security vulnerability scanning
Line 11: Cargo audit integration for Rust security analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 54: Don't update advisory database during analysis
Line 63: Cargo audit returns non-zero if vulnerabilities are found
Line 80: Parse cargo audit JSON output
Line 85: No vulnerabilities found
Line 151: Determine severity based on vulnerability metadata
Line 153: Simple heuristic based on keywords in title/description
Line 168: Cargo audit analysis result
Line 181: Individual vulnerability found by cargo audit
Line 195: Raw cargo audit report structure
Line 239: Create a Cargo.toml to simulate a Rust project
Line 251: Create a Cargo.toml
Line 257: This will depend on whether cargo audit is installed

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4665 characters
📦 Processing batch 9/11 (5 files)...
🤖 Analyzing: [███████████████████████████████████████░░░░░░░░░░░]  78% (41/52) - pylint.rs...🔍 DEBUG PROMPT for pylint.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n
- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/pylint.rs
Language: rust
Comments found: 26

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via fs::write(&python_file, (lines 256).
imports: Imports: use tempfile::tempdir;., Imports: use serde::{Serialize, Deserialize};., Imports: use std::fs;., use super::ExternalTool;., Imports: use super::ExternalTool;., Imports: use tokio::process::Command;., Imports: use tracing::{debug, warn};., use super::*;., Imports: use anyhow::{Result, Context};., Imports: use super::*;., Imports: use std::path::{Path, PathBuf};.
structure: calls Command::new., calls serde_json::from_str., analyze_file is a wrapper for Ok.messages.Vec.new.total_messages.error_count.warning_count.refactor_count.convention_count (lines 42)., calls PylintIntegration::new., analyze is a wrapper for Ok.PylintResult.default (lines 122)., get_version is a wrapper for Err.anyhow.anyhow (lines 164)., calls PylintResult::default., calls Path::new.

COMMENTS TO ANALYZE:
Line 1: ! Pylint Code Quality Analyzer Integration
Line 3: ! Zero-degradation integration with Pylint matching Python static_analyzer.py behavior
Line 24: Analyze a single file with pylint - CRITICAL for zero-degradation compliance
Line 30: Disable some docstring warnings for cleaner output
Line 39: Parse JSON output - pylint returns array of messages
Line 41: No issues found
Line 52: Parse pylint JSON output format
Line 61: Categorize messages by type
Line 68: Default to convention
Line 101: Disable some docstring warnings for cleaner output
Line 108: Pylint can have various exit codes, we care about the output regardless
Line 112: No issues found or no Python files
Line 116: Parse pylint JSON output
Line 131: Categorize messages by type
Line 138: Default to warning
Line 168: Extract version line from pylint output
Line 178: Pylint analysis result
Line 189: Individual pylint message
Line 234: Test availability (may or may not be installed)
Line 254: Create a Python file with various pylint issues
Line 287: Should find some convention issues at minimum

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4707 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (42/52) - vulture.rs...🔍 DEBUG PROMPT for vulture.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n
- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/vulture.rs
Language: rust
Comments found: 17

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via fs::write(&python_file, (lines 273).
imports: Imports: use super::*;., Imports: use tokio::process::Command;., Imports: use std::path::{Path, PathBuf};., Imports: use serde::{Serialize, Deserialize};., Imports: use super::ExternalTool;., Imports: use std::fs;., Imports: use tempfile::tempdir;., Imports: use anyhow::{Result, Context};., use super::*;., Imports: use tracing::{debug, warn};., use super::ExternalTool;.
structure: analyze is a wrapper for Ok.VultureResult.default (lines 54)., get_version is a wrapper for Err.anyhow.anyhow (lines 112)., calls Command::new., calls VultureResult::default., calls VultureIntegration::new., calls Path::new.

COMMENTS TO ANALYZE:
Line 1: ! Vulture Dead Code Detector Integration
Line 3: ! Zero-degradation integration with Vulture dead code detector matching Python behavior
Line 41: Only report high-confidence dead code
Line 53: No dead code found
Line 57: Parse vulture output (line-based format)
Line 71: Categorize dead code by type
Line 122: Parse vulture output format: filename:line: unused item 'name' (confidence%)
Line 132: Extract item type and name from message
Line 146: Parse messages like:
Line 147: "unused function 'old_function' (100% confidence)"
Line 148: "unused variable 'unused_var' (90% confidence)"
Line 149: "unused import 'os' (80% confidence)"
Line 169: Extract name between single quotes
Line 184: Extract confidence percentage
Line 251: Test availability (may or may not be installed)
Line 271: Create a Python file with dead code
Line 335: Should find some dead code

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4345 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  82% (43/52) - ripgrep.rs...🔍 DEBUG PROMPT for ripgrep.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n
- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/ripgrep.rs
Language: rust
Comments found: 43

STRUCTURAL CONTEXT:
imports: Imports: use std::path::Path;., Imports: use tokio::process::Command;., Imports: use tokio::fs;., Imports: use async_trait::async_trait;., Imports: use super::*;., use super::ExternalTool;., Imports: use super::ExternalTool;., Imports: use anyhow::{Context, Result};., Imports: use tempfile::TempDir;., Imports: use serde::{Deserialize, Serialize};., use super::*;.
file_i/o: this scope performs file I/O via fs::write(file_path, (lines 306).
structure: search_with_options is a wrapper for Ok.matches.Vec.new.stats.total_matches.files_with_matches.files_searched.search_time_ms.success.error.Some.String.from_utf8_lossy.output.stderr.to_string (lines 110)., parse_ripgrep_match is a wrapper for Ok.file_path.path.to_string.line_number.column_number.start.matched_text.line_text.line_data.to_string.pattern.pattern.to_string (lines 169)., calls RipgrepTool::new., calls RipgrepTool::is_available., calls RipgrepTool::version., calls Default::default., calls serde_json::from_str::<serde_json::Value>., calls RipgrepOptions::default., calls fs::write., calls Self::version., calls Self::is_available., calls TempDir::new., calls Command::new.

COMMENTS TO ANALYZE:
Line 9: Ripgrep integration for fast text search and pattern analysis
Line 15: A match found by ripgrep
Line 18: The file path where the match was found
Line 20: Line number (1-indexed)
Line 22: Column number (1-indexed)
Line 24: The matched text
Line 26: The full line containing the match
Line 28: The pattern that was matched
Line 32: Results from ripgrep search
Line 35: List of matches found
Line 39: Whether the search was successful
Line 41: Error message if any
Line 45: Search statistics from ripgrep
Line 48: Total number of matches found
Line 50: Number of files with matches
Line 52: Number of files searched
Line 54: Search time in milliseconds
Line 59: Create a new ripgrep tool instance
Line 66: Search for a pattern in the codebase
Line 71: Search with custom options
Line 102: Add the pattern and path
Line 142: ripgrep doesn't provide this in JSON output
Line 151: Parse a ripgrep JSON match entry
Line 172: Convert to 1-indexed
Line 181: Fallback if JSON parsing fails
Line 192: Check if ripgrep is available
Line 202: Get ripgrep version
Line 218: Options for ripgrep search
Line 221: Case insensitive search
Line 223: Word boundary matching
Line 227: File type filter (e.g., "py", "js", "rs")
Line 229: Glob pattern for file filtering
Line 231: Maximum number of matches per file
Line 240: Default analysis: search for common patterns that might indicate code issues
Line 334: Case sensitive search should not find 'todo'
Line 340: Only the comment
Line 342: Case insensitive should find both
Line 362: Should find TODO, FIXME, XXX
Line 382: Should only find matches in Python files
Line 390: Test if ripgrep is available (may fail in some test environments)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5609 characters
🤖 Analyzing: [██████████████████████████████████████████░░░░░░░░]  84% (44/52) - bandit.rs...🔍 DEBUG PROMPT for bandit.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n
- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/bandit.rs
Language: rust
Comments found: 34

STRUCTURAL CONTEXT:
structure: calls serde_json::from_str., analyze_file is a wrapper for Ok.issues.Vec.new.total_issues.high_severity.medium_severity.low_severity.confidence_high.confidence_medium.confidence_low (lines 41)., calls Path::new., analyze is a wrapper for Ok.BanditResult.default (lines 155)., calls BanditResult::default., get_version is a wrapper for Err.anyhow.anyhow (lines 213)., calls Command::new., calls BanditIntegration::new.
imports: use super::ExternalTool;., Imports: use std::path::{Path, PathBuf};., Imports: use serde::{Serialize, Deserialize};., use super::*;., Imports: use tracing::{debug, warn};., Imports: use tokio::process::Command;., Imports: use tempfile::tempdir;., Imports: use anyhow::{Result, Context};., Imports: use super::ExternalTool;., Imports: use super::*;., Imports: use std::fs;.
file_i/o: this scope performs file I/O via fs::write(&python_file, (lines 341, 406).

COMMENTS TO ANALYZE:
Line 1: ! Bandit Security Analyzer Integration
Line 3: ! Zero-degradation integration with Bandit security scanner matching Python behavior
Line 23: Analyze a single file with bandit - CRITICAL for zero-degradation security compliance
Line 30: Quiet (no progress bar)
Line 38: Parse JSON output
Line 40: No issues found
Line 53: Parse bandit JSON output format
Line 64: Categorize issues by severity and confidence
Line 81: Convert to simplified format
Line 107: Analyze a directory with bandit - wrapper around analyze() for compatibility
Line 109: Since bandit always analyzes the full codebase, just call analyze()
Line 133: Quiet (no progress bar)
Line 143: Bandit returns non-zero exit code when issues are found, which is expected
Line 145: No issues found or no Python files
Line 149: Parse bandit JSON output
Line 163: Count issues by severity
Line 169: Default to low
Line 173: Convert to simplified format
Line 194: TODO: Calculate from issues
Line 195: TODO: Calculate from issues
Line 196: TODO: Calculate from issues
Line 221: Bandit JSON output structures
Line 319: Test availability (may or may not be installed)
Line 339: Create a Python file with security issues
Line 395: Should find multiple security issues in the insecure code
Line 404: Create a Python file without security issues
Line 434: Should find few or no security issues in secure code
Line 435: May still have minor issues

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5077 characters
🤖 Analyzing: [███████████████████████████████████████████░░░░░░░]  86% (45/52) - clippy.rs...🔍 DEBUG PROMPT for clippy.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- query_engine.rs: The `./codehud-core/src/query_engine.rs` file in the CodeHUD Rust project is a comprehensive tool that functions as a tree-sitter query engine for code analysis. It automatically detects file language
- mod.rs: This file serves as the core pattern detection module for CodeHUD, a Rust-based software that provides functionalities for identifying anti-patterns, code smells, architectural patterns, and security 
- cargo_test.rs: This file, `./codehud-core/src/external_tools/cargo_test.rs` in the CodeHUD Rust project is designed for integration with the cargo test tool used for running and analyzing Rust tests. It provides an 
- ruff.rs: The file `ruff.rs` in the CodeHUD Rust project serves as an integration of the Ruff Python Linter, a tool that specializes in static analysis and linting for Python codebases. It offers zero-degradati
- coverage.rs: This file, `coverage.rs` in the CodeHUD Rust project, provides integration with Coverage.py for test coverage analysis. It allows retrieving existing coverage data and running tests with coverage if n
- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/clippy.rs
Language: rust
Comments found: 14

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., Imports: use std::fs;., use super::*;., Imports: use std::path::{Path, PathBuf};., Imports: use std::process::{Command, Stdio};., Imports: use anyhow::{Result, Context};., Imports: use serde::{Serialize, Deserialize};., Imports: use tempfile::tempdir;., Imports: use tracing::{debug, warn};.
file_i/o: this scope performs file I/O via fs::write(temp_dir.path().join("Cargo.toml"), (lines 197, 208).
structure: calls Stdio::null., calls chrono::Utc::now., calls serde_json::from_str::<ClippyDiagnostic>., calls Command::new., get_version is a wrapper for Err.anyhow.anyhow (lines 123)., calls Path::new., calls fs::write., calls ClippyIntegration::new.

COMMENTS TO ANALYZE:
Line 1: ! Clippy Integration - Rust linter equivalent to ruff/pylint
Line 3: ! Provides integration with cargo clippy for Rust code analysis
Line 11: Clippy integration for Rust code analysis
Line 23: Check if Cargo.toml exists to determine if this is a Rust project
Line 62: Exit code 101 means clippy found issues, which is fine
Line 69: Parse clippy JSON output
Line 97: Count issues by severity
Line 99: Clippy mainly produces warnings
Line 130: Clippy analysis result
Line 140: Individual clippy issue/warning
Line 152: Clippy diagnostic message format
Line 196: Create a Cargo.toml to simulate a Rust project
Line 207: Create a Cargo.toml
Line 212: This will depend on whether clippy is installed in the test environment

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4190 characters
📦 Processing batch 10/11 (5 files)...
🤖 Analyzing: [████████████████████████████████████████████░░░░░░]  88% (46/52) - git.rs...🔍 DEBUG PROMPT for git.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra
- pylint.rs: This file, `pylint.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with Pylint, a popular Python static code analysis tool. It provides zero-degradation integratio
- vulture.rs: The file `./codehud-core/src/external_tools/vulture.rs` in the CodeHUD Rust project serves a crucial role as an integration of Vulture, a Python dead code detector tool. It provides zero-degradation i
- ripgrep.rs: This file, `./codehud-core/src/external_tools/ripgrep.rs` in the CodeHUD Rust project, provides an integration with Ripgrep, a fast text search and pattern analysis tool. It enables users to perform s
- bandit.rs: This file, `bandit.rs` in the CodeHud Rust project, is designed for security analysis and compliance with Bandit, a tool developed by PyCQA (Python Community Quality and Association) that helps identi
- clippy.rs: The file `./codehud-core/src/external_tools/clippy.rs` in the CodeHUD Rust project is a comprehensive tool for integrating with the cargo clippy tool, a static analysis tool used for Rust code. It act

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/external_tools/git.rs
Language: rust
Comments found: 16

STRUCTURAL CONTEXT:
imports: Imports: use tempfile::tempdir;., Imports: use anyhow::{Result, Context};., Imports: use tokio::process::Command;., Imports: use super::*;., use super::*;., Imports: use std::path::{Path, PathBuf};., Imports: use serde::{Serialize, Deserialize};., Imports: use tracing::{debug, warn};., use super::ExternalTool;., Imports: use super::ExternalTool;.
structure: get_version is a wrapper for Err.anyhow.anyhow (lines 87)., calls Command::new., get_file_change_stats is a wrapper for Ok.Vec.new (lines 212)., get_author_stats is a wrapper for Ok.Vec.new (lines 252)., calls Default::default., get_recent_commits is a wrapper for Ok.Vec.new (lines 189)., analyze is a wrapper for Ok.is_git_repo.Default.default (lines 44)., parse_author_line is a wrapper for Some.author.author.to_string.commit_count (lines 335)., calls Path::new., calls GitIntegration::new.

COMMENTS TO ANALYZE:
Line 1: ! Git Version Control Integration
Line 3: ! Zero-degradation integration with Git for version control analysis
Line 50: Get repository statistics
Line 53: Get commit history
Line 56: Get file change statistics
Line 59: Get author statistics
Line 62: Get branch information
Line 97: Get total commits
Line 115: Get current branch
Line 129: Get repository status
Line 143: Get last commit info
Line 233: Sort by change count (most changed first)
Line 236: Limit to top 50 most changed files
Line 265: Get all branches
Line 282: Get remote info
Line 427: Test availability (git should be available on most systems)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4253 characters
🤖 Analyzing: [█████████████████████████████████████████████░░░░░]  90% (47/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra
- pylint.rs: This file, `pylint.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with Pylint, a popular Python static code analysis tool. It provides zero-degradation integratio
- vulture.rs: The file `./codehud-core/src/external_tools/vulture.rs` in the CodeHUD Rust project serves a crucial role as an integration of Vulture, a Python dead code detector tool. It provides zero-degradation i
- ripgrep.rs: This file, `./codehud-core/src/external_tools/ripgrep.rs` in the CodeHUD Rust project, provides an integration with Ripgrep, a fast text search and pattern analysis tool. It enables users to perform s
- bandit.rs: This file, `bandit.rs` in the CodeHud Rust project, is designed for security analysis and compliance with Bandit, a tool developed by PyCQA (Python Community Quality and Association) that helps identi
- clippy.rs: The file `./codehud-core/src/external_tools/clippy.rs` in the CodeHUD Rust project is a comprehensive tool for integrating with the cargo clippy tool, a static analysis tool used for Rust code. It act

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/cache/mod.rs
Language: rust
Comments found: 40

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::write(&cache_file, (lines 109)., this scope performs file I/O via std::fs::read_dir(&self.cache_dir) (lines 158, 179, 211, 228)., this scope performs file I/O via std::fs::read_dir(&self.cache_dir)? (lines 179)., this scope performs file I/O via std::fs::read(&cache_file) (lines 133)., this scope performs file I/O via std::fs::write(self.cache_dir.join(format!("{}.cache", (lines 149)., this scope performs file I/O via std::fs::read(&path) (lines 164).
imports: Imports: use tempfile::tempdir;., Imports: use serde::{Serialize, Deserialize};., Imports: use super::*;., use super::*;., Imports: use std::collections::HashMap;., Imports: use std::path::Path;., Imports: use std::time::{SystemTime, Duration};.
structure: calls bincode::serialize., calls ToolCache::new., calls bincode::deserialize::<CacheEntry<serde_json::Value>>., calls CacheEntry::new., calls Duration::from_secs., calls CacheStatistics::default., calls bincode::deserialize., calls CacheKey::new., calls SystemTime::now., calls SmartCache::new., calls HashMap::new., retrieve is a wrapper for Ok.None (lines 140)., calls crate::Error::Cache.

COMMENTS TO ANALYZE:
Line 1: ! Cache module for CodeHUD core
Line 3: ! This module provides intelligent caching capabilities that must exactly
Line 4: ! match the Python caching behavior for zero degradation compatibility.
Line 11: Cache key for storing analysis results
Line 21: Create a new cache key
Line 31: Generate cache key as string for storage
Line 42: Cache entry with metadata
Line 53: Create a new cache entry
Line 65: Update access statistics
Line 71: Check if cache entry is stale
Line 77: Smart cache implementation that matches Python behavior
Line 86: Create a new smart cache
Line 98: Store data in cache
Line 111: Update cache size tracking
Line 114: Evict old entries if necessary
Line 122: Retrieve data from cache
Line 137: Check if entry is stale
Line 143: Update access statistics
Line 146: Write back updated entry
Line 154: Invalidate cache entries that depend on the given file
Line 163: Check if this cache file depends on the changed file
Line 177: Evict old cache entries to free up space
Line 193: Sort by last modified time (oldest first)
Line 196: Remove oldest entries until we're under the size limit
Line 198: Keep 75% of max size
Line 209: Clear all cache entries
Line 224: Get cache statistics
Line 236: Check if stale
Line 258: Statistics about cache performance
Line 270: Tool cache for external tool results (matches Python ToolCache behavior)
Line 281: Create a new tool cache
Line 290: Store result in cache
Line 295: Evict entries if we exceed max size
Line 301: Retrieve result from cache
Line 305: Check if stale
Line 315: Remove stale entries
Line 328: Evict least recently used entry
Line 339: Clear all entries
Line 387: Store and retrieve

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5594 characters
🤖 Analyzing: [██████████████████████████████████████████████░░░░]  92% (48/52) - view_generator.rs...🔍 DEBUG PROMPT for view_generator.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra
- pylint.rs: This file, `pylint.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with Pylint, a popular Python static code analysis tool. It provides zero-degradation integratio
- vulture.rs: The file `./codehud-core/src/external_tools/vulture.rs` in the CodeHUD Rust project serves a crucial role as an integration of Vulture, a Python dead code detector tool. It provides zero-degradation i
- ripgrep.rs: This file, `./codehud-core/src/external_tools/ripgrep.rs` in the CodeHUD Rust project, provides an integration with Ripgrep, a fast text search and pattern analysis tool. It enables users to perform s
- bandit.rs: This file, `bandit.rs` in the CodeHud Rust project, is designed for security analysis and compliance with Bandit, a tool developed by PyCQA (Python Community Quality and Association) that helps identi
- clippy.rs: The file `./codehud-core/src/external_tools/clippy.rs` in the CodeHUD Rust project is a comprehensive tool for integrating with the cargo clippy tool, a static analysis tool used for Rust code. It act

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/analysis/view_generator.rs
Language: rust
Comments found: 4

STRUCTURAL CONTEXT:
structure: calls Self::new.
imports: Imports: use crate::models::analysis_result::AnalysisResult;., use crate::models::analysis_result::AnalysisResult;., Imports: use std::collections::HashMap;., Imports: use serde_json::{json, Value};., Imports: use crate::{Result, ViewType};., use crate::{Result, ViewType};.

COMMENTS TO ANALYZE:
Line 1: ! View Generator
Line 3: ! Generates formatted output for different view types
Line 17: Generate formatted view output for the specified view type
Line 34: Generate a comprehensive summary view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3287 characters
🤖 Analyzing: [███████████████████████████████████████████████░░░]  94% (49/52) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra
- pylint.rs: This file, `pylint.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with Pylint, a popular Python static code analysis tool. It provides zero-degradation integratio
- vulture.rs: The file `./codehud-core/src/external_tools/vulture.rs` in the CodeHUD Rust project serves a crucial role as an integration of Vulture, a Python dead code detector tool. It provides zero-degradation i
- ripgrep.rs: This file, `./codehud-core/src/external_tools/ripgrep.rs` in the CodeHUD Rust project, provides an integration with Ripgrep, a fast text search and pattern analysis tool. It enables users to perform s
- bandit.rs: This file, `bandit.rs` in the CodeHud Rust project, is designed for security analysis and compliance with Bandit, a tool developed by PyCQA (Python Community Quality and Association) that helps identi
- clippy.rs: The file `./codehud-core/src/external_tools/clippy.rs` in the CodeHUD Rust project is a comprehensive tool for integrating with the cargo clippy tool, a static analysis tool used for Rust code. It act

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/analysis/mod.rs
Language: rust
Comments found: 26

STRUCTURAL CONTEXT:
exports: pub use health_calculator::HealthCalculator;., pub use view_generator::ViewGenerator;., pub use pipeline::AnalysisPipeline;.
structure: calls QualityExtractor::new., calls HashMap::new., calls PerformanceExtractor::new., calls FlowExtractor::new., calls TopologyExtractor::new., calls DependenciesExtractor::new., calls OrphanedFilesExtractor::new., calls Utc::now., new is a wrapper for Err.Error.Config.format.codebase_path.display (lines 47)., calls SecurityExtractor::new., calls TestingExtractor::new., calls CodeMetrics::default., calls crate::Error::Config., calls IssuesExtractor::new., calls EvolutionExtractor::new., calls QueryEngine::new., calls AnalysisResult::new., calls crate::Error::Io., calls HealthCalculator::new.
imports: Imports: use crate::query_engine::QueryEngine;., use crate::{Result, ViewType, Pipeline};., use crate::extractors::{, Imports: pub use view_generator::ViewGenerator;., Imports: use crate::models::analysis_result::{AnalysisResult, CodeMetrics};., Imports: pub use health_calculator::HealthCalculator;., use crate::query_engine::QueryEngine;., Imports: use serde_json::{json, Value};., Imports: use crate::extractors::{, Imports: use crate::{Result, ViewType, Pipeline};., use crate::models::analysis_result::{AnalysisResult, CodeMetrics};., Imports: use std::collections::HashMap;., Imports: pub use pipeline::AnalysisPipeline;., Imports: use std::path::{Path, PathBuf};., Imports: use chrono::Utc;.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Analysis Pipeline
Line 3: ! Main analysis orchestration module that coordinates all extractors
Line 4: ! and generates comprehensive codebase analysis results.
Line 35: Main analysis orchestrator that coordinates all extractors
Line 65: Run comprehensive analysis using all extractors
Line 75: Run all extractors in parallel for better performance
Line 100: Store extracted data
Line 112: Calculate aggregate metrics
Line 116: Calculate health score
Line 125: Extract critical issues
Line 128: Generate focus recommendations
Line 136: Record analysis completion
Line 151: Generate specific view data
Line 248: Use the query engine to perform enhanced tree-sitter analysis
Line 252: Analyze the entire codebase using the enhanced tree-sitter system
Line 262: Extract metrics from topology data
Line 270: Extract metrics from quality data
Line 275: Calculate technical debt ratio based on health score
Line 280: Calculate executable lines (estimate: 70% of total lines)
Line 297: Extract critical quality issues
Line 313: Extract critical security issues
Line 371: Default recommendations if none specific

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5336 characters
🤖 Analyzing: [████████████████████████████████████████████████░░]  96% (50/52) - health_calculator.rs...🔍 DEBUG PROMPT for health_calculator.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- radon.rs: The file ./codehud-core/src/external_tools/radon.rs in the CodeHUD Rust project is designed to integrate with Radon, a complexity analysis tool for Python code. It provides functionalities such as cyc
- rustfmt.rs: This file, `rustfmt.rs` in the CodeHUD Rust project's external tools directory, provides an integration with rustfmt for Rust code formatting analysis and is designed as a tool for analyzing and sugge
- mypy.rs: This file, `mypy.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with MyPy, a static type checker for Python. It provides zero-degradation integration matching Pyt
- mod.rs: This file serves as the core module for managing and coordinating external code analysis tools, such as ruff (Python Linter), pylint, mypy, bandit, radon, vulture, coverage, git, ripgrep, rustfmt, car
- cargo_audit.rs: This file, `cargo_audit.rs` in the CodeHUD Rust project's external tools directory, provides an integration with cargo audit for Rust security vulnerability scanning. It is designed as a tool that wra
- pylint.rs: This file, `pylint.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with Pylint, a popular Python static code analysis tool. It provides zero-degradation integratio
- vulture.rs: The file `./codehud-core/src/external_tools/vulture.rs` in the CodeHUD Rust project serves a crucial role as an integration of Vulture, a Python dead code detector tool. It provides zero-degradation i
- ripgrep.rs: This file, `./codehud-core/src/external_tools/ripgrep.rs` in the CodeHUD Rust project, provides an integration with Ripgrep, a fast text search and pattern analysis tool. It enables users to perform s
- bandit.rs: This file, `bandit.rs` in the CodeHud Rust project, is designed for security analysis and compliance with Bandit, a tool developed by PyCQA (Python Community Quality and Association) that helps identi
- clippy.rs: The file `./codehud-core/src/external_tools/clippy.rs` in the CodeHUD Rust project is a comprehensive tool for integrating with the cargo clippy tool, a static analysis tool used for Rust code. It act

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/analysis/health_calculator.rs
Language: rust
Comments found: 12

STRUCTURAL CONTEXT:
structure: calls Self::new.
imports: Imports: use crate::Result;., Imports: use crate::models::analysis_result::CodeMetrics;., Imports: use serde_json::Value;., use crate::Result;., use crate::models::analysis_result::CodeMetrics;.

COMMENTS TO ANALYZE:
Line 1: ! Health Score Calculator
Line 3: ! Calculates overall codebase health score based on multiple metrics
Line 16: Calculate overall health score (0-100) based on all analysis data
Line 28: Weighted average of all scores
Line 38: Extract health score from quality data if available
Line 45: Fallback calculation based on issues
Line 74: Penalize based on security findings
Line 88: Penalize circular dependencies heavily
Line 97: Penalize high coupling
Line 107: Penalize high average complexity
Line 112: Penalize very high maximum complexity
Line 117: Penalize high technical debt

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3597 characters
📦 Processing batch 11/11 (2 files)...
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (21/52) - pipeline.rs...🔍 DEBUG PROMPT for pipeline.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- pylint.rs: This file, `pylint.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with Pylint, a popular Python static code analysis tool. It provides zero-degradation integratio
- vulture.rs: The file `./codehud-core/src/external_tools/vulture.rs` in the CodeHUD Rust project serves a crucial role as an integration of Vulture, a Python dead code detector tool. It provides zero-degradation i
- ripgrep.rs: This file, `./codehud-core/src/external_tools/ripgrep.rs` in the CodeHUD Rust project, provides an integration with Ripgrep, a fast text search and pattern analysis tool. It enables users to perform s
- bandit.rs: This file, `bandit.rs` in the CodeHud Rust project, is designed for security analysis and compliance with Bandit, a tool developed by PyCQA (Python Community Quality and Association) that helps identi
- clippy.rs: The file `./codehud-core/src/external_tools/clippy.rs` in the CodeHUD Rust project is a comprehensive tool for integrating with the cargo clippy tool, a static analysis tool used for Rust code. It act
- git.rs: The file `git.rs` in the CodeHUD Rust project is a vital part of its core module, providing an integration with Git for version control analysis. This tool enables users to gain insight into their rep
- mod.rs: This file serves as the core module for cache management in CodeHUD, a Rust-based code analysis tool. It provides intelligent caching capabilities that match the Python caching behavior for zero degra
- view_generator.rs: This file in the CodeHUD Rust project, `./codehud-core/src/analysis/view_generator.rs`, is responsible for generating formatted output for different types of analyses and views. It primarily implement
- mod.rs: This file, `./codehud-core/src/analysis/mod.rs` in the CodeHUD Rust project is a comprehensive module that orchestrates all analysis extractors and generates comprehensive codebase analysis results. I
- health_calculator.rs: This file `health_calculator.rs` in the CodeHUD Rust project is designed to calculate and analyze the overall health score of a codebase based on various metrics such as security findings, circular de

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/src/analysis/pipeline.rs
Language: rust
Comments found: 8

STRUCTURAL CONTEXT:
imports: use crate::models::analysis_result::AnalysisResult;., Imports: use super::AnalysisOrchestrator;., Imports: use crate::{Result, Pipeline};., use super::AnalysisOrchestrator;., Imports: use crate::models::analysis_result::AnalysisResult;., Imports: use std::path::Path;., use crate::{Result, Pipeline};.
structure: calls AnalysisOrchestrator::new.

COMMENTS TO ANALYZE:
Line 1: ! Analysis Pipeline Implementation
Line 3: ! Handles different analysis pipeline types (direct, legacy, etc.)
Line 13: Run analysis using the specified pipeline
Line 20: Fast, direct extraction pipeline
Line 24: Legacy pipeline with full processing (future implementation)
Line 25: For now, use the same pipeline but could be extended
Line 29: Hybrid analysis pipeline (future implementation)
Line 35: Run analysis for a specific view only

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3580 characters
🤖 Analyzing: [█████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  42% (22/52) - extraction_benchmarks.rs...🔍 DEBUG PROMPT for extraction_benchmarks.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- pylint.rs: This file, `pylint.rs` in the CodeHUD Rust project's external tools directory, is designed to integrate with Pylint, a popular Python static code analysis tool. It provides zero-degradation integratio
- vulture.rs: The file `./codehud-core/src/external_tools/vulture.rs` in the CodeHUD Rust project serves a crucial role as an integration of Vulture, a Python dead code detector tool. It provides zero-degradation i
- ripgrep.rs: This file, `./codehud-core/src/external_tools/ripgrep.rs` in the CodeHUD Rust project, provides an integration with Ripgrep, a fast text search and pattern analysis tool. It enables users to perform s
- bandit.rs: This file, `bandit.rs` in the CodeHud Rust project, is designed for security analysis and compliance with Bandit, a tool developed by PyCQA (Python Community Quality and Association) that helps identi
- clippy.rs: The file `./codehud-core/src/external_tools/clippy.rs` in the CodeHUD Rust project is a comprehensive tool for integrating with the cargo clippy tool, a static analysis tool used for Rust code. It act
- git.rs: The file `git.rs` in the CodeHUD Rust project is a vital part of its core module, providing an integration with Git for version control analysis. This tool enables users to gain insight into their rep
- mod.rs: This file serves as the core module for cache management in CodeHUD, a Rust-based code analysis tool. It provides intelligent caching capabilities that match the Python caching behavior for zero degra
- view_generator.rs: This file in the CodeHUD Rust project, `./codehud-core/src/analysis/view_generator.rs`, is responsible for generating formatted output for different types of analyses and views. It primarily implement
- mod.rs: This file, `./codehud-core/src/analysis/mod.rs` in the CodeHUD Rust project is a comprehensive module that orchestrates all analysis extractors and generates comprehensive codebase analysis results. I
- health_calculator.rs: This file `health_calculator.rs` in the CodeHUD Rust project is designed to calculate and analyze the overall health score of a codebase based on various metrics such as security findings, circular de

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-core/benches/extraction_benchmarks.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
imports: Imports: use criterion::{black_box, criterion_group, criterion_main, Criterion};.

COMMENTS TO ANALYZE:
Line 1: ! Extraction performance benchmarks for zero-degradation validation
Line 6: TODO: Implement extraction benchmarks for performance validation
Line 7: This is critical for zero-degradation requirements

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3084 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (52/52) - Complete!
✅ Phase 2 complete: 52 files analyzed with enhanced context
📄 File summaries updated: 59 total files (52 from codehud-core)
📄 Analysis metadata updated: 3 crates processed
🔍 DEBUG: Crate path for codehud-gui: ./codehud-gui
🔍 Processing 62 files from crate codehud-gui
🔍 DEBUG: First 5 files discovered for crate codehud-gui:
  1. ./codehud-gui/src/signals.rs
  2. ./codehud-gui/src/views/health_view_gui.rs
  3. ./codehud-gui/src/views/topology_view_gui.rs
  4. ./codehud-gui/src/views/metrics_view_gui.rs
  5. ./codehud-gui/src/views/tests_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/signals.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/signals.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/health_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/health_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/topology_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/topology_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/metrics_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/metrics_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/tests_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/tests_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/dependencies_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/dependencies_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/console_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/console_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/llm_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/llm_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/quality_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/quality_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/documentation_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/documentation_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/settings_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/settings_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/performance_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/performance_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/views/files_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/views/files_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/main.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/main.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/state.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/state.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/utils.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/utils.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/controllers/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/controllers/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/controllers/analysis_controller.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/controllers/analysis_controller.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/quality_dashboard.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/quality_dashboard.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/code_formatter.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/code_formatter.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/code_editor.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/code_editor.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/plugin_manager.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/plugin_manager.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/task_scheduler.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/task_scheduler.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/git_integration.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/git_integration.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/file_browser.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/file_browser.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/topology_view.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/topology_view.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/performance_monitor.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/performance_monitor.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/menu_bar.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/menu_bar.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/test_runner.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/test_runner.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/search_panel.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/search_panel.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/documentation_viewer.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/documentation_viewer.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/project_explorer.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/project_explorer.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/dependency_graph.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/dependency_graph.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/toolbar.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/toolbar.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/code_quality_metrics.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/code_quality_metrics.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/llm_debugger.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/llm_debugger.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/ai_assistant.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/ai_assistant.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/health_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/health_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/topology_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/topology_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/metrics_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/metrics_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/tests_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/tests_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/dependencies_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/dependencies_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/console_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/console_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/llm_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/llm_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/quality_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/quality_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/documentation_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/documentation_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/settings_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/settings_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/codehud-gui/src/views/files_view_gui.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/codehud-gui/src/views/files_view_gui.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/metrics_panel.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/metrics_panel.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/settings_panel.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/settings_panel.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/status_bar.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/status_bar.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/refactoring_tools.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/refactoring_tools.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/console_output.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/console_output.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/components/health_monitor.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/components/health_monitor.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/app.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/app.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/widgets/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/widgets/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/widgets/project_explorer.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/widgets/project_explorer.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/widgets/health_dashboard.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/widgets/health_dashboard.rs
🔍 DEBUG: Generating structural insights for ./codehud-gui/src/signals_pyqt5.rs
✅ DEBUG: Narrator method succeeded for ./codehud-gui/src/signals_pyqt5.rs
💾 Comments JSON updated: 83 total files (24 from codehud-gui)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-gui...
🤖 Analyzing 24 files with enhanced context and improved token limits...
📦 Processing batch 1/5 (5 files)...
🤖 Analyzing: [██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   4% (1/24) - health_view_gui.rs...🔍 DEBUG PROMPT for health_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/health_view_gui.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
imports: Imports: use tokio::sync::RwLock;., Imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use egui::{Context, Ui, Color32};., use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use std::sync::Arc;.

COMMENTS TO ANALYZE:
Line 1: ! Health View GUI
Line 3: ! Displays overall codebase health metrics and status indicators.
Line 10: Health status view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 904 characters
🤖 Analyzing: [████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   8% (2/24) - topology_view_gui.rs...🔍 DEBUG PROMPT for topology_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/topology_view_gui.rs
Language: rust
Comments found: 41

STRUCTURAL CONTEXT:
imports: use crate::{GuiView, GuiResult, GuiError, state::AppState};., Imports: use egui::{Context, Ui, ScrollArea, CollapsingHeader, Grid};., Imports: use crate::{GuiView, GuiResult, GuiError, state::AppState};., Imports: use serde_json::Value;., Imports: use tokio::sync::RwLock;., Imports: use std::sync::Arc;.
file_i/o: this scope performs file I/O via CollapsingHeader::new("🏗️ (lines 100)., this scope performs file I/O via CollapsingHeader::new("📂 (lines 155).
structure: calls ScrollArea::vertical., calls CollapsingHeader::new., calls Grid::new.

COMMENTS TO ANALYZE:
Line 1: ! Topology View - Exact Python Implementation Equivalent
Line 3: ! Displays architectural topology and file structure analysis.
Line 4: ! This is a zero-degradation implementation of the Python TopologyView.
Line 12: Topology analysis view - exact Python TopologyView equivalent
Line 17: UI state matching Python implementation
Line 25: Topology data structure matching Python analysis output
Line 75: Setup topology view UI - exact Python setup_content_ui equivalent
Line 77: Vertical layout with splitter equivalent
Line 79: Top: Summary metrics (Python create_summary_section equivalent)
Line 87: Bottom: File details table (Python create_file_table equivalent)
Line 98: Create summary section - exact Python create_summary_section equivalent
Line 137: File type breakdown (matching Python implementation)
Line 153: Create file table - exact Python create_file_table equivalent
Line 159: Table header (matching Python QTableWidget columns)
Line 184: File table content
Line 208: Show file details if selected (matching Python behavior)
Line 234: Sort table by column - exact Python table sorting equivalent
Line 263: Update data from analysis results - exact Python update_data equivalent
Line 265: Parse JSON data into TopologyData structure
Line 271: Parse topology data from JSON - Python data processing equivalent
Line 273: Extract data from JSON (matching Python data structure)
Line 282: Parse file types
Line 292: Parse complexity metrics
Line 313: Parse file details
Line 323: Parse dependency graph (if available)
Line 324: TODO: Parse from JSON
Line 371: Render view - exact Python rendering equivalent
Line 379: Handle incoming messages
Line 384: Get the view title
Line 389: Called when view becomes active (optional)
Line 394: Called when view becomes inactive (optional)
Line 399: Called when view is being closed (optional)
Line 401: true = allow close
Line 406: Update topology data
Line 407: Equivalent to update_topology_data() in Python version
Line 409: Convert from AppState topology data to view format if needed
Line 414: Update topology data if available in state
Line 416: Convert from state topology data to view format
Line 417: This would match the Python update mechanism

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3298 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  12% (3/24) - metrics_view_gui.rs...🔍 DEBUG PROMPT for metrics_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/metrics_view_gui.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
imports: Imports: use egui::{Context, Ui};., Imports: use tokio::sync::RwLock;., Imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use std::sync::Arc;., use crate::{GuiResult, GuiMessage, GuiView, state::AppState};.

COMMENTS TO ANALYZE:
Line 1: ! Metrics View GUI
Line 3: ! Displays comprehensive code metrics and analysis data.
Line 10: Metrics analysis view

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 891 characters
🤖 Analyzing: [████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  16% (4/24) - tests_view_gui.rs...🔍 DEBUG PROMPT for tests_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/tests_view_gui.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use std::sync::Arc;., Imports: use tokio::sync::RwLock;., Imports: use egui::{Context, Ui, Color32};.

COMMENTS TO ANALYZE:
Line 1: ! Tests View GUI
Line 3: ! Displays test results, coverage metrics, and test management interface.
Line 10: Test results and coverage interface
Line 56: Toggle coverage view
Line 75: Trigger test run
Line 78: Refresh test results
Line 81: Generate coverage report

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1047 characters
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (5/24) - dependencies_view_gui.rs...🔍 DEBUG PROMPT for dependencies_view_gui.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/dependencies_view_gui.rs
Language: rust
Comments found: 32

STRUCTURAL CONTEXT:
structure: calls ProgressBar::new., calls PyQtSignal::new., calls Color32::from_rgb., calls egui::Grid::new., calls DependenciesData::default., calls HashMap::new., calls egui::ScrollArea::vertical.
imports: Imports: use egui::{Context, Ui, Color32, Vec2, ProgressBar};., Imports: use serde::{Deserialize, Serialize};., use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};., Imports: use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};., Imports: use std::collections::HashMap;., Imports: use std::sync::Arc;., Imports: use tokio::sync::RwLock;.

COMMENTS TO ANALYZE:
Line 1: ! Dependencies View GUI
Line 3: ! Displays module dependencies and coupling analysis with proper GUI components.
Line 12: Dependencies analysis data structure matching Python implementation
Line 63: Dependencies and coupling analysis view matching Python DependenciesView
Line 68: PyQt5-style signals matching Python implementation
Line 77: Create new dependencies view matching Python constructor
Line 88: Get view title matching Python get_view_title
Line 93: Update content with analysis data matching Python update_content
Line 99: Render overview metrics section matching Python create_overview_section
Line 106: Left: Summary metrics matching Python metrics_widget
Line 137: Right: Coupling distribution matching Python dist_widget
Line 146: Low coupling bar
Line 156: Medium coupling bar
Line 166: High coupling bar
Line 183: Render dependencies table matching Python create_dependencies_table
Line 199: Dependencies table matching Python table structure
Line 207: Table headers matching Python setHorizontalHeaderLabels
Line 214: Sort dependencies by coupling score if enabled
Line 226: Display table rows matching Python update_dependencies_table
Line 228: Module name (clickable)
Line 239: Coupling score with color coding
Line 249: Risk level with background color matching Python implementation
Line 257: Create colored background label
Line 270: Render selected module details panel
Line 337: Main layout matching Python splitter structure (vertical split)
Line 339: Top: Overview metrics matching Python create_overview_section
Line 344: Bottom: Dependencies table matching Python create_dependencies_table
Line 347: Details panel for selected module
Line 360: Dependencies data might be updated with topology

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2877 characters
📦 Processing batch 2/5 (5 files)...
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (6/24) - console_view_gui.rs...🔍 DEBUG PROMPT for console_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/console_view_gui.rs
Language: rust
Comments found: 5

STRUCTURAL CONTEXT:
structure: calls egui::ScrollArea::vertical., calls TextEdit::multiline., calls TextEdit::singleline.
imports: Imports: use std::sync::Arc;., Imports: use tokio::sync::RwLock;., use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use egui::{Context, Ui, TextEdit};., Imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};.

COMMENTS TO ANALYZE:
Line 1: ! Console View GUI
Line 3: ! Displays console output and command execution interface.
Line 10: Console output and command interface

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2252 characters
🤖 Analyzing: [██████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  29% (7/24) - llm_view_gui.rs...🔍 DEBUG PROMPT for llm_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/llm_view_gui.rs
Language: rust
Comments found: 44

STRUCTURAL CONTEXT:
imports: Imports: use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};., Imports: use serde::{Deserialize, Serialize};., Imports: use egui::{Context, Ui, Color32, Vec2, TextEdit};., Imports: use std::sync::Arc;., Imports: use tokio::sync::RwLock;., use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};.
file_i/o: this scope performs file I/O via "Pylint (lines 360).
structure: calls egui::Button::new., calls egui::ScrollArea::vertical., calls PyQtSignal::new., calls egui::ProgressBar::new., calls egui::ComboBox::from_label., calls LlmOperationData::default., calls TextEdit::multiline., calls TextEdit::singleline.

COMMENTS TO ANALYZE:
Line 1: ! LLM/Auto Debugger View GUI
Line 3: ! Provides GUI interface for LLM-powered debugging and auto-fixing capabilities.
Line 4: ! Note: LLM functionality temporarily disabled for compilation - will be re-enabled in Phase 5b.
Line 12: LLM operation data structure matching Python implementation
Line 21: Auto-fix operation types matching Python implementation
Line 42: LLM-powered debugging and auto-fixing interface matching Python LLMDebuggerView
Line 47: PyQt5-style signals matching Python implementation
Line 51: UI state matching Python tabs
Line 55: Tab content matching Python implementation
Line 66: Create new LLM view matching Python constructor
Line 85: Get view title matching Python get_view_title
Line 90: Update content matching Python update_content
Line 95: Render auto-fix tab matching Python create_autofix_tab
Line 101: Fix type selection matching Python fix_type_combo
Line 123: Action buttons matching Python implementation
Line 134: Progress bar matching Python autofix_progress
Line 143: Output area matching Python autofix_output
Line 161: Render pattern detection tab matching Python create_patterns_tab
Line 171: Patterns output matching Python patterns_output
Line 183: Render code search tab matching Python create_search_tab
Line 189: Search type selection matching Python search_type_combo
Line 200: Query input matching Python search_query
Line 217: Search results matching Python search_output
Line 225: Render system status tab matching Python create_status_tab
Line 247: Status output matching Python status_output
Line 259: Render view renderer tab matching Python create_view_renderer_tab
Line 265: View selection matching Python view_combo
Line 285: View output matching Python view_output
Line 297: Run auto-fix operation matching Python run_autofix
Line 315: Simulate completion (in real implementation, this would be async)
Line 322: Stop running operation matching Python stop_command
Line 330: Detect patterns matching Python detect_patterns
Line 335: Run search matching Python run_search
Line 341: Simulate search results
Line 345: This would be displayed in search results area
Line 348: Refresh status matching Python refresh_status
Line 353: View dashboard matching Python view_dashboard
Line 358: Check pylint status matching Python check_pylint_status
Line 363: List views matching Python list_views
Line 368: Render view matching Python render_view
Line 377: Tab widget matching Python tab structure
Line 388: Render active tab content matching Python tab implementation
Line 406: Handle LLM request (would be implemented when LLM is re-enabled)
Line 410: Handle LLM response (would be implemented when LLM is re-enabled)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5119 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (8/24) - quality_view_gui.rs...🔍 DEBUG PROMPT for quality_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/quality_view_gui.rs
Language: rust
Comments found: 28

STRUCTURAL CONTEXT:
imports: Imports: use serde::{Deserialize, Serialize};., Imports: use tokio::sync::RwLock;., use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};., Imports: use egui::{Context, Ui, Color32, Vec2};., Imports: use std::collections::HashMap;., Imports: use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};., Imports: use std::sync::Arc;.
structure: calls PyQtSignal::new., calls Color32::from_rgb., calls egui::ComboBox::from_label., calls QualityData::default., calls egui::Grid::new., calls egui::ScrollArea::vertical., calls HashMap::new.

COMMENTS TO ANALYZE:
Line 1: ! Quality View GUI
Line 3: ! Displays code quality metrics, maintainability index, and technical debt analysis.
Line 12: Quality metrics data structure
Line 47: Quality Analysis GUI View matching Python QualityView implementation
Line 63: Create new quality view matching Python constructor
Line 76: Get view title matching Python implementation
Line 81: Update content with analysis data (matching Python update_content)
Line 87: Render quality overview section (matching Python UI structure)
Line 93: Quality score display
Line 149: Render code smells table (matching Python implementation)
Line 170: Code smells table
Line 185: Filter and display smells
Line 221: Render details panel (matching Python implementation)
Line 272: Main layout matching Python splitter structure
Line 274: Top section: Quality overview
Line 279: Middle section: Code smells table
Line 284: Bottom section: Details panel
Line 289: Toggle details panel button
Line 303: Refresh quality data from state
Line 304: This would typically fetch new data from the analysis engine

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3425 characters
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  37% (9/24) - documentation_view_gui.rs...🔍 DEBUG PROMPT for documentation_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/documentation_view_gui.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
imports: Imports: use tokio::sync::RwLock;., Imports: use std::sync::Arc;., use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use egui::{Context, Ui, Color32, TextEdit};., Imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};.
structure: calls TextEdit::multiline., calls egui::ScrollArea::vertical.

COMMENTS TO ANALYZE:
Line 1: ! Documentation View GUI
Line 3: ! Displays documentation coverage, generates docs, and manages documentation.
Line 10: Documentation management interface
Line 43: Generate coverage report
Line 61: Documentation content viewer

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2333 characters
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  41% (10/24) - settings_view_gui.rs...🔍 DEBUG PROMPT for settings_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/settings_view_gui.rs
Language: rust
Comments found: 10

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via ui.label("• (lines 81)., this scope performs file I/O via ui.group(|ui| (lines 79).
imports: Imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use tokio::sync::RwLock;., Imports: use egui::{Context, Ui, Color32};., Imports: use std::sync::Arc;.
structure: calls egui::Slider::new., calls egui::ComboBox::from_label.

COMMENTS TO ANALYZE:
Line 1: ! Settings View GUI
Line 3: ! Displays application settings and configuration options.
Line 10: Application settings and configuration

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2354 characters
📦 Processing batch 3/5 (5 files)...
🤖 Analyzing: [██████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  45% (11/24) - performance_view_gui.rs...🔍 DEBUG PROMPT for performance_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra
- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/performance_view_gui.rs
Language: rust
Comments found: 31

STRUCTURAL CONTEXT:
imports: Imports: use serde::{Deserialize, Serialize};., Imports: use tokio::sync::RwLock;., Imports: use std::collections::HashMap;., Imports: use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};., use crate::{GuiResult, GuiMessage, GuiView, signals_pyqt5::PyQtSignal, state::AppState};., Imports: use egui::{Context, Ui, Color32, Vec2, ProgressBar};., Imports: use std::sync::Arc;.
structure: calls HashMap::new., calls egui::RichText::new., calls PyQtSignal::new., calls egui::ScrollArea::vertical., calls ProgressBar::new., calls PerformanceData::default., calls Color32::from_rgb., calls egui::Grid::new., calls egui::Layout::top_down.

COMMENTS TO ANALYZE:
Line 1: ! Performance View GUI
Line 3: ! Displays performance analysis, bottlenecks, and optimization opportunities.
Line 12: Performance analysis data structure matching Python implementation
Line 100: Performance analysis view matching Python PerformanceView
Line 105: PyQt5-style signals matching Python implementation
Line 113: Create new performance view matching Python constructor
Line 123: Get view title matching Python get_view_title
Line 128: Update content with analysis data matching Python update_content
Line 134: Render performance dashboard matching Python create_performance_dashboard
Line 137: Performance score section matching Python score_section
Line 150: Large score display matching Python implementation
Line 161: Performance metrics matching Python metrics_section
Line 205: Optimization opportunities matching Python opportunities_section
Line 239: Render bottlenecks table matching Python create_bottlenecks_table
Line 245: Bottlenecks table matching Python table structure
Line 253: Table headers matching Python setHorizontalHeaderLabels
Line 261: Display bottlenecks matching Python update_bottlenecks_table
Line 263: Impact level with color coding
Line 299: Complexity with color coding
Line 318: Render selected bottleneck details panel
Line 379: Main layout matching Python splitter structure (horizontal split)
Line 381: Left: Performance dashboard matching Python create_performance_dashboard
Line 392: Right: Bottlenecks table matching Python create_bottlenecks_table
Line 399: Details panel for selected bottleneck
Line 414: Performance data might be updated after analysis

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5170 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (12/24) - files_view_gui.rs...🔍 DEBUG PROMPT for files_view_gui.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra
- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/views/files_view_gui.rs
Language: rust
Comments found: 8

STRUCTURAL CONTEXT:
structure: calls egui::ScrollArea::vertical.
imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use std::sync::Arc;., Imports: use tokio::sync::RwLock;., Imports: use crate::{GuiResult, GuiMessage, GuiView, state::AppState};., Imports: use egui::{Context, Ui, Color32};.

COMMENTS TO ANALYZE:
Line 1: ! Files View GUI
Line 3: ! Displays file browser and file management interface.
Line 10: File browser and management interface
Line 47: File tree (simplified)
Line 54: Simulate file tree structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3380 characters
🤖 Analyzing: [███████████████████████████░░░░░░░░░░░░░░░░░░░░░░░]  54% (13/24) - state.rs...🔍 DEBUG PROMPT for state.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra
- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/state.rs
Language: rust
Comments found: 26

STRUCTURAL CONTEXT:
imports: use crate::{GuiResult, GuiError};., Imports: use tokio::sync::RwLock;., Imports: use std::collections::HashMap;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::path::PathBuf;., Imports: use std::sync::Arc;., Imports: use crate::{GuiResult, GuiError};.
structure: calls HashMap::new., calls WindowLayout::default., calls Theme::default., calls UserPreferences::default., calls ResourceUsage::default., calls Self::default_component_visibility., calls PerformanceMetrics::default., calls walkdir::WalkDir::new., calls HealthStatus::default.

COMMENTS TO ANALYZE:
Line 2: use codehud_core::{CoreEngine, ProjectMetrics};  // Temporarily disabled
Line 3: use codehud_llm::LlmEngine;  // Temporarily disabled
Line 17: pub core_engine: Option<Arc<RwLock<CoreEngine>>>,  // Temporarily disabled
Line 18: pub llm_engine: Option<Arc<RwLock<LlmEngine>>>,  // Temporarily disabled
Line 45: pub metrics: Option<ProjectMetrics>,  // Temporarily disabled
Line 266: Initialize core engine (temporarily disabled)
Line 267: let core_engine = CoreEngine::new().await
Line 269: self.core_engine = Some(Arc::new(RwLock::new(core_engine)));
Line 271: Initialize LLM engine (temporarily disabled)
Line 272: let llm_engine = LlmEngine::new().await
Line 274: self.llm_engine = Some(Arc::new(RwLock::new(llm_engine)));
Line 294: Add to recent projects
Line 305: Simple language detection based on file extensions
Line 350: Default visible components
Line 361: Default hidden components

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4326 characters
🤖 Analyzing: [█████████████████████████████░░░░░░░░░░░░░░░░░░░░░]  58% (14/24) - utils.rs...🔍 DEBUG PROMPT for utils.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra
- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/utils.rs
Language: rust
Comments found: 19

STRUCTURAL CONTEXT:
structure: calls crate::GuiError::Io., validate_project_path is a wrapper for Err.GuiError.Io.std.io.Error.new.std.io.ErrorKind.InvalidInput.format.path.display (lines 176)., calls egui::Color32::from_rgb.
imports: Imports: use egui::{Context, Ui};., Imports: use crate::{GuiResult, GuiMessage};., Imports: use std::path::PathBuf;., use crate::{GuiResult, GuiMessage};.

COMMENTS TO ANALYZE:
Line 5: Base trait for all GUI views matching PyQt5 widget pattern
Line 7: Render the view content
Line 10: Handle incoming messages
Line 13: Get the view title
Line 16: Called when view becomes active (optional)
Line 21: Called when view becomes inactive (optional)
Line 26: Called when view is being closed (optional)
Line 28: true = allow close
Line 32: Base trait for GUI components matching PyQt5 widget pattern
Line 34: Get component name
Line 37: Render the component
Line 40: Handle incoming messages
Line 43: Get component visibility
Line 46: Set component visibility
Line 49: Get component enabled state
Line 52: Set component enabled state
Line 144: Weighted average of different health aspects
Line 145: performance, quality, security, maintainability

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3993 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  62% (15/24) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- health_view_gui.rs: This file, `health_view_gui.rs` in the Rust codebase, serves as a graphical user interface for displaying overall health metrics and status indicators of the codebase. It is designed to provide users 
- topology_view_gui.rs: The provided Rust file, `topology_view_gui.rs`, serves as the GUI implementation for a topology view of an application's architecture and its component interactions. It provides detailed analysis of a
- metrics_view_gui.rs: This Rust file, `metrics_view_gui.rs`, represents the graphical user interface (GUI) for displaying comprehensive code metrics and analysis data. It implements a specific view in an application's GUI 
- tests_view_gui.rs: This file serves as the graphical user interface for testing and coverage in a software application. It displays test results, coverage metrics, and provides an interface for managing tests. This incl
- dependencies_view_gui.rs: This file implements a graphical user interface for displaying module dependencies and coupling analysis in an organized manner, similar to the Python DependenciesView class. It uses Rust's egui libra
- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/lib.rs
Language: rust
Comments found: 1

STRUCTURAL CONTEXT:
exports: pub use app::CodeHudGuiApp;., pub use utils::{GuiView, GuiComponent};., pub use state::AppState;.
imports: Imports: use egui::{Context, Ui};., Imports: use anyhow::Result;., Imports: pub use utils::{GuiView, GuiComponent};., Imports: use serde::{Deserialize, Serialize};., Imports: use tokio::sync::RwLock;., Imports: use std::sync::Arc;., Imports: pub use state::AppState;., Imports: pub use app::CodeHudGuiApp;.

COMMENTS TO ANALYZE:
Line 56: Traits moved to utils.rs to avoid duplication

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3334 characters
📦 Processing batch 4/5 (5 files)...
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (16/24) - analysis_controller.rs...🔍 DEBUG PROMPT for analysis_controller.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various
- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/controllers/analysis_controller.rs
Language: rust
Comments found: 35

STRUCTURAL CONTEXT:
structure: start is a wrapper for Err.GuiError.State.to_string (lines 79)., calls PyQtSignal::new., calls GuiError::State., calls AnalysisWorker::new., calls PyQtThread::new.
file_i/o: this scope performs file I/O via PyQtThread::new("AnalysisWorker") (lines 69)., this scope performs file I/O via self.thread.terminate() (lines 166)., this scope performs file I/O via self.thread.wait() (lines 171)., this scope performs file I/O via "Worker (lines 79)., this scope performs file I/O via Err(GuiError::State("Worker (lines 79)., this scope performs file I/O via self.thread.start(|| (lines 82)., this scope performs file I/O via GuiError::State("Worker (lines 79)., this scope performs file I/O via self.thread.is_running() (lines 78, 176).
imports: Imports: use std::sync::Arc;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::path::PathBuf;., Imports: use std::collections::HashMap;., use crate::{, Imports: use tokio::sync::RwLock;., Imports: use crate::{

COMMENTS TO ANALYZE:
Line 1: ! Analysis Controller - Exact Python Implementation Equivalent
Line 3: ! This module provides the exact equivalent of the Python AnalysisController
Line 4: ! with QThread background processing for zero-degradation compliance.
Line 17: Analysis progress information matching Python AnalysisWorker
Line 28: Analysis results matching Python AnalysisController output
Line 45: Background worker thread matching Python AnalysisWorker exactly
Line 52: PyQt5-style signals matching Python implementation
Line 59: Create new analysis worker - exact Python constructor equivalent
Line 76: Start the worker thread - exact Python start() method
Line 86: Run analysis - exact Python run() method equivalent
Line 90: Emit initial progress
Line 100: Create analysis results structure
Line 164: Stop the worker thread
Line 169: Wait for worker to finish
Line 174: Check if worker is running
Line 182: Signals are created in constructor
Line 187: Connect any internal signals
Line 197: Main analysis controller matching Python AnalysisController exactly
Line 203: PyQt5-style signals matching Python implementation
Line 211: Create new analysis controller matching Python constructor
Line 224: Set codebase path
Line 229: Start analysis matching Python start_analysis method
Line 232: Stop any running analysis
Line 240: Create new worker
Line 266: Emit started signal
Line 276: Stop current analysis - exact Python method equivalent
Line 287: Check if analysis is running
Line 294: Get codebase path
Line 302: Signals are created in constructor
Line 307: Connect any internal signals

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5405 characters
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  70% (17/24) - menu_bar.rs...🔍 DEBUG PROMPT for menu_bar.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various
- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/components/menu_bar.rs
Language: rust
Comments found: 7

STRUCTURAL CONTEXT:
structure: calls GuiMessage::ProjectLoaded., render is a wrapper for Ok (lines 28)., calls GuiMessage::LlmRequest.
file_i/o: this scope performs file I/O via self.signal_bus.emit("open_project", (lines 40)., this scope performs file I/O via menu::bar(ui, (lines 31)., this scope performs file I/O via ui.menu_button("File", (lines 33).
imports: Imports: use std::sync::Arc;., use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus};., Imports: use egui::{Context, Ui, menu};., Imports: use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus};.

NO MEANINGFUL COMMENTS FOUND - ANALYZING FILE STRUCTURE ONLY:

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3447 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (18/24) - project_explorer.rs...🔍 DEBUG PROMPT for project_explorer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various
- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/components/project_explorer.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via self.signal_bus.emit("open_project_dialog", (lines 134)., this scope performs file I/O via ScrollArea::vertical() (lines 152)., this scope performs file I/O via CollapsingHeader::new(&folder_name) (lines 70)., this scope performs file I/O via ui.vertical(|ui| (lines 117)., this scope performs file I/O via self.state.try_read() (lines 156)., this scope performs file I/O via ui.horizontal(|ui| (lines 132).
structure: calls HashMap::new., calls Ok::<., calls ScrollArea::vertical., calls CollapsingHeader::new., calls GuiMessage::ProjectLoaded., render is a wrapper for Ok (lines 114).
imports: Imports: use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus, state::AppState};., Imports: use egui::{Context, Ui, ScrollArea, CollapsingHeader};., use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus, state::AppState};., Imports: use tokio::sync::RwLock;., Imports: use std::collections::HashMap;., Imports: use std::sync::Arc;., Imports: use std::path::PathBuf;.

COMMENTS TO ANALYZE:
Line 35: Group files by directory
Line 51: Render direct files first
Line 155: Try to read state without blocking
Line 163: Render project info
Line 168: Render file tree

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4050 characters
🤖 Analyzing: [███████████████████████████████████████░░░░░░░░░░░]  79% (19/24) - llm_debugger.rs...🔍 DEBUG PROMPT for llm_debugger.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various
- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/components/llm_debugger.rs
Language: rust
Comments found: 15

STRUCTURAL CONTEXT:
imports: Imports: use std::sync::Arc;., use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus, state::{AppState, ConversationState, MessageRole}};., Imports: use egui::{Context, Ui, ScrollArea, Color32, TextEdit};., Imports: use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus, state::{AppState, ConversationState, MessageRole}};., Imports: use tokio::sync::RwLock;.
structure: calls egui::TextEdit::multiline., render is a wrapper for Ok (lines 243)., render_conversation_list is a wrapper for Ok (lines 40)., calls ScrollArea::vertical., calls egui::Layout::right_to_left., calls GuiMessage::LlmRequest., calls TextEdit::multiline.
file_i/o: this scope performs file I/O via ui.vertical(|ui| (lines 246, 257, 279)., this scope performs file I/O via ui.horizontal(|ui| (lines 255)., this scope performs file I/O via self.state.try_read() (lines 196, 260, 281)., this scope performs file I/O via ui.collapsing("LLM (lines 194).

COMMENTS TO ANALYZE:
Line 24: Hidden by default
Line 84: Skip system messages if not showing them
Line 116: Metadata (if enabled)
Line 195: Try to read state without blocking
Line 254: Main content area
Line 256: Left panel - conversation list
Line 278: Right panel - conversation content and input

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4077 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  83% (20/24) - health_monitor.rs...🔍 DEBUG PROMPT for health_monitor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- console_view_gui.rs: This file, `console_view_gui.rs` in the Rust codebase, is designed for displaying console output and command execution interface. It uses egui's ScrollArea, TextEdit functionalities to display scrolli
- llm_view_gui.rs: This Rust file, `llm_view_gui.rs`, serves as the GUI implementation for an LLM (Language Model) powered debugging and auto-fixing feature in a codebase. It provides users with an interface for LLM ope
- quality_view_gui.rs: This Rust file, quality_view_gui.rs, is a graphical user interface for displaying code quality metrics and analysis data in an application's GUI. It serves as the equivalent of a Python QualityView cl
- documentation_view_gui.rs: This file, `documentation_view_gui.rs` in the Rust codebase, serves as a graphical user interface for managing and displaying documentation information about an application. It provides users with fea
- settings_view_gui.rs: This file, `settings_view_gui.rs` in the Rust codebase, is a graphical user interface (GUI) that serves as an interactive settings and configuration view for the application. This GUI displays various
- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/components/health_monitor.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
structure: calls ProgressBar::new., calls ScrollArea::vertical., render_alerts is a wrapper for Ok (lines 154)., calls Color32::from_rgb., calls egui::Layout::right_to_left., render is a wrapper for Ok (lines 219).
imports: use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus, state::{AppState, HealthStatus, AlertLevel}};., Imports: use tokio::sync::RwLock;., Imports: use std::sync::Arc;., Imports: use egui::{Context, Ui, ScrollArea, Color32, ProgressBar};., Imports: use crate::{GuiComponent, GuiMessage, GuiResult, signals::SignalBus, state::{AppState, HealthStatus, AlertLevel}};.
file_i/o: this scope performs file I/O via self.state.try_read() (lines 242)., this scope performs file I/O via ui.vertical(|ui| (lines 229)., this scope performs file I/O via ScrollArea::vertical() (lines 238).

COMMENTS TO ANALYZE:
Line 30: Overall health score
Line 241: Try to read state without blocking
Line 296: Health monitor is always enabled
Line 300: Health monitor cannot be disabled

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3819 characters
📦 Processing batch 5/5 (4 files)...
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  70% (17/24) - app.rs...🔍 DEBUG PROMPT for app.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti
- analysis_controller.rs: This file, `analysis_controller.rs`, serves as a controller for the analysis operations in an application that employs QThread for background processing and PyQt5-style signals for inter-thread commun
- menu_bar.rs: This file, `menu_bar.rs` in the Rust codebase is a component responsible for creating and managing the application's menu bar interface. The menu bar provides access to various functionalities of the 
- project_explorer.rs: This file, project_explorer.rs in the Rust codebase, is designed for managing and displaying files information about an application's GUI. It uses egui's ScrollArea, CollapsingHeader functionalities t
- llm_debugger.rs: This file, llm_debugger.rs, is a Rust component designed for the implementation of an LLM (Language Model) powered debugging and auto-fixing feature in an application's GUI. The component uses egui's 
- health_monitor.rs: This file, `health_monitor.rs` in the Rust codebase is a component responsible for monitoring and reporting application health status. It implements features such as displaying progress bars indicatin

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/app.rs
Language: rust
Comments found: 18

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via self.state.write() (lines 117)., this scope performs file I/O via self.state.try_read() (lines 234).
imports: Imports: use std::collections::HashMap;., Imports: use eframe::egui::{self, Context, Ui, ViewportBuilder};., Imports: use crate::{, use crate::{, Imports: use tokio::sync::RwLock;., Imports: use std::sync::Arc;.
structure: calls DocumentationViewerComponent::new., calls SignalBus::new., calls Box::new., calls StatusBarComponent::new., calls egui::TopBottomPanel::bottom., calls RwLock::new., calls HealthViewGui::new., calls RefactoringToolsComponent::new., calls LlmDebuggerComponent::new., calls TestsViewGui::new., calls egui::SidePanel::left., calls MetricsPanelComponent::new., calls SettingsViewGui::new., calls CodeQualityMetricsComponent::new., calls DependencyGraphComponent::new., calls TopologyViewGui::new., calls SearchPanelComponent::new., calls TaskSchedulerComponent::new., calls AiAssistantComponent::new., calls serde_json::to_string., calls PerformanceMonitorComponent::new., calls ProjectExplorerComponent::new., calls HashMap::new., calls FilesViewGui::new., calls TopologyViewComponent::new., calls DependenciesViewGui::new., calls egui::TopBottomPanel::top., calls MenuBarComponent::new., initialize is a wrapper for Ok (lines 112)., calls GitIntegrationComponent::new., calls TestRunnerComponent::new., calls PluginManagerComponent::new., calls SettingsPanelComponent::new., calls egui::CentralPanel::default., calls QualityViewGui::new., calls Arc::new., calls DocumentationViewGui::new., calls ConsoleOutputComponent::new., calls LlmViewGui::new., calls MetricsViewGui::new., calls ConsoleViewGui::new., calls ToolbarComponent::new., calls AppState::new., calls CodeFormatterComponent::new., calls HealthMonitorComponent::new., calls CodeEditorComponent::new., calls FileBrowserComponent::new., calls egui::SidePanel::right., calls QualityDashboardComponent::new.

COMMENTS TO ANALYZE:
Line 17: Core components (25+ as per plan)
Line 44: Views (11+ as per plan)
Line 76: Initialize all 25+ components
Line 121: Set up signal connections (PyQt5-style signal/slot architecture)
Line 129: Connect project explorer signals to other components
Line 140: Connect LLM signals
Line 151: Connect quality update signals
Line 192: Tab bar for switching between views
Line 203: Render active view
Line 215: Initialize immediately to skip loading screen
Line 219: Process signals (skip for now to avoid potential issues)
Line 220: if let Err(e) = self.signal_bus.process_pending() {
Line 221: log::error!("Error processing signals: {}", e);
Line 224: Render main layout
Line 233: Save application state

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5456 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (18/24) - project_explorer.rs...🔍 DEBUG PROMPT for project_explorer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti
- analysis_controller.rs: This file, `analysis_controller.rs`, serves as a controller for the analysis operations in an application that employs QThread for background processing and PyQt5-style signals for inter-thread commun
- menu_bar.rs: This file, `menu_bar.rs` in the Rust codebase is a component responsible for creating and managing the application's menu bar interface. The menu bar provides access to various functionalities of the 
- project_explorer.rs: This file, project_explorer.rs in the Rust codebase, is designed for managing and displaying files information about an application's GUI. It uses egui's ScrollArea, CollapsingHeader functionalities t
- llm_debugger.rs: This file, llm_debugger.rs, is a Rust component designed for the implementation of an LLM (Language Model) powered debugging and auto-fixing feature in an application's GUI. The component uses egui's 
- health_monitor.rs: This file, `health_monitor.rs` in the Rust codebase is a component responsible for monitoring and reporting application health status. It implements features such as displaying progress bars indicatin

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/widgets/project_explorer.rs
Language: rust
Comments found: 51

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via CollapsingHeader::new(format!("📁 (lines 148)., this scope performs file I/O via std::fs::read_dir(&dir_path) (lines 285).
imports: Imports: use std::sync::Arc;., Imports: use egui::{Context, Ui, ScrollArea, CollapsingHeader, Color32};., Imports: use crate::{, Imports: use std::collections::HashMap;., Imports: use std::path::PathBuf;., Imports: use tokio::sync::RwLock;., use crate::{
structure: calls GuiError::Io., calls Box::pin., calls Color32::from_rgb., calls ScrollArea::vertical., calls CollapsingHeader::new., calls egui::Layout::right_to_left., calls HashMap::new., calls PyQtSignal::new.

COMMENTS TO ANALYZE:
Line 1: ! Project Explorer Widget - Exact Python Implementation Equivalent
Line 3: ! File tree navigation with health indicators and context menu.
Line 4: ! This is a zero-degradation implementation of the Python ProjectExplorer.
Line 18: Project file explorer with health indicators - exact Python ProjectExplorer equivalent
Line 23: UI state matching Python implementation
Line 30: Health indicators (matching Python health indicators)
Line 38: File tree node structure matching Python QStandardItem model
Line 51: Create new project explorer - exact Python constructor equivalent
Line 67: Initialize user interface - exact Python init_ui equivalent
Line 70: Header (matching Python QLabel header)
Line 82: Search box (exact Python QLineEdit equivalent)
Line 93: File tree (exact Python QTreeView equivalent)
Line 100: Status information (matching Python status display)
Line 123: Render file tree - exact Python QTreeView rendering equivalent
Line 140: Render individual file node - exact Python QStandardItem equivalent
Line 146: Directory node with collapsible header (matching Python tree expansion)
Line 160: Update expansion state
Line 166: File node (matching Python file item)
Line 168: File icon based on type
Line 172: File name with selection
Line 179: Health indicator (matching Python health indicators)
Line 185: File size (if available)
Line 193: Context menu for selected files (matching Python context menu)
Line 198: Open file for viewing
Line 201: Open file for editing
Line 204: Analyze individual file
Line 214: Get file icon based on extension - exact Python icon logic
Line 235: Convert health score to color - exact Python health indicator colors
Line 248: Format file size - exact Python file size formatting
Line 262: Load project - exact Python load_project equivalent
Line 270: Build file tree model - exact Python QStandardItemModel building
Line 280: Scan directory recursively - exact Python directory scanning
Line 292: Skip hidden files unless explicitly shown
Line 302: Recursive directory scan (with depth limit)
Line 323: Sort children: directories first, then files (matching Python sorting)
Line 343: Root is always expanded
Line 347: Load health indicators - exact Python health indicator loading
Line 349: TODO: Load health scores from analysis results
Line 350: This would integrate with the analysis controller to get health data
Line 354: Filter file tree based on search - exact Python search filtering
Line 357: Show all files
Line 361: TODO: Implement search filtering logic matching Python
Line 364: Count files in tree
Line 381: Count folders in tree
Line 401: Signals are created in constructor
Line 406: Signal connections would be set up by parent components

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6186 characters
🤖 Analyzing: [███████████████████████████████████████░░░░░░░░░░░]  79% (19/24) - health_dashboard.rs...🔍 DEBUG PROMPT for health_dashboard.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti
- analysis_controller.rs: This file, `analysis_controller.rs`, serves as a controller for the analysis operations in an application that employs QThread for background processing and PyQt5-style signals for inter-thread commun
- menu_bar.rs: This file, `menu_bar.rs` in the Rust codebase is a component responsible for creating and managing the application's menu bar interface. The menu bar provides access to various functionalities of the 
- project_explorer.rs: This file, project_explorer.rs in the Rust codebase, is designed for managing and displaying files information about an application's GUI. It uses egui's ScrollArea, CollapsingHeader functionalities t
- llm_debugger.rs: This file, llm_debugger.rs, is a Rust component designed for the implementation of an LLM (Language Model) powered debugging and auto-fixing feature in an application's GUI. The component uses egui's 
- health_monitor.rs: This file, `health_monitor.rs` in the Rust codebase is a component responsible for monitoring and reporting application health status. It implements features such as displaying progress bars indicatin

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/widgets/health_dashboard.rs
Language: rust
Comments found: 17

STRUCTURAL CONTEXT:
structure: render is a wrapper for Ok (lines 82)., calls Color32::from_rgb., calls egui::RichText::new., calls HealthStatus::default.
imports: use crate::{GuiResult, GuiMessage, GuiComponent, state::AppState};., Imports: use tokio::sync::RwLock;., Imports: use egui::{Context, Ui, Color32, Vec2};., Imports: use serde::{Deserialize, Serialize};., Imports: use crate::{GuiResult, GuiMessage, GuiComponent, state::AppState};., Imports: use std::sync::Arc;.

COMMENTS TO ANALYZE:
Line 1: ! Health Dashboard Widget
Line 3: ! Displays overall codebase health status and metrics summary.
Line 11: Health dashboard data
Line 37: Health dashboard widget displaying overall codebase health
Line 46: Create new health dashboard
Line 56: Update health status
Line 61: Render health score with color coding
Line 94: Overall score prominently displayed
Line 142: Health trend indicator
Line 155: Trigger health refresh
Line 158: Show detailed health report
Line 161: Navigate to issues view
Line 172: Update health metrics from analysis

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3830 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  83% (20/24) - signals_pyqt5.rs...🔍 DEBUG PROMPT for signals_pyqt5.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- performance_view_gui.rs: This Rust file, performance_view_gui.rs, implements a graphical user interface for displaying and analyzing the performance metrics of an application. It provides users with an interactive dashboard t
- files_view_gui.rs: The file "./codehud-gui/src/views/files_view_gui.rs" in the Rust codebase serves as a graphical user interface for managing and displaying files information about an application. It provides users wit
- state.rs: The state.rs file in the Rust codebase acts as a central hub for managing various aspects of the application, such as user preferences, resource usage statistics, and performance metrics. It also hand
- utils.rs: The file `utils.rs` in the Rust codebase serves as a utility module containing common functionalities for GUI views and components used across different modules such as health_view_gui, topology_view_
- lib.rs: The file "./codehud-gui/src/lib.rs" in the Rust codebase serves as the central hub for all other GUI components and views of an application's architecture. It acts as a unified interface for interacti
- analysis_controller.rs: This file, `analysis_controller.rs`, serves as a controller for the analysis operations in an application that employs QThread for background processing and PyQt5-style signals for inter-thread commun
- menu_bar.rs: This file, `menu_bar.rs` in the Rust codebase is a component responsible for creating and managing the application's menu bar interface. The menu bar provides access to various functionalities of the 
- project_explorer.rs: This file, project_explorer.rs in the Rust codebase, is designed for managing and displaying files information about an application's GUI. It uses egui's ScrollArea, CollapsingHeader functionalities t
- llm_debugger.rs: This file, llm_debugger.rs, is a Rust component designed for the implementation of an LLM (Language Model) powered debugging and auto-fixing feature in an application's GUI. The component uses egui's 
- health_monitor.rs: This file, `health_monitor.rs` in the Rust codebase is a component responsible for monitoring and reporting application health status. It implements features such as displaying progress bars indicatin

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-gui/src/signals_pyqt5.rs
Language: rust
Comments found: 29

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via thread.wait().unwrap() (lines 303)., this scope performs file I/O via std::thread::sleep(std::time::Duration::from_millis(10)) (lines 299)., this scope performs file I/O via GuiError::State(format!("Thread (lines 224)., this scope performs file I/O via handle.join() (lines 223)., this scope performs file I/O via thread.wait() (lines 303)., this scope performs file I/O via PyQtThread::new("test") (lines 283)., this scope performs file I/O via thread.start(|| (lines 298)., this scope performs file I/O via std::thread::spawn(move (lines 181)., this scope performs file I/O via thread.finished.connect(move (lines 294)., this scope performs file I/O via thread.started.connect(move (lines 290).
structure: calls HashMap::new., calls PyQtSignal::new., calls GuiError::State., calls PyQtSignal::<i32>::new., connect_objects is a wrapper for Err.GuiError.State.format.sender_signal_name (lines 130)., calls Arc::clone., calls Arc::new., calls self.get_signal::<T>., calls PyQtThread::new., calls Box::new., calls Mutex::new., calls Self::new., calls signal.downcast_ref::<PyQtSignal<T>>.
imports: Imports: use std::marker::PhantomData;., Imports: use std::any::{Any, TypeId};., use super::*;., use crate::{GuiResult, GuiError};., Imports: use crate::{GuiResult, GuiError};., Imports: use crossbeam_channel::{bounded, Receiver, Sender};., Imports: use std::sync::{Arc, Mutex, Weak};., Imports: use std::collections::HashMap;., Imports: use super::*;.

COMMENTS TO ANALYZE:
Line 1: ! PyQt5-Style Signal/Slot System - Zero Degradation Implementation
Line 3: ! This module provides an exact PyQt5 signal/slot architecture implementation
Line 4: ! to ensure zero-degradation from the Python GUI system.
Line 13: PyQt5-style Signal that can emit typed messages to connected slots
Line 29: Connect a slot function to this signal (PyQt5 style)
Line 40: Emit signal with value (PyQt5 style)
Line 49: Also send to emit queue if connected
Line 58: Disconnect all slots
Line 66: Set up emit queue for async processing
Line 73: Clone signal for thread sharing
Line 89: PyQt5-style QObject equivalent with signal/slot management
Line 96: Signal manager matching PyQt5 QObject behavior
Line 110: Register a signal by name (PyQt5 style)
Line 115: Get signal by name and type
Line 121: Connect two objects' signals and slots (PyQt5 style)
Line 135: Cleanup disconnected signals
Line 147: PyQt5 QThread equivalent for background processing
Line 171: Start the thread (PyQt5 QThread.start() equivalent)
Line 182: Emit started signal
Line 192: Emit appropriate completion signal
Line 215: Stop the thread (PyQt5 QThread.quit() equivalent)
Line 220: Wait for thread to finish (PyQt5 QThread.wait() equivalent)
Line 233: Terminate the thread forcefully (PyQt5 QThread.terminate() equivalent)
Line 237: Note: Rust doesn't have forced thread termination for safety reasons
Line 238: This is a graceful shutdown attempt
Line 244: Macro to create PyQt5-style signal connections
Line 252: Macro to emit PyQt5-style signals

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5833 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (24/24) - Complete!
✅ Phase 2 complete: 24 files analyzed with enhanced context
📄 File summaries updated: 83 total files (24 from codehud-gui)
📄 Analysis metadata updated: 4 crates processed
🔍 DEBUG: Crate path for codehud-llm: ./codehud-llm
🔍 Processing 34 files from crate codehud-llm
🔍 DEBUG: First 5 files discovered for crate codehud-llm:
  1. ./codehud-llm/src/ollama.rs
  2. ./codehud-llm/src/narrator/aggregate.rs
  3. ./codehud-llm/src/narrator/mod.rs
  4. ./codehud-llm/src/narrator/cst.rs
  5. ./codehud-llm/src/narrator/config.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/ollama.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/ollama.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/aggregate.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/aggregate.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/cst.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/cst.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/config.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/config.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/findings.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/findings.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/entrypoint.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/entrypoint.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/wrapper.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/wrapper.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/imports_exports.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/imports_exports.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/comments.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/comments.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/io.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/io.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/module_relationships.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/module_relationships.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/detectors/utility_class.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/detectors/utility_class.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/narrator/render.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/narrator/render.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/constitutional.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/constitutional.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/progress_monitor.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/progress_monitor.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/ffi.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/ffi.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/structured.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/structured.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/denoiser.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/denoiser.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/file_processor.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/file_processor.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/crate_summarizer.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/crate_summarizer.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/comment_extractor.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/comment_extractor.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/conversation.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/conversation.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/extraction_fsm.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/extraction_fsm.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/critical.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/critical.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/equivalence.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/equivalence.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/native_stub.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/native_stub.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/validation.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/validation.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/native.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/native.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/src/monitoring.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/src/monitoring.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/tests/phase_5b_validation.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/tests/phase_5b_validation.rs
🔍 DEBUG: Generating structural insights for ./codehud-llm/tests/equivalence_tests.rs
✅ DEBUG: Narrator method succeeded for ./codehud-llm/tests/equivalence_tests.rs
💾 Comments JSON updated: 113 total files (30 from codehud-llm)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-llm...
🤖 Analyzing 30 files with enhanced context and improved token limits...
📦 Processing batch 1/6 (5 files)...
🤖 Analyzing: [█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   3% (1/30) - ollama.rs...🔍 DEBUG PROMPT for ollama.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-llm/src/ollama.rs
Language: rust
Comments found: 91

STRUCTURAL CONTEXT:
structure: list_models is a wrapper for Err.LlmError.Http.reqwest.Error.from.response.error_for_status.unwrap_err (lines 324)., calls Client::builder., calls OllamaPipeline::new., calls reqwest::Error::from., calls ModelConfig::default., calls SessionConfig::default., generate_native is a wrapper for Err.LlmError.Inference.format.response.status (lines 477)., calls ContextWindow::default., pull_model is a wrapper for Err.LlmError.Inference.format.model_name.response.status (lines 355)., calls NativeLlmEngine::new., calls Duration::from_secs., calls ModelParameters::default., calls LlmError::Http., calls HashMap::new., calls GpuConfig::default., calls Command::new., calls LlmError::Inference., calls PyDict::new., calls Self::new., generate is a wrapper for generate_via_python_bridge.prompt.system_prompt.python_bridge (lines 411)., generate_structured_code is a wrapper for Ok.python_bridge.generate_structured_code.prompt.ffi_constraints (lines 539)., calls OllamaConfig::default.
imports: Imports: use super::*;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::time::Duration;., Imports: use tokio::process::Command;., Imports: use std::collections::HashMap;., use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError, ffi::PythonLlmBridge, native::NativeLlmEngine};., Imports: use reqwest::Client;., Imports: use pyo3::types::PyDict;., Imports: use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError, ffi::PythonLlmBridge, native::NativeLlmEngine};., use super::*;., Imports: use pyo3::prelude::*;., use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError, ffi::PythonLlmBridge, native_stub::NativeLlmEngine};., Imports: use tokio;., Imports: use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError, ffi::PythonLlmBridge, native_stub::NativeLlmEngine};.

COMMENTS TO ANALYZE:
Line 1: ! Ollama Pipeline Integration - GPU accelerated local LLM inference
Line 3: ! This module provides integration with Ollama for local LLM inference with 4+ model types
Line 4: ! and GPU acceleration support, matching Python implementation exactly.
Line 17: Ollama configuration matching Python implementation
Line 20: Ollama server URL
Line 47: Model type to use
Line 53: Whether to keep model loaded
Line 68: Model parameters for inference
Line 73: Top-p nucleus sampling
Line 98: GPU acceleration configuration
Line 101: GPU type to use
Line 103: Number of GPU layers to use
Line 105: GPU memory fraction to use
Line 107: Whether to enable memory mapping
Line 109: Whether to enable memory locking
Line 125: Session management configuration
Line 128: Maximum conversation length
Line 132: Whether to persist conversations
Line 134: Context window management
Line 149: Context window management strategy
Line 152: Strategy for handling context overflow
Line 154: Target context utilization (0.0-1.0)
Line 156: Whether to summarize old context
Line 170: Strategy for handling context window overflow
Line 173: Truncate oldest messages
Line 175: Use sliding window approach
Line 177: Summarize and compress
Line 179: Fail on overflow
Line 183: Ollama API request structure
Line 197: Ollama API response structure
Line 216: Ollama model information
Line 226: Detailed model information
Line 236: Ollama pipeline for local LLM inference with GPU acceleration
Line 238: This implementation provides a Rust interface while delegating to the Python
Line 239: implementation during Phase 5a to ensure zero-degradation compatibility.
Line 243: HTTP client for API communication
Line 245: Native LLM engine (Phase 5b primary implementation)
Line 247: Python FFI bridge (Phase 5a fallback)
Line 249: Current conversation context
Line 251: Session ID for tracking
Line 256: Create a new Ollama pipeline
Line 273: Create with native engine for Phase 5b (primary implementation)
Line 277: Initialize native engine with LLM config
Line 297: Create with Python FFI bridge for Phase 5a compatibility
Line 307: Check if Ollama is available and running
Line 315: List available models
Line 336: Pull a model from the Ollama registry
Line 365: Generate text using Ollama with GPU acceleration
Line 371: Phase 5b: Use native engine as primary implementation
Line 379: Generate structured code using constraints for better quality
Line 409: Phase 5a: Fallback to Python bridge if available for guaranteed compatibility
Line 414: Final fallback: Native Ollama HTTP API implementation
Line 418: Generate via Python bridge (Phase 5a)
Line 425: Call Python Ollama pipeline directly
Line 454: Native Rust generation (will be used in Phase 5b)
Line 485: Update conversation context for session continuity
Line 493: Generate structured code with constraints
Line 499: Phase 5b: Use native engine as primary implementation
Line 519: Phase 5a: Fallback to Python bridge for guaranteed compatibility
Line 542: Final fallback: Native structured generation - convert constraints
Line 561: Native structured generation implementation
Line 567: Enhanced prompt with constraints
Line 590: No special formatting required
Line 601: Add validation rules as instructions
Line 612: Start a new conversation session
Line 618: End the current session
Line 624: Get current session ID
Line 629: Check if model is loaded
Line 637: Ensure model is available (pull if necessary)
Line 646: Get GPU information
Line 648: Check GPU availability through system commands
Line 651: Check NVIDIA GPU
Line 664: Check AMD GPU (ROCm)
Line 677: Check Metal (macOS)
Line 709: Requires Ollama server running
Line 714: This test requires Ollama to be running

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6024 characters
🤖 Analyzing: [███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   6% (2/30) - aggregate.rs...🔍 DEBUG PROMPT for aggregate.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/aggregate.rs
Language: rust
Comments found: 6

STRUCTURAL CONTEXT:
imports: use crate::narrator::{Finding, FindingType, NarratorConfig};., Imports: use crate::narrator::{Finding, FindingType, NarratorConfig};., Imports: use itertools::Itertools;., Imports: use std::collections::BTreeMap;.
structure: calls BTreeMap::new.

COMMENTS TO ANALYZE:
Line 25: Role line: first NoteComment becomes "Role" sentence (trimmed)
Line 44: Group same (type, owner, subject) and merge lines
Line 125: handled as role
Line 136: Install sections in configured order
Line 140: rendered in render.rs header

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1014 characters
🤖 Analyzing: [█████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  10% (3/30) - cst.rs...🔍 DEBUG PROMPT for cst.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/cst.rs
Language: rust
Comments found: 6

STRUCTURAL CONTEXT:
imports: Imports: use serde::{Deserialize, Serialize};., Imports: use std::path::PathBuf;.

COMMENTS TO ANALYZE:
Line 4: Minimal JSON shape compatible with `tree-sitter parse --json`.
Line 5: We only rely on `type`, `children`, `text`, and `startPoint`.
Line 26: original source path if embedded; else the CST file path
Line 28: optional (not always present in CST JSON)
Line 31: Helper functions for Node
Line 48: Get all text content from this node and its children

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 956 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  13% (4/30) - findings.rs...🔍 DEBUG PROMPT for findings.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/findings.rs
Language: rust
Comments found: 4

STRUCTURAL CONTEXT:
imports: Imports: use serde::{Deserialize, Serialize};.

COMMENTS TO ANALYZE:
Line 18: use crate::, use super::, use self::
Line 19: Calls to functions from other modules
Line 20: pub use statements
Line 32: e.g., TODO text

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 717 characters
🤖 Analyzing: [████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  16% (5/30) - entrypoint.rs...🔍 DEBUG PROMPT for entrypoint.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/detectors/entrypoint.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
structure: calls Finding::new., extract_function_name is a wrapper for ch.text.clone (lines 41).
imports: Imports: use crate::narrator::{FileCst, Finding, FindingType, Node};., use crate::narrator::{FileCst, Finding, FindingType, Node};., use crate::narrator::detectors::Detector;., Imports: use crate::narrator::detectors::Detector;.

COMMENTS TO ANALYZE:
Line 9: Look for Python __name__ == "__main__" pattern and Rust main function
Line 14: Python entrypoint pattern
Line 23: Rust main function

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1003 characters
📦 Processing batch 2/6 (5 files)...
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (6/30) - wrapper.rs...🔍 DEBUG PROMPT for wrapper.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/detectors/wrapper.rs
Language: rust
Comments found: 7

STRUCTURAL CONTEXT:
structure: calls Finding::new., extract_function_name is a wrapper for ch.text.clone (lines 35)., find_return_call is a wrapper for Some.n.g.name (lines 53).
imports: use crate::narrator::detectors::Detector;., Imports: use crate::narrator::detectors::Detector;., use crate::narrator::{FileCst, Finding, FindingType, Node};., Imports: use crate::narrator::{FileCst, Finding, FindingType, Node};.

COMMENTS TO ANALYZE:
Line 4: Detect functions that return a single call: return foo(...)
Line 16: Look for a child block containing a single return_statement -> call_expression
Line 32: naive: find first child 'identifier'
Line 44: descend to find return -> call
Line 51: find callee identifier
Line 68: try to find 'identifier' or 'property_identifier'

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2438 characters
🤖 Analyzing: [███████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  23% (7/30) - imports_exports.rs...🔍 DEBUG PROMPT for imports_exports.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/detectors/imports_exports.rs
Language: rust
Comments found: 5

STRUCTURAL CONTEXT:
structure: calls Finding::new.
imports: Imports: use crate::narrator::{FileCst, Finding, FindingType};., Imports: use crate::narrator::detectors::Detector;., use crate::narrator::{FileCst, Finding, FindingType};., use crate::narrator::detectors::Detector;.

COMMENTS TO ANALYZE:
Line 51: Create separate findings for each export to preserve granularity
Line 59: Create separate findings for each import to preserve granularity and show relationships

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2145 characters
🤖 Analyzing: [█████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  26% (8/30) - comments.rs...🔍 DEBUG PROMPT for comments.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/detectors/comments.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
structure: calls Finding::new., calls Regex::new.
imports: Imports: use regex::Regex;., use crate::narrator::{FileCst, Finding, FindingType, NarratorConfig};., Imports: use crate::narrator::detectors::Detector;., use crate::narrator::detectors::Detector;., Imports: use crate::narrator::{FileCst, Finding, FindingType, NarratorConfig};.

COMMENTS TO ANALYZE:
Line 25: Walk and find "comment" nodes (tree-sitter common name)
Line 30: First comment for "Role"
Line 39: First non-empty trimmed comment line becomes "Note" we map later to "Role" section in render.

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2249 characters
🤖 Analyzing: [███████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  30% (9/30) - io.rs...🔍 DEBUG PROMPT for io.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/detectors/io.rs
Language: rust
Comments found: 1

STRUCTURAL CONTEXT:
imports: Imports: use crate::narrator::{FileCst, Finding, FindingType, Node, NarratorConfig};., Imports: use aho_corasick::AhoCorasick;., use crate::narrator::detectors::Detector;., use crate::narrator::{FileCst, Finding, FindingType, Node, NarratorConfig};., Imports: use crate::narrator::detectors::Detector;.
structure: calls AhoCorasick::new., calls Finding::new.

COMMENTS TO ANALYZE:
Line 51: pick first meaningful token from the bag

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2122 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (10/30) - module_relationships.rs...🔍 DEBUG PROMPT for module_relationships.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/detectors/module_relationships.rs
Language: rust
Comments found: 14

STRUCTURAL CONTEXT:
structure: calls Finding::new.
imports: Imports: use crate::narrator::{FileCst, Finding, FindingType};., use crate::narrator::{FileCst, Finding, FindingType};., use crate::narrator::detectors::Detector;., Imports: use crate::narrator::detectors::Detector;.

COMMENTS TO ANALYZE:
Line 17: Rust use declarations
Line 22: Detect intra-crate imports
Line 27: Detect re-exports (pub use)
Line 38: Look for calls that reference modules (contains ::)
Line 40: Extract just the function call, limit length to avoid huge expressions
Line 42: Try to extract the module::function part
Line 57: Add intra-crate imports
Line 71: Add function calls (deduplicate)
Line 85: Extract the module::function part from a call expression
Line 87: Look for patterns like: module::function(), crate::module::Type::new(), self::helper()
Line 95: Only include calls that reference modules (contain ::) and look like project code
Line 97: Filter out standard library and common external crates to reduce noise

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2683 characters
📦 Processing batch 3/6 (5 files)...
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  36% (11/30) - utility_class.rs...🔍 DEBUG PROMPT for utility_class.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c
- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/detectors/utility_class.rs
Language: rust
Comments found: 1

STRUCTURAL CONTEXT:
imports: Imports: use crate::narrator::{FileCst, Finding, FindingType, Node};., use crate::narrator::{FileCst, Finding, FindingType, Node};., use crate::narrator::detectors::Detector;., Imports: use crate::narrator::detectors::Detector;.
structure: calls Finding::new., extract_class_name is a wrapper for ch.text.clone (lines 53).

COMMENTS TO ANALYZE:
Line 28: crude: look for 'static' token or @staticmethod nearby

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3203 characters
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (12/30) - render.rs...🔍 DEBUG PROMPT for render.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c
- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/narrator/render.rs
Language: rust
Comments found: 2

STRUCTURAL CONTEXT:
imports: Imports: use crate::narrator::{FileDoc, NarratorConfig};., use crate::narrator::{FileDoc, NarratorConfig};.

COMMENTS TO ANALYZE:
Line 6: Don't include the file path header, we'll integrate this differently
Line 26: Render bullet points in a compact format for LLM consumption

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3054 characters
🤖 Analyzing: [█████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  43% (13/30) - constitutional.rs...🔍 DEBUG PROMPT for constitutional.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c
- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/constitutional.rs
Language: rust
Comments found: 3

STRUCTURAL CONTEXT:
imports: use crate::ffi::PythonLlmBridge;., use crate::{LlmError, LlmResult};., Imports: use crate::{LlmError, LlmResult};., Imports: use serde::{Deserialize, Serialize};., Imports: use chrono::{DateTime, Utc};., Imports: use std::collections::HashMap;., Imports: use crate::ffi::PythonLlmBridge;.
structure: calls regex::Regex::new., calls LlmError::ConfigurationError., calls Utc::now., calls HashMap::new.

NO MEANINGFUL COMMENTS FOUND - ANALYZING FILE STRUCTURE ONLY:

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3239 characters
🤖 Analyzing: [███████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░]  46% (14/30) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c
- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/lib.rs
Language: rust
Comments found: 59

STRUCTURAL CONTEXT:
imports: Imports: pub use denoiser::{LlmContextDenoiser, DenoiserConfig, DenoiserStats};., Imports: pub use monitoring::{LlmMonitor, PerformanceMetrics};., Imports: pub use ffi::PythonLlmBridge;., Imports: pub use native_stub::{NativeLlmEngine, ModelInfo};., Imports: pub use equivalence::{EquivalenceTester, EquivalenceTestSuite};., Imports: pub use extraction_fsm::{CommentExtractionFSM, CommentExtractionCLI, ExtractionState, ScanResult, GUIIntegration};., Imports: pub use structured::{StructuredCodeGenerator, GenerationConstraints};., Imports: pub use ollama::{OllamaPipeline, OllamaConfig};., Imports: pub use conversation::{ConversationTracker, ConversationMessage};., Imports: pub use native::{NativeLlmEngine, ModelManager, InferenceEngine};., Imports: pub use file_processor::{FileProcessor, ProcessorConfig, FileSummary, SystemSummary, ProcessingReport};., Imports: pub use crate_summarizer::{CrateSummarizer, CrateSummary, CrateGrouper, CrateInfo, CrateSummarizerConfig, CleanedFileData};., Imports: pub use critical::{CriticalMistakeDetector, MistakeType, CriticalMistake, CodeLocation};., Imports: pub use validation::{ValidationEngine, ValidationResult};., Imports: pub use constitutional::{ConstitutionalAI, ConstitutionalPrinciple};., Imports: pub use comment_extractor::{CommentExtractor, ExtractedComment, FileCommentExtraction, ExtractionConfig};.
structure: calls LlmError::PythonDowncast.
exports: pub use validation::{ValidationEngine, ValidationResult};., pub use file_processor::{FileProcessor, ProcessorConfig, FileSummary, SystemSummary, ProcessingReport};., pub use comment_extractor::{CommentExtractor, ExtractedComment, FileCommentExtraction, ExtractionConfig};., pub use native::{NativeLlmEngine, ModelManager, InferenceEngine};., pub use native_stub::{NativeLlmEngine, ModelInfo};., pub use ffi::PythonLlmBridge;., pub use crate_summarizer::{CrateSummarizer, CrateSummary, CrateGrouper, CrateInfo, CrateSummarizerConfig, CleanedFileData};., pub use equivalence::{EquivalenceTester, EquivalenceTestSuite};., pub use denoiser::{LlmContextDenoiser, DenoiserConfig, DenoiserStats};., pub use monitoring::{LlmMonitor, PerformanceMetrics};., pub use conversation::{ConversationTracker, ConversationMessage};., pub use constitutional::{ConstitutionalAI, ConstitutionalPrinciple};., pub use extraction_fsm::{CommentExtractionFSM, CommentExtractionCLI, ExtractionState, ScanResult, GUIIntegration};., pub use critical::{CriticalMistakeDetector, MistakeType, CriticalMistake, CodeLocation};., pub use ollama::{OllamaPipeline, OllamaConfig};., pub use structured::{StructuredCodeGenerator, GenerationConstraints};.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD LLM - Large Language Model Integration (Phase 5a: FFI Preservation Bridge)
Line 3: ! This crate provides complete LLM integration preserving Python functionality exactly.
Line 4: ! Phase 5a implements PyO3 bindings to call Python implementations directly for
Line 5: ! guaranteed zero-degradation compatibility.
Line 7: ! Key Components (29+ files from Python implementation):
Line 8: ! - Ollama Pipeline with GPU acceleration
Line 9: ! - Structured code generation with constraints
Line 10: ! - Critical mistake detection and self-correction
Line 11: ! - Constitutional AI with guardrails
Line 12: ! - Conversation tracking and memory
Line 13: ! - 97%+ bug fix success rate preservation
Line 18: LLM capability modules
Line 20: Use full native implementation when candle feature is enabled
Line 24: Use stub implementation when candle feature is disabled (for GUI integration)
Line 43: Re-export main types for convenience
Line 45: Re-export under consistent name
Line 65: Result type for LLM operations
Line 68: Error types for LLM operations
Line 71: Python FFI error
Line 75: Python downcast error
Line 79: HTTP request error
Line 83: JSON parsing error
Line 87: Schema validation error
Line 99: Configuration error (alias)
Line 103: Model inference error
Line 107: Critical mistake detected
Line 111: Constitutional AI violation
Line 115: GPU acceleration error
Line 123: Conversation tracking error
Line 135: Regex compilation error
Line 139: Python bridge errors
Line 168: LLM model types supported (matching Python implementation exactly)
Line 171: DeepSeek Coder models
Line 173: Qwen2.5 Coder models
Line 175: Code Llama models
Line 182: Get the model identifier used by Ollama
Line 192: Get the HuggingFace model identifier
Line 203: GPU acceleration type (matching Python implementation)
Line 208: Metal acceleration (macOS)
Line 214: LLM configuration matching Python behavior exactly
Line 217: Model type to use
Line 219: GPU acceleration type
Line 221: Maximum tokens to generate
Line 223: Temperature for sampling
Line 225: Top-p sampling parameter
Line 227: Random seed for reproducibility
Line 229: Whether to enable structured generation
Line 231: Whether to enable critical mistake detection
Line 233: Whether to enable constitutional AI
Line 235: Session timeout in seconds

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 7729 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (15/30) - progress_monitor.rs...🔍 DEBUG PROMPT for progress_monitor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ollama.rs: This Rust file provides an interface for local Language Model (LLM) inference with GPU acceleration, using Ollama's infrastructure and capabilities. It allows users to configure various aspects of the
- aggregate.rs: This Rust file, `./codehud-llm/src/narrator/aggregate.rs`, is a part of the system's narration module for code analysis and reporting. It handles various aspects such as role assignment, grouping of f
- cst.rs: This file, written in Rust, is a representation of the Concrete Syntax Tree (CST) for parsing code into an abstract syntax tree. The CST represents the parse tree of the source code and provides a hig
- findings.rs: This Rust file, `findings.rs`, provides a data structure for storing and serializing vulnerability findings generated by various security checks in the codehud-llm system. It uses the Serde library fo
- entrypoint.rs: This Rust file, `entrypoint.rs`, serves as the entry point of a system designed for static code analysis. The purpose is to identify and provide detailed information about potential issues in source c
- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/progress_monitor.rs
Language: rust
Comments found: 39

STRUCTURAL CONTEXT:
imports: Imports: use std::os::unix::fs::PermissionsExt;., Imports: use std::process::{Command, Stdio};., Imports: use std::path::PathBuf;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::fs;., Imports: use anyhow::Result;., Imports: use std::io::IsTerminal;.
file_i/o: this scope performs file I/O via self.read_progress() (lines 114, 131, 148, 164)., this scope performs file I/O via self.write_progress(&progress) (lines 103, 126, 143, 153, 169)., this scope performs file I/O via std::thread::sleep(std::time::Duration::from_secs(5)) (lines 172)., this scope performs file I/O via fs::read_to_string(&self.progress_file) (lines 191)., this scope performs file I/O via fs::write(&self.progress_file, (lines 181)., this scope performs file I/O via std::thread::sleep(std::time::Duration::from_secs(2)) (lines 156)., this scope performs file I/O via fs::write(&script_file, (lines 281).
structure: calls fs::write., calls serde_json::to_string_pretty., calls Default::default., calls Self::should_use_popup., read_progress is a wrapper for Ok.ProgressInfo.default (lines 188)., calls fs::read_to_string., calls fs::metadata., calls Self::new., calls fs::set_permissions., calls Command::new., calls Stdio::null., spawn_popup_window is a wrapper for Ok (lines 313)., calls serde_json::from_str., calls fs::remove_file., calls ProgressInfo::default.

COMMENTS TO ANALYZE:
Line 1: ! Progress Monitor for Background Execution
Line 3: ! Displays a popup terminal window with progress bar when the main process
Line 4: ! runs in the background, ensuring visibility of long-running operations.
Line 12: Progress information shared between main process and popup window
Line 15: Current step being processed
Line 17: Total number of steps
Line 19: Current file being processed
Line 21: Total files to process
Line 23: Current operation description
Line 25: Whether the operation is complete
Line 27: Elapsed time in seconds
Line 29: Any error message
Line 48: Progress monitor that can spawn popup windows for background processes
Line 50: Path to the progress file
Line 52: Whether to use popup mode
Line 54: Start time for elapsed calculation
Line 59: Create a new progress monitor
Line 71: Detect if we should use popup mode (running in background)
Line 73: Check if we're running in background by testing if stdout is a terminal
Line 76: If stdout is not a terminal, we're likely running in background
Line 81: Also check for explicit background indicators
Line 86: Check if DISPLAY is set (we're in GUI environment) and no terminal
Line 94: Initialize progress monitoring (spawn popup if needed)
Line 102: Write initial progress
Line 129: Update progress with file count
Line 146: Mark as completed
Line 155: Clean up after a short delay
Line 162: Mark as failed
Line 171: Clean up after a longer delay for errors
Line 178: Write progress to shared file
Line 185: Read progress from shared file
Line 196: Spawn a popup terminal window to display progress
Line 202: Create a script that monitors the progress file
Line 279: Write script to temp file
Line 283: Make script executable
Line 292: Prepare command arguments with proper lifetimes
Line 296: Try different terminal emulators
Line 317: Fallback: just print a message

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 6011 characters
📦 Processing batch 4/6 (5 files)...
🤖 Analyzing: [██████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░]  53% (16/30) - ffi.rs...🔍 DEBUG PROMPT for ffi.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate
- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/ffi.rs
Language: rust
Comments found: 120

STRUCTURAL CONTEXT:
imports: Imports: use std::collections::HashMap;., Imports: use pyo3::types::{PyDict, PyList};., use super::*;., Imports: use crate::{LlmConfig, ModelType, LlmResult, LlmError, MistakeType, CriticalMistake, CodeLocation};., Imports: use serde_json::Value;., Imports: use super::*;., Imports: use std::path::Path;., Imports: use pyo3::prelude::*;., Imports: use std::path::PathBuf;., Imports: use std::time::{Duration, Instant};., use crate::{LlmConfig, ModelType, LlmResult, LlmError, MistakeType, CriticalMistake, CodeLocation};.
structure: calls pyo3::prepare_freethreaded_python., calls PyErr::from., calls Python::with_gil., calls tokio::task::spawn_blocking., calls PathBuf::from., calls LlmCapability::all., calls PythonLlmBridge::new., calls PyList::new., calls chrono::Utc::now., calls PyList::empty., calls PyDict::new., calls serde_json::from_str., calls pyo3::exceptions::PyKeyError::new_err., calls Duration::from_secs., calls serde_json::to_string., call_python is a wrapper for Err.LlmError.seconds.timeout_seconds (lines 792)., calls Python::assume_gil_acquired., calls Instant::now., calls PythonCallWrapper::new.
file_i/o: this scope performs file I/O via pyo3::prepare_freethreaded_python() (lines 179)., this scope performs file I/O via Python::with_gil(|python| (lines 180)., this scope performs file I/O via python (lines 243)., this scope performs file I/O via Python::with_gil(|py| (lines 716)., this scope performs file I/O via openhands_bridge.into() (lines 271)., this scope performs file I/O via Ok(Self (lines 258).

COMMENTS TO ANALYZE:
Line 1: ! FFI Bridge - PyO3 bindings to preserve exact Python LLM behavior
Line 3: ! This module implements Phase 5a of the plan: calling Python LLM implementations
Line 4: ! directly through FFI to guarantee zero-degradation compatibility while building
Line 5: ! the Rust infrastructure.
Line 14: Main FFI bridge to Python LLM implementations
Line 16: This bridge calls the Python codehud.local_llm modules directly to ensure
Line 17: identical behavior during the transition period.
Line 19: Python interpreter instance
Line 21: Python Ollama pipeline module
Line 23: Python PyTorch pipeline module
Line 25: Python structured generator module
Line 27: Python critical detector module
Line 29: Python constitutional AI module
Line 31: Python conversation tracker module
Line 33: Python self-verification system module
Line 35: Python continuous test monitor module
Line 37: Python behavior analysis module
Line 39: Python optimized pipeline module
Line 41: Python guardrails integration module
Line 43: Python OpenHands bridge module
Line 45: Python monitoring system module
Line 47: Python validation system module
Line 51: LLM capability enumeration matching Python implementation
Line 54: Ollama pipeline with GPU acceleration
Line 56: PyTorch pipeline with HuggingFace integration
Line 58: Structured code generation with constraints
Line 60: Critical mistake detection and self-correction
Line 62: Constitutional AI with guardrails
Line 64: Conversation tracking and memory
Line 68: Continuous testing and monitoring
Line 70: LLM behavior analysis
Line 74: Advanced constraint enforcement
Line 76: External AI system bridging
Line 81: Get all available capabilities
Line 100: Generation constraints for structured output
Line 103: JSON schema for structured output
Line 105: Grammar rules for constrained generation
Line 107: Maximum length constraints
Line 109: Required output format
Line 115: Output format specification
Line 118: Plain text output
Line 120: JSON structured output
Line 122: Python code output
Line 124: Rust code output
Line 131: Constitutional AI rule
Line 138: Rule pattern to match
Line 140: Action to take when rule is violated
Line 146: Action to take when a constitutional rule is violated
Line 149: Block the output completely
Line 151: Warn and continue
Line 153: Attempt to fix the violation
Line 155: Request human review
Line 159: Severity levels for constitutional rules
Line 162: Low severity - informational
Line 164: Medium severity - warning
Line 166: High severity - requires action
Line 168: Critical severity - blocks execution
Line 173: Create a new Python LLM bridge
Line 175: This initializes the Python interpreter and imports all necessary modules
Line 176: from the original Python codebase.
Line 178: Initialize Python interpreter
Line 182: Add the Python codebase to sys.path
Line 187: Import all Python LLM modules
Line 278: Generate structured code using Python implementation
Line 280: This calls the Python structured generator directly to ensure
Line 281: identical output during the FFI bridge phase.
Line 288: Convert constraints to Python dict
Line 308: Call Python method
Line 317: Detect critical mistakes using Python implementation
Line 399: Run constitutional AI validation using Python implementation
Line 406: Convert rules to Python list
Line 428: Start a new conversation session via Python
Line 437: Add a message to conversation via Python
Line 470: Get conversation history via Python
Line 482: Convert Python result to Rust structures
Line 489: Extract turn data and convert to Rust ConversationTurn
Line 527: Generate conversation summary via Python
Line 541: Would extract from Python
Line 542: Would extract from Python
Line 556: End conversation and get summary via Python
Line 561: Collect system metrics via Python
Line 611: Validate content via Python validation engine
Line 632: Would extract from Python
Line 650: Start monitoring via Python
Line 659: Assess constitutional AI via Python
Line 678: Would extract from Python
Line 688: Helper method to convert Python message to Rust structure
Line 707: Would extract from Python
Line 714: Check if a specific capability is available
Line 732: Try to call the capability check method
Line 740: Get available capabilities
Line 748: Generate bug fix using 97%+ success rate Python implementation
Line 767: Python call wrapper with comprehensive error handling
Line 777: Execute a Python call with error handling and timeout
Line 787: Attempt to acquire GIL with timeout
Line 790: Check if we've exceeded timeout
Line 797: Execute the Python call
Line 801: Convert PyO3 error to our error type
Line 823: Execute an async Python call (using tokio::task::spawn_blocking)
Line 846: Get the Python call wrapper for this bridge
Line 848: 30 second timeout
Line 851: Safe wrapper for Python calls with comprehensive error handling
Line 860: Safe wrapper for async Python calls
Line 870: Thread safety implementation with proper GIL handling
Line 874: Note: These impls are safe because:
Line 875: 1. Python objects are stored as PyObject which can be shared across threads
Line 876: 2. All Python calls go through Python::with_gil() which ensures thread safety
Line 877: 3. The PythonCallWrapper provides additional safety and timeout handling
Line 885: Requires Python environment setup
Line 892: Bridge created successfully
Line 896: Expected if Python environment not available
Line 905: All 12+ LLM capabilities

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 9780 characters
🤖 Analyzing: [████████████████████████████░░░░░░░░░░░░░░░░░░░░░░]  56% (17/30) - structured.rs...🔍 DEBUG PROMPT for structured.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate
- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/structured.rs
Language: rust
Comments found: 171

STRUCTURAL CONTEXT:
imports: use crate::{LlmConfig, LlmResult, LlmError, ffi::PythonLlmBridge, native_stub::NativeLlmEngine};., use super::*;., Imports: use serde_json::{Value, json};., Imports: use crate::{LlmConfig, LlmResult, LlmError, ffi::PythonLlmBridge, native_stub::NativeLlmEngine};., Imports: use std::time::Instant;., use crate::{LlmConfig, LlmResult, LlmError, ffi::PythonLlmBridge, native::NativeLlmEngine};., Imports: use jsonschema::{JSONSchema, Draft};., Imports: use serde::{Deserialize, Serialize};., Imports: use super::*;., Imports: use crate::{LlmConfig, LlmResult, LlmError, ffi::PythonLlmBridge, native::NativeLlmEngine};., Imports: use std::collections::HashMap;.
structure: calls GenerationStats::default., calls Self::new., calls GeneratorConfig::default., calls JSONSchema::options., calls Instant::now., calls LlmError::Inference., calls serde_json::from_str::<Value>., calls f64::from., calls LlmError::Schema., calls StructuredCodeGenerator::new., calls syn::parse_file., generate_native is a wrapper for Ok.result (lines 414).

COMMENTS TO ANALYZE:
Line 1: ! Structured Code Generation with Constraints
Line 3: ! This module provides structured code generation with JSON schema validation,
Line 4: ! grammar-based constraints, and constitutional AI guardrails, preserving the
Line 5: ! Python implementation's exact behavior during Phase 5a.
Line 18: Generation constraints for structured output
Line 21: JSON schema for output validation
Line 23: Grammar rules for structured generation
Line 25: Maximum output length
Line 27: Expected output format
Line 29: Additional validation rules
Line 33: Output format specification
Line 36: Plain text output
Line 38: Text output (alias for PlainText)
Line 40: Python source code
Line 42: Rust source code
Line 44: JavaScript source code
Line 48: JSON output (alias for JsonObject)
Line 50: Markdown formatted text
Line 54: Custom format with specification
Line 58: Structured code generator with constraint enforcement
Line 60: Phase 5b uses native LLM engine as primary implementation with FFI bridge fallback.
Line 64: JSON schema validator
Line 66: Native LLM engine (Phase 5b primary)
Line 68: Python FFI bridge (Phase 5a fallback)
Line 74: Configuration for structured generation
Line 77: Maximum generation attempts
Line 79: Timeout per generation attempt
Line 81: Whether to enable self-correction
Line 83: Whether to validate syntax
Line 85: Whether to enforce style guidelines
Line 87: Custom validation rules
Line 104: Custom validation rule
Line 109: Description of what this validates
Line 111: Regex pattern to match (if applicable)
Line 113: Python code to execute for validation
Line 119: Validation severity levels
Line 124: Warning but continue
Line 126: Error - retry generation
Line 128: Critical - fail completely
Line 135: Total generation attempts
Line 141: Average generation time (milliseconds)
Line 143: Total tokens generated
Line 145: Validation failure breakdown
Line 149: Generation result with metadata
Line 154: Whether generation was successful
Line 160: Correction attempts made
Line 162: Final confidence score
Line 166: Individual validation result
Line 171: Whether validation passed
Line 177: Location of issue (if applicable)
Line 181: Error location information
Line 184: Line number (1-indexed)
Line 186: Column number (1-indexed)
Line 188: Length of the issue
Line 190: Context around the error
Line 197: Time taken for generation (milliseconds)
Line 199: Model used for generation
Line 205: Whether self-correction was applied
Line 207: Constraint satisfaction score
Line 211: Syntax validation result
Line 214: Whether syntax is valid
Line 216: Syntax errors found
Line 222: Syntax error information
Line 235: Syntax warning information
Line 246: Types of syntax errors
Line 261: Types of syntax warnings
Line 275: Create a new structured code generator
Line 286: Create with Python FFI bridge for Phase 5a compatibility
Line 296: Set JSON schema for validation
Line 307: Generate structured code with constraints
Line 316: Phase 5a: Use Python bridge for guaranteed compatibility
Line 321: Native Rust implementation (Phase 5b)
Line 325: Generate via Python bridge (Phase 5a)
Line 332: Call Python structured generator directly
Line 358: Validate the generated code using Rust validators
Line 381: Not available from Python bridge
Line 382: Default from Python
Line 383: Handled by Python
Line 391: Native generation implementation (Phase 5b)
Line 417: Continue to next attempt for self-correction
Line 427: All attempts failed
Line 433: Attempt a single generation
Line 439: Enhanced prompt with constraints
Line 442: TODO: Integrate with Ollama or other LLM backend for native generation
Line 443: For now, return a placeholder
Line 461: Will be set by caller
Line 473: Build enhanced prompt with constraints
Line 477: Add output format instructions
Line 508: Add validation rules as constraints
Line 516: Add length constraint
Line 524: Validate generated code against constraints
Line 548: JSON schema validation
Line 601: Custom validation rules
Line 620: Validate syntax for specific output format
Line 636: Text format doesn't have strict syntax rules
Line 644: Plain text format doesn't have strict syntax rules
Line 661: Custom format validation not implemented
Line 675: Validate HTML syntax
Line 677: HTML syntax validation would require external parsers
Line 678: For now, provide a placeholder implementation
Line 690: Validate JavaScript syntax
Line 692: JavaScript syntax validation would require external tools or parsers
Line 693: For now, provide a placeholder implementation
Line 705: Validate Python syntax
Line 707: Use Python AST parsing via FFI bridge if available
Line 709: Call Python ast.parse() for accurate syntax validation
Line 710: TODO: Implement Python AST validation via FFI
Line 713: Basic validation for now
Line 717: Check for basic Python syntax issues
Line 721: Check indentation (very basic)
Line 724: Potential indentation issue
Line 732: Check for common syntax errors
Line 750: Validate Rust syntax
Line 752: Try to parse with syn crate
Line 762: proc_macro2::Span doesn't have start() method
Line 776: Validate JSON syntax
Line 801: Validate Markdown syntax
Line 803: Basic Markdown validation
Line 806: Check for common Markdown issues
Line 808: Check for headers without space after #
Line 819: Markdown is very forgiving
Line 825: Apply custom validation rule
Line 846: Unknown rule passes by default
Line 850: Calculate constraint satisfaction score
Line 879: Update generation statistics
Line 881: Update average time
Line 886: Update validation failure counts
Line 896: Get current generation statistics
Line 928: Missing closing brace
Line 942: Missing closing paren
Line 984: Should be partial satisfaction

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 9539 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  60% (18/30) - denoiser.rs...🔍 DEBUG PROMPT for denoiser.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate
- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/denoiser.rs
Language: rust
Comments found: 48

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., Imports: use aho_corasick::AhoCorasick;., use super::*;., use crate::comment_extractor::CommentType;., Imports: use crate::comment_extractor::{FileCommentExtraction, ExtractedComment, StructuralInsights};., Imports: use crate::comment_extractor::CommentType;., Imports: use serde::{Deserialize, Serialize};., use crate::comment_extractor::{FileCommentExtraction, ExtractedComment, StructuralInsights};., Imports: use std::collections::{HashMap, HashSet};.
structure: calls HashMap::new., calls Default::default., calls LlmContextDenoiser::new., calls DenoiserConfig::default., calls HashSet::new.

COMMENTS TO ANALYZE:
Line 1: ! LLM Context Denoiser
Line 3: ! This module removes redundant information, repeated phrases, and verbose content
Line 4: ! to fit large datasets within LLM context windows while preserving key insights.
Line 11: Configuration for the denoiser
Line 14: Target token reduction percentage (0.0 to 1.0)
Line 16: Minimum phrase length to consider for deduplication
Line 18: Maximum phrase length to consider
Line 20: Preserve structural insights (narrator bullet points)
Line 22: Preserve file paths and metadata
Line 38: Statistics about denoising operation
Line 49: Main denoiser for LLM context preparation
Line 52: Cache of common phrases found across files
Line 54: Cache of common words
Line 67: Denoise a collection of file extractions for LLM consumption
Line 69: Phase 1: Analyze frequency patterns across all files
Line 72: Phase 2: Clean each file extraction
Line 87: Track cleaning metrics
Line 112: Analyze frequency patterns across all files to identify redundancy
Line 123: Analyze structural insights if present
Line 134: Analyze frequency of words and phrases in text
Line 138: Count word frequency
Line 146: Count phrase frequency
Line 158: Denoise a single file extraction
Line 167: Clean structural insights (preserve but deduplicate)
Line 177: Denoise a single comment
Line 192: Denoise structural insights while preserving key information
Line 202: Remove exact duplicates but preserve similar items
Line 221: Core text denoising logic
Line 225: Step 1: Remove highly repeated phrases (appears in 5+ files)
Line 237: Step 2: Consolidate repeated words
Line 240: Step 3: Remove common filler phrases
Line 243: Step 4: Clean up whitespace
Line 249: Consolidate repeated words within the same text
Line 260: Only include word if it hasn't appeared too many times
Line 269: Remove common filler phrases that add no value
Line 296: Normalize whitespace and remove empty lines
Line 308: Normalize a word for frequency analysis
Line 315: Normalize a phrase for frequency analysis
Line 324: Calculate content size for statistics
Line 343: Count removed phrases for statistics
Line 345: Simplified for now - could implement detailed tracking
Line 349: Count consolidated words for statistics
Line 351: Simplified for now - could implement detailed tracking
Line 365: Simulate frequent phrases
Line 380: Should reduce repeated instances

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5784 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  63% (19/30) - file_processor.rs...🔍 DEBUG PROMPT for file_processor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate
- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/file_processor.rs
Language: rust
Comments found: 152

STRUCTURAL CONTEXT:
structure: analyze_single_file is a wrapper for Ok.create_empty_summary.extraction.total_tokens.llm_calls (lines 698)., calls fs::create_dir_all., calls LlmError::Io., calls RwLock::new., calls serde_json::from_str., calls LlmError::Http., calls StructuredCodeGenerator::new., calls PathBuf::new., generate_file_summary is a wrapper for Ok.file.extraction.file.clone.themes.vec.to_string.dependencies.vec.purpose.to_string.confidence.ConfidenceLevel.Low.llm_model.to_string.analysis_timestamp.chrono.Utc.now.to_rfc3339.token_usage.input.output (lines 489)., calls fs::write., calls CommentExtractor::with_config., calls PathBuf::from., generate_hierarchical_summary_with_budget is a wrapper for Err.LlmError.Inference.format.response.status (lines 464)., calls reqwest::Client::new., calls ExtractionConfig::default., calls LlmError::Inference., calls HashMap::new., calls serde_json::to_string., calls Path::new., calls serde_json::from_value., calls serde_json::to_string_pretty., calls OllamaPipeline::new., calls crate::structured::GeneratorConfig::default., generate_project_hierarchical_summary is a wrapper for Err.LlmError.Inference.format.response.status (lines 416)., generate_hierarchical_summary is a wrapper for Err.LlmError.Inference.format.response.status (lines 368)., calls Arc::new., calls chrono::Utc::now., calls crate::monitoring::AlertThresholds::default., process_codebase is a wrapper for Ok.create_failed_report.errors.start_time.elapsed (lines 600).
imports: Imports: use serde_json::Value;., Imports: use std::path::{Path, PathBuf};., Imports: use tokio::sync::RwLock;., use crate::{, Imports: use tokio::fs;., Imports: use codehud_core::query_engine::QueryEngine;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::collections::HashMap;., Imports: use crate::{, Imports: use std::sync::Arc;.
file_i/o: this scope performs file I/O via self.structured_generator.write() (lines 717, 755)., this scope performs file I/O via self.structured_generator.write().await.generate_structured_code(&prompt, (lines 717, 755)., this scope performs file I/O via fs::write(path, (lines 891).

COMMENTS TO ANALYZE:
Line 1: ! File Processing Pipeline for Comment Analysis
Line 3: ! This module implements the three-phase workflow described in LLM_vision.txt:
Line 4: ! 1. Extract comments from files -> comments.json
Line 5: ! 2. Generate per-file summaries using LLM -> summaries.json
Line 6: ! 3. Create system-wide summary -> system_summary.json
Line 26: Summary of a single file based on its comments
Line 29: File path that was analyzed
Line 31: Key themes identified from comments
Line 33: Dependencies mentioned in comments
Line 35: Overall purpose of the file
Line 37: Confidence level of the analysis
Line 39: LLM model used for analysis
Line 41: When the analysis was performed
Line 43: Token usage statistics
Line 47: System-wide summary of the entire codebase
Line 50: Overall themes across the entire system
Line 52: Key dependencies used throughout the system
Line 54: Overall purpose and description of the system
Line 56: Confidence level of the system analysis
Line 58: Metadata about the analysis process
Line 62: Confidence level of LLM analysis
Line 70: Token usage statistics
Line 73: Input tokens sent to LLM
Line 75: Output tokens received from LLM
Line 79: Analysis metadata for system summary
Line 82: Number of files analyzed
Line 84: Total comments extracted
Line 86: Programming languages detected
Line 88: Total analysis duration in seconds
Line 90: LLM model used
Line 94: Configuration for file processing pipeline
Line 97: Comment extraction configuration
Line 107: LLM analysis configuration
Line 110: Maximum tokens per file analysis
Line 112: Maximum tokens for system summary
Line 114: Whether to include code context in analysis
Line 116: Whether to extract TODO items
Line 118: Whether to analyze documentation coverage
Line 120: Temperature for LLM responses
Line 127: Output directory for analysis files
Line 129: Whether to create pretty-formatted JSON
Line 131: Whether to include debug information
Line 138: Whether to enable parallel file processing
Line 140: Maximum concurrent LLM calls
Line 142: Whether to use caching
Line 144: Cache duration in hours
Line 175: Processing report summarizing the entire analysis
Line 178: Overall success status
Line 180: Files processed successfully
Line 182: Files that failed processing
Line 184: Total processing time
Line 186: Output file paths
Line 194: Output file paths
Line 197: Path to comments.json
Line 199: Path to summaries.json
Line 201: Path to system_summary.json
Line 205: Processing error information
Line 208: File that caused the error
Line 212: Processing phase where error occurred
Line 225: Processing performance metrics
Line 228: Comment extraction time
Line 230: LLM analysis time
Line 232: System summary time
Line 234: Average time per file
Line 236: Total tokens processed
Line 238: LLM calls made
Line 242: Main file processor implementing the three-phase workflow
Line 246: LLM pipeline for analysis
Line 248: Structured code generator
Line 250: Constitutional AI for quality control
Line 252: Conversation tracker for context management
Line 254: LLM performance monitor
Line 261: Create a new file processor with all required components
Line 266: Create comment extractor
Line 271: Create LLM pipeline
Line 274: Create structured generator
Line 279: Create constitutional AI with default config
Line 289: Create conversation tracker with default config
Line 301: Create LLM monitor with default config
Line 324: Process a single file and return its summary
Line 326: Phase 1: Extract comments
Line 329: Phase 2: Generate LLM summary for this file
Line 335: Generate a text summary using the LLM (for FSM integration)
Line 336: REMOVED: Old generate_text_summary with low token limit
Line 337: Now using generate_hierarchical_summary for all summaries
Line 339: Generate hierarchical project summary with extended output tokens (600-1000 words)
Line 342: Make direct HTTP call to Ollama API with extended token limit
Line 355: Reduced from 1024 for more concise summaries
Line 387: Generate project-level hierarchical summary (SEPARATE from file summaries)
Line 390: Make direct HTTP call to Ollama API for PROJECT-LEVEL summary
Line 403: 1000 tokens for ~500 word project summary
Line 435: Generate hierarchical summary with custom token budget (for file summaries)
Line 438: Make direct HTTP call to Ollama API with custom token limit
Line 451: Custom token budget
Line 483: Generate LLM summary for a single file's comments
Line 485: Debug: Print comment extraction details
Line 487: If no comments found, return early
Line 517: Generate LLM analysis using actual API call
Line 522: Create file summary
Line 525: TODO: Parse from LLM response
Line 526: TODO: Extract from LLM response
Line 538: Process an entire codebase using the three-phase workflow
Line 551: Create output directory
Line 555: Phase 1: Extract comments from all files
Line 575: Phase 2: Generate per-file summaries using LLM
Line 589: Phase 3: Generate system-wide summary
Line 611: Calculate final metrics
Line 620: Create processing report
Line 636: Phase 1: Extract comments from all files in the codebase
Line 644: Convert to HashMap for JSON output matching vision format
Line 653: Extract comments sequentially (simpler, more stable)
Line 659: Extract comments in parallel (faster for large codebases)
Line 661: For now, use sequential implementation
Line 662: TODO: Implement true parallel processing with tokio tasks
Line 666: Phase 2: Analyze each file's comments using LLM
Line 695: Analyze a single file's comments using structured LLM generation
Line 701: Create structured prompt for file analysis
Line 704: Define constraints for structured generation
Line 716: Generate structured analysis
Line 719: Parse response into FileSummary
Line 728: Rough token estimation
Line 740: Phase 3: Generate system-wide summary from file summaries
Line 760: Add analysis metadata
Line 769: TODO: Calculate from extractions
Line 771: TODO: Calculate actual duration
Line 783: Build prompt for analyzing a single file's comments
Line 812: Build prompt for system-wide summary
Line 841: Get JSON schema for FileSummary
Line 855: Get JSON schema for SystemSummary
Line 869: Create empty summary for files with no comments
Line 883: Save data as JSON file
Line 895: Create failed processing report
Line 919: Get current LLM model name
Line 921: TODO: Get actual model name from LLM pipeline
Line 925: Extract language from file path
Line 943: Analysis statistics for tracking token usage

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 11382 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (20/30) - crate_summarizer.rs...🔍 DEBUG PROMPT for crate_summarizer.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- wrapper.rs: The file `wrapper.rs` in the `./codehud-llm/src/narrator/detectors/` directory is a Rust implementation of security detection for code analysis using static analysis techniques. It leverages an abstra
- imports_exports.rs: This Rust file, `./codehud-llm/src/narrator/detectors/imports_exports.rs`, is a part of the system's static code analysis module for detecting and reporting potential issues related to imports and exp
- comments.rs: This Rust file, `./codehud-llm/src/narrator/detectors/comments.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects commen
- io.rs: This file, `io.rs` in the directory `./codehud-llm/src/narrator/detectors`, is a Rust implementation for detecting and reporting potential security issues within source code. It utilizes the AhoCorasi
- module_relationships.rs: This Rust file, `module_relationships.rs`, is a part of the codehud-llm system's module detection and relationship analysis feature. It analyzes source code for potential issues related to intra-crate
- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/crate_summarizer.rs
Language: rust
Comments found: 155

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::read_to_string(cargo_path) (lines 186)., this scope performs file I/O via std::fs::read_to_string(&summaries_file) (lines 540)., this scope performs file I/O via std::fs::write(project_path.join("Cargo.toml"), (lines 1293).
imports: use crate::comment_extractor::{FileCommentExtraction, StructuralInsights};., Imports: use crate::denoiser::{LlmContextDenoiser, DenoiserConfig};., Imports: use std::collections::HashMap;., Imports: use std::path::{Path, PathBuf};., use crate::{LlmResult, LlmError, FileProcessor, ProcessorConfig};., Imports: use crate::comment_extractor::{FileCommentExtraction, StructuralInsights};., Imports: use super::*;., Imports: use walkdir::WalkDir;., Imports: use crate::{LlmResult, LlmError, FileProcessor, ProcessorConfig};., Imports: use tempfile::TempDir;., use super::*;., use crate::denoiser::{LlmContextDenoiser, DenoiserConfig};., Imports: use serde::{Deserialize, Serialize};.
structure: generate_subcrate_summaries is a wrapper for Ok.None (lines 980)., generate_crate_summary is a wrapper for Ok.crate_name.crate_info.name.clone.crate_path.make_relative_crate_path.crate_info.path.files_analyzed.crate_files.iter.map.f.make_relative_path.f.file.collect.summary_text.structural_insights.aggregate_structural_insights.crate_files.token_count.timestamp.chrono.Utc.now.subcrates.None (lines 401)., calls chrono::Utc::now., load_file_summaries_for_crate is a wrapper for Err.LlmError.Io.std.io.Error.new.std.io.ErrorKind.NotFound.format.summaries_file (lines 534)., calls Default::default., calls serde_json::from_str., calls LlmError::Io., calls PathBuf::from., calls LlmContextDenoiser::new., calls Path::new., calls CrateGrouper::new., calls LlmError::Config., generate_crate_summary_with_context is a wrapper for Ok.crate_name.crate_info.name.clone.crate_path.make_relative_crate_path.crate_info.path.files_analyzed.crate_files.iter.map.f.make_relative_path.f.file.collect.summary_text.structural_insights.aggregate_structural_insights.crate_files.token_count.timestamp.chrono.Utc.now.subcrates.subcrate_summaries.clone (lines 497)., calls TempDir::new., calls WalkDir::new., calls HashMap::new.

COMMENTS TO ANALYZE:
Line 1: ! Crate-Level Summarization for Hierarchical LLM Analysis
Line 3: ! This module implements hierarchical summarization by grouping files into crates
Line 4: ! and generating focused summaries for each crate before final project analysis.
Line 14: Summary of a single crate with its analysis
Line 17: Name of the crate
Line 19: Path to the crate directory
Line 21: Files analyzed in this crate
Line 23: LLM-generated summary text
Line 25: Aggregated structural insights
Line 27: Token count of the summary
Line 31: Subcrate summaries (for large crates with subdirectories)
Line 36: Summary of a subcrate (subdirectory within a crate) with recursive nesting
Line 39: Name/path of the subcrate (e.g., "narrator/detectors")
Line 41: Number of direct files in this subcrate (not including nested subcrates)
Line 43: Direct files in this subcrate
Line 45: LLM-generated summary for this subcrate
Line 47: Token count of the summary
Line 49: Total size in kilobytes (for prioritization)
Line 51: Nested subcrates (recursive structure)
Line 56: Cleaned file data for crate summarization input (using file summaries, not raw comments)
Line 59: Relative file path
Line 61: LLM-generated file summary (from file_summaries.json)
Line 63: Preserved structural insights for technical details
Line 67: Crate grouping and discovery
Line 70: Root project path
Line 76: Information about a discovered crate
Line 79: Crate name from Cargo.toml
Line 81: Path to crate directory
Line 83: Crate description from Cargo.toml
Line 87: Files belonging to this crate
Line 91: Main crate summarization engine
Line 93: File processor for LLM calls
Line 95: Denoiser for stage 1 cleaning
Line 99: Project root path for relative path conversion
Line 103: Configuration for crate summarization
Line 106: Maximum tokens per crate summary
Line 108: Whether to include code context in summaries
Line 110: Whether to analyze inter-crate dependencies
Line 112: Denoising aggressiveness (0.0 to 1.0)
Line 122: 40% reduction for crate inputs
Line 128: Create a new crate grouper for the project
Line 136: Discover all crates in the project
Line 142: Find all Cargo.toml files
Line 152: Skip tree-sitter grammars and ALL test directories
Line 162: Check for duplicates before adding
Line 177: Sort crates by name for consistent processing order
Line 184: Parse Cargo.toml to extract crate information
Line 216: Will be populated later
Line 220: Group files by their containing crate
Line 237: Update crate file lists
Line 246: Debug output for final grouping
Line 255: Find which crate a file belongs to
Line 257: Convert to absolute path and canonicalize to resolve symlinks
Line 264: Canonicalize paths to resolve any symlinks or '..' components
Line 268: Find the crate that contains this file
Line 273: Make crate path absolute and canonical for comparison
Line 323: Get discovered crate information
Line 330: Create a new crate summarizer
Line 335: Strip metadata for crate summaries
Line 349: Convert full path to project-relative path for token efficiency
Line 355: Fallback: just use filename if strip_prefix fails
Line 363: Convert crate path to project-relative path
Line 372: Generate summary for a single crate
Line 381: Load file summaries (hierarchical: file summaries → crate summary)
Line 384: Build crate summary prompt
Line 387: Check token budget (8K limit per crate)
Line 391: Apply more aggressive denoising if needed
Line 395: Generate summary via LLM with 8K budget
Line 413: Generate summary via LLM within budget
Line 416: Calculate actual token count
Line 419: Aggregate structural insights
Line 436: Generate context-aware crate summary using project memory
Line 448: Load file summaries (hierarchical: file summaries → crate summary)
Line 451: Filter files based on whether they belong to subcrates
Line 473: Build context-aware prompt with subcrates
Line 481: Check token budget (8K limit per crate)
Line 509: Generate summary via LLM with context
Line 527: Load file summaries for crate summary input (hierarchical: file summaries → crate summary)
Line 531: Load all file summaries from disk
Line 547: Create a lookup map for file summaries
Line 550: Build cleaned file data using file summaries + structural insights
Line 552: Get the file summary (required)
Line 572: Build prompt for crate summary generation
Line 598: Add LLM-generated file summary (primary source of understanding)
Line 602: Add structural insights for technical details
Line 629: Aggregate structural insights from all files in the crate
Line 648: Limit items per section to avoid bloat
Line 660: Apply aggressive denoising for oversized prompts (limit number of files)
Line 662: Simply limit to most important files (first N files)
Line 663: File summaries are already concise, so we just need to limit count
Line 668: Build context-aware prompt using project memory
Line 680: Add project context from memory
Line 704: Limit files to fit within token budget
Line 712: Add LLM-generated file summary (primary source)
Line 716: Add structural insights for technical details
Line 742: Build reduced context prompt for oversized prompts
Line 754: Add minimal context
Line 769: Very limited file data (just first line of summary)
Line 772: Take first sentence of file summary
Line 786: Generate summary using only structural insights (no comments) - ultra token efficient
Line 794: Build prompt using only structural insights
Line 797: Generate summary via LLM
Line 815: Build prompt using only structural insights - extremely token efficient
Line 827: Aggregate all structural insights
Line 834: Shorten long items for token efficiency
Line 857: Calculates total size in KB for a collection of files
Line 865: Detect subcrates recursively with unlimited nesting depth
Line 866: Returns a tree structure of subdirectories that meet the threshold (5+ files)
Line 873: Group files by immediate parent directory
Line 881: File is in a subdirectory
Line 889: Build subcrate nodes recursively
Line 892: Only create subcrate if it has 5+ files (threshold)
Line 899: Find direct files in this directory (not in subdirectories)
Line 912: Recursively find nested subcrates
Line 915: Calculate total size in KB
Line 931: Count all subcrates including nested ones
Line 940: Flatten all subcrates into a prioritized list for truncation
Line 941: Returns (full_path, size_kb, is_nested)
Line 958: Recursively add nested subcrates (marked as nested=true)
Line 962: nested subcrates are marked as nested
Line 969: Generate subcrate summaries recursively (bottom-up traversal)
Line 975: Detect subcrates from the crate root, not hardcoded src/ directory
Line 983: Count all subcrates including nested
Line 992: Determine which subcrates to keep (max 10)
Line 996: Sort by priority for TRUNCATION (will truncate from start):
Line 997: 1. Nested subcrates first (is_nested=true)
Line 998: 2. Within each group, smallest size first
Line 1001: nested comes first (truncated first)
Line 1002: top-level comes last (kept)
Line 1003: sort by size ascending
Line 1024: Calculate per-subcrate token budget (reduced from 500 to 250 max)
Line 1031: Generate summaries (skipping truncated ones)
Line 1055: Generate summary for a single subcrate (handles nesting recursively)
Line 1065: First, generate summaries for all nested subcrates (bottom-up)
Line 1071: Skip if this nested subcrate was truncated
Line 1088: Build prompt for this subcrate
Line 1106: Add nested subcrate summaries if present
Line 1122: Generate LLM summary with token budget
Line 1126: Collect file paths for this subcrate
Line 1143: Collect all file paths recursively from a subcrate summary
Line 1156: Build context-aware prompt with subcrate summaries
Line 1166: Add context from project memory
Line 1187: Add subcrate summaries if present
Line 1197: Add individual file summaries
Line 1217: Build reduced context prompt with subcrates (for when token budget is exceeded)
Line 1233: Add subcrate summaries (these are already compressed)
Line 1243: Only include first sentence of each individual file summary
Line 1266: Internal node structure for subcrate tree
Line 1286: Create a simple Cargo.toml
Line 1310: Mock file extractions

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 13144 characters
📦 Processing batch 5/6 (5 files)...
🤖 Analyzing: [███████████████████████████████████░░░░░░░░░░░░░░░]  70% (21/30) - comment_extractor.rs...🔍 DEBUG PROMPT for comment_extractor.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr
- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/comment_extractor.rs
Language: rust
Comments found: 168

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::read_to_string(file_path) (lines 193).
imports: Imports: use crate::{LlmResult, LlmError};., Imports: use crate::narrator::{NarratorConfig, DetectorRegistry, FileCst, Node, aggregate_findings, render::render_bullets_compact};., use crate::{LlmResult, LlmError};., Imports: use std::sync::Arc;., use crate::narrator::{NarratorConfig, DetectorRegistry, FileCst, Node, aggregate_findings, render::render_bullets_compact};., Imports: use std::collections::{HashMap, HashSet};., Imports: use codehud_core::query_engine::{QueryEngine, get_query_engine, SupportedLanguage};., Imports: use tree_sitter::Parser;., Imports: use std::path::{Path, PathBuf};., Imports: use walkdir;., Imports: use regex::Regex;., Imports: use serde::{Deserialize, Serialize};.
structure: calls ExtractionConfig::default., calls LlmError::ConfigurationError., calls HashSet::new., extract_function_name is a wrapper for Some.name.as_str.to_string (lines 605)., detect_language is a wrapper for Err.LlmError.ConfigurationError.format.extension (lines 506)., calls LlmError::Config., calls DetectorRegistry::new., calls HashMap::new., clean_comment_text_for_llm is a wrapper for text.trim.to_string (lines 740)., calls LlmError::Io., calls walkdir::WalkDir::new., calls NarratorConfig::default., fallback_comment_extraction is a wrapper for Err.LlmError.ConfigurationError.format.language (lines 436)., extract_class_name is a wrapper for Some.name.as_str.to_string (lines 624)., calls regex::Regex::new., calls Parser::new.

COMMENTS TO ANALYZE:
Line 1: ! Comment Extraction Engine with Tree-sitter Integration
Line 3: ! This module implements the core comment extraction functionality described in LLM_vision.txt,
Line 4: ! leveraging CodeHUD's existing enhanced tree-sitter infrastructure for high-performance
Line 5: ! multi-language comment analysis.
Line 17: Position information for comments in source code
Line 20: Line number (1-indexed)
Line 22: Column number (1-indexed)
Line 26: Type of comment detected
Line 29: Single line comment (// in Rust, # in Python)
Line 31: Block comment (/* */ in Rust)
Line 33: Documentation comment (/// in Rust, """ in Python)
Line 35: Multi-line documentation block
Line 39: Code context surrounding a comment
Line 42: Name of function the comment is associated with
Line 44: Name of class/struct the comment is associated with
Line 46: Module or namespace path
Line 48: 3-5 lines of code adjacent to the comment
Line 50: Whether this comment appears to document the following code
Line 54: Structural insights derived from AST analysis
Line 57: Source of these insights
Line 59: Whether these are generated (not human-written)
Line 61: Organized insights by category
Line 65: Cleaned format optimized for LLM consumption
Line 72: Cleaned comment text without JSON overhead
Line 74: Generated structural insights
Line 78: An extracted comment with rich metadata
Line 81: The comment text (without comment markers)
Line 83: Type of comment
Line 85: Byte offset in source file where comment starts
Line 87: Byte offset in source file where comment ends
Line 89: Line/column position where comment starts
Line 91: Line/column position where comment ends
Line 93: Surrounding code context
Line 97: Configuration for comment extraction
Line 100: Include single-line comments
Line 102: Include block comments
Line 104: Include documentation comments
Line 106: Extract code context around comments
Line 108: Number of lines of adjacent code to capture
Line 110: Minimum comment length to include (filters out noise)
Line 112: Maximum comment length to include (prevents huge comments)
Line 114: Skip comments that are just dividers (e.g., "// ========")
Line 133: Results of extracting comments from a single file
Line 136: File path that was analyzed
Line 138: Programming language detected
Line 140: Extraction method used
Line 142: List of extracted comments
Line 144: Generated structural insights about the code
Line 150: Statistics about comment extraction
Line 153: Total comments found
Line 155: Comments by type
Line 157: Total lines of code processed
Line 159: Processing time in milliseconds
Line 161: Whether extraction was successful
Line 163: Error message if extraction failed
Line 167: Main comment extractor leveraging CodeHUD's tree-sitter engine
Line 169: Configuration for extraction behavior
Line 174: Create a new comment extractor
Line 181: Create with custom configuration
Line 188: Extract comments from a single file
Line 192: Read file content
Line 196: Detect language from file extension
Line 199: Extract comments using tree-sitter
Line 202: Generate structural insights
Line 219: Extract comments from multiple files in a directory
Line 223: Walk directory recursively
Line 236: Skip build artifacts and common ignore patterns
Line 245: Check if we support this language
Line 251: Continue with other files
Line 260: Extract comments from file content using tree-sitter
Line 267: Use shared query engine instance for performance
Line 290: Extract comments from tree-sitter analysis result
Line 299: Look for dedicated comments section first
Line 308: Get comment type from the analysis
Line 314: Fallback: determine from text content
Line 362: Parse comment from tree-sitter highlight
Line 375: Extract comment text
Line 379: Determine comment type
Line 382: Extract context if enabled
Line 400: Parse comment from tree-sitter capture
Line 406: Similar to parse_comment_from_highlight but for capture format
Line 407: Implementation would be similar, adapting to capture data structure
Line 411: Fallback comment extraction using regex patterns
Line 419: Define regex patterns for different comment types
Line 442: Apply patterns line by line for better position tracking
Line 449: +1 for newline
Line 488: Detect programming language from file extension
Line 514: Clean comment text by removing comment markers and excess whitespace
Line 518: Remove common comment markers
Line 530: Remove leading asterisks from multiline comments
Line 539: Determine the type of comment based on markers
Line 556: Extract code context around a comment
Line 560: Find which line the comment is on
Line 570: +1 for newline
Line 573: Extract surrounding lines
Line 579: Try to extract function/class names (basic implementation)
Line 586: TODO: Extract from file structure
Line 592: Basic function name extraction
Line 594: Simple regex patterns for common languages
Line 613: Basic class name extraction
Line 632: Check if a comment should be included based on configuration
Line 634: Check comment type inclusion
Line 641: Check length constraints
Line 652: Skip divider comments if configured
Line 659: If comment is mostly divider characters, skip it
Line 668: Calculate extraction statistics
Line 698: Convert FileCommentExtraction to cleaned format optimized for LLM
Line 714: Clean comments by removing JSON overhead and comment markers
Line 723: Clean individual comment text for LLM consumption
Line 724: Conservative cleaning that preserves content while removing syntax bloat
Line 727: Only remove outermost comment markers, preserve inner content
Line 738: If cleaning made the text too short or empty, return original (minus just whitespace)
Line 746: Generate structural insights from code content
Line 750: Try to use narrator for bullet point generation
Line 762: Fallback to original method
Line 781: Extract entry points
Line 787: Extract IO operations
Line 793: Extract test patterns
Line 806: Generate bullet points using the narrator module
Line 810: Get the appropriate language parser
Line 814: Parse the content directly with tree-sitter
Line 822: Convert tree-sitter tree to FileCst format
Line 825: Use narrator to detect findings and generate bullet points
Line 832: Convert to StructuralInsights format
Line 835: Parse the bullet text into sections
Line 842: This is a section header
Line 849: This is a bullet point
Line 852: Special handling for role line
Line 857: Add the last section
Line 870: Convert language string to SupportedLanguage enum
Line 882: Convert tree-sitter tree to narrator FileCst format
Line 892: Recursively convert tree-sitter nodes to narrator Node format
Line 906: Include text for all nodes - detectors need text from parent nodes too
Line 920: Extract import patterns for multiple languages
Line 957: Limit to avoid noise
Line 960: Extract function/method patterns
Line 997: Skip test functions here, handle in test patterns
Line 1005: Limit to key functions
Line 1008: Extract entry point patterns
Line 1037: Extract IO operation patterns
Line 1041: File IO patterns
Line 1058: Network IO patterns
Line 1095: Extract test patterns
Line 1140: Format cleaned analysis as text for LLM consumption
Line 1141: Balanced approach: removes JSON bloat but preserves essential context
Line 1147: Add comments section with minimal formatting
Line 1150: Limit to avoid excessive length
Line 1160: Add structural insights with logical grouping
Line 1164: Organize sections in a logical order
Line 1170: Limit per section to avoid noise
Line 1180: Add any remaining sections (limited)
Line 1183: Even more limited for misc sections

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 11935 characters
🤖 Analyzing: [████████████████████████████████████░░░░░░░░░░░░░░]  73% (22/30) - conversation.rs...🔍 DEBUG PROMPT for conversation.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr
- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/conversation.rs
Language: rust
Comments found: 18

STRUCTURAL CONTEXT:
structure: calls LlmError::ConversationError., extract_conversation_summary is a wrapper for Ok.to_string (lines 287)., calls HashMap::new., calls Uuid::new_v4., calls Self::default., calls Utc::now., calls ProjectAnalysisMemory::new.
imports: Imports: use crate::crate_summarizer::CrateSummary;., Imports: use chrono::{DateTime, Utc};., use crate::ffi::PythonLlmBridge;., Imports: use std::collections::HashMap;., Imports: use serde::{Deserialize, Serialize};., use crate::{LlmError, LlmResult};., Imports: use crate::{LlmError, LlmResult};., use crate::crate_summarizer::CrateSummary;., Imports: use crate::ffi::PythonLlmBridge;., Imports: use uuid::Uuid;.

COMMENTS TO ANALYZE:
Line 422: Other strategies would be implemented here
Line 492: Project-level analysis memory for hierarchical summarization
Line 529: Accumulate insights from a crate summary
Line 535: Extract patterns from crate summary
Line 538: Extract architectural insights
Line 541: Extract technology stack information
Line 544: Build crate relationships
Line 548: Build enhanced context for final summary generation
Line 633: Look for crate references in summary
Line 646: Enhanced conversation tracker with project analysis memory
Line 648: Create a new project analysis memory for hierarchical processing
Line 651: Store in conversation context with special project ID
Line 663: 12K token budget for hierarchical analysis
Line 674: Get project analysis memory for a project
Line 677: For now, create empty memory - in full implementation would persist/retrieve
Line 681: Update project memory with crate insights
Line 683: In full implementation, would retrieve, update, and persist memory
Line 684: For now, just log the accumulation

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4490 characters
🤖 Analyzing: [██████████████████████████████████████░░░░░░░░░░░░]  76% (23/30) - extraction_fsm.rs...🔍 DEBUG PROMPT for extraction_fsm.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr
- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/extraction_fsm.rs
Language: rust
Comments found: 303

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via std::fs::write(&summary_file, (lines 583, 1526, 2117)., this scope performs file I/O via self.state.read() (lines 250)., this scope performs file I/O via serde_json::from_str( (lines 1866, 1941)., this scope performs file I/O via self.project_memory.write() (lines 2035)., this scope performs file I/O via std::fs::read_to_string(&subcrate_file) (lines 1986)., this scope performs file I/O via self.state.read().await.clone() (lines 250)., this scope performs file I/O via std::fs::read_to_string(&summaries_file) (lines 1790)., this scope performs file I/O via std::fs::write(&metadata_file, (lines 601, 1836)., this scope performs file I/O via std::fs::write(&summaries_file, (lines 589, 1801)., this scope performs file I/O via self.project_memory.read() (lines 1550)., this scope performs file I/O via std::fs::read_to_string(&metadata_file) (lines 1807)., this scope performs file I/O via std::fs::write(&crate_summaries_file, (lines 2030)., this scope performs file I/O via std::fs::write(&subcrate_file, (lines 1910)., this scope performs file I/O via self.project_context.read() (lines 364, 635, 663, 778, 806)., this scope performs file I/O via std::fs::read_to_string(&crate_summaries_file) (lines 2019, 2055)., this scope performs file I/O via std::fs::read_to_string(&extractions_file) (lines 1761, 1867, 1942)., this scope performs file I/O via self.project_memory.read().await.clone() (lines 1550)., this scope performs file I/O via self.state.write() (lines 268, 476, 488, 617, 689, 724, 807, 819, 1533, 2124)., this scope performs file I/O via std::fs::write(&extractions_file, (lines 561, 1772)., this scope performs file I/O via self.project_context.write() (lines 286, 448, 742).
structure: process_crate_phase3_summary is a wrapper for Ok (lines 1938)., calls serde_json::to_string_pretty., calls ProgressMonitor::new., calls ProgressStyle::default_bar., calls Box::new., build_enhanced_batch_context is a wrapper for Ok.String.new (lines 1134)., calls CrateSummarizerConfig::default., apply_intelligent_denoising is a wrapper for Ok.text.to_string (lines 1601)., process_event is a wrapper for Err.LlmError.Config.to_string (lines 400)., calls CrateGrouper::new., calls CrateSummarizer::new., calls serde_json::from_str., calls serde_json::from_str::<Vec<., start_project_scan is a wrapper for Ok (lines 566)., apply_dual_stage_denoising is a wrapper for Ok.crate_summaries.to_vec (lines 1560)., generate_final_summary is a wrapper for Err.LlmError.Config.to_string (lines 2059)., calls FileProcessor::new., calls ProgressBar::new., generate_file_summary is a wrapper for Ok.to_string (lines 833)., calls ProjectContext::default., calls PathBuf::from., calls RwLock::new., calls LlmError::Config., process_crate_phase1_files is a wrapper for Ok (lines 1747)., calls CommentExtractor::new., calls LlmResult::Ok., calls WalkDir::new., calls CommentExtractionFSM::discover_project_files_static., calls Arc::new., calls serde_json::from_str::<Vec<FileCommentExtraction>>., calls serde_json::from_str::<serde_json::Value>., enforce_token_budget is a wrapper for Ok.text.to_string (lines 1700)., calls serde_json::from_str::<Vec<CrateSummary>>., calls crate::conversation::ProjectAnalysisMemory::new., start_crate_discovery is a wrapper for Err.e (lines 1430)., process_crate_phase2_subcrates is a wrapper for Ok (lines 1863).
imports: Imports: use serde_json;., Imports: use crate::ollama::OllamaConfig;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::sync::Arc;., Imports: use crate::crate_summarizer::{CrateGrouper, CrateSummarizer, CrateSummarizerConfig, CrateSummary, CrateInfo};., Imports: use std::io::Write;., Imports: use std::collections::{HashMap, HashSet};., Imports: use std::path::{Path, PathBuf};., Imports: use crate::comment_extractor::{CommentExtractor, FileCommentExtraction, CleanedFileAnalysis};., Imports: use crate::progress_monitor::ProgressMonitor;., use crate::progress_monitor::ProgressMonitor;., use crate::crate_summarizer::{CrateGrouper, CrateSummarizer, CrateSummarizerConfig, CrateSummary, CrateInfo};., use crate::ollama::OllamaConfig;., use crate::comment_extractor::{CommentExtractor, FileCommentExtraction, CleanedFileAnalysis};., Imports: use walkdir::WalkDir;., Imports: use indicatif::{ProgressBar, ProgressStyle};., use crate::{LlmResult, LlmError, FileProcessor, ProcessorConfig};., Imports: use tokio::sync::RwLock;., Imports: use crate::{LlmResult, LlmError, FileProcessor, ProcessorConfig};., Imports: use chrono;.

COMMENTS TO ANALYZE:
Line 1: ! LLM Comment Extraction Finite State Machine
Line 3: ! This module implements an FSM-based interface for LLM comment extraction
Line 4: ! with two primary modes: single file scanning and project scanning with
Line 5: ! context accumulation.
Line 23: FSM states for the comment extraction process
Line 26: Initial state - ready to accept scan commands
Line 28: File picker mode - waiting for single file selection
Line 30: Single file scanning in progress
Line 32: Project scanning initialization
Line 34: Hierarchical project scan - discovering crates
Line 36: Processing files within each crate for crate-level summaries
Line 43: Project scanning in progress - processing individual files (legacy mode)
Line 50: Generating final project summary from crate summaries
Line 55: Accumulating context and generating project summary (legacy mode)
Line 57: Scan completed successfully
Line 63: Types of scan operations
Line 66: Single file scan with immediate result
Line 68: Project-wide scan with context accumulation
Line 72: Result of a scan operation
Line 75: Whether the scan completed successfully
Line 77: Number of files processed
Line 79: Total scan duration in seconds
Line 81: Summary description of results
Line 83: Any errors encountered
Line 99: Detailed scan results by type
Line 102: Single file scan result
Line 108: Project scan result with accumulated context
Line 116: File summary with accumulated context from previous files
Line 119: Path to the file
Line 123: LLM-generated summary for this file
Line 125: Context from previous files that influenced this summary
Line 127: Processing order in the project scan
Line 131: Project-wide summary with accumulated insights
Line 134: Overall project understanding
Line 136: Key architectural insights
Line 138: Common patterns found across files
Line 140: Identified issues or improvements
Line 142: Total files processed
Line 144: Total comments analyzed
Line 148: FSM events that trigger state transitions
Line 151: Start single file scan mode
Line 153: File selected for single scan
Line 155: Start project scan mode
Line 157: Project directory selected
Line 159: Single file processing completed
Line 165: Project file processing completed
Line 171: All project files processed, ready for final summary
Line 173: Crate discovery completed
Line 177: Single crate summary completed
Line 181: All crate summaries completed, ready for final summary
Line 185: Project summary generation completed
Line 189: Reset to initial state
Line 193: Context accumulator for project scans
Line 196: Accumulated understanding from processed files
Line 198: File summaries in processing order
Line 200: Total comments processed
Line 202: Architectural patterns discovered
Line 206: Main FSM for LLM comment extraction
Line 210: File processor for LLM analysis
Line 214: Project context accumulator
Line 216: Event listeners for GUI/CLI integration
Line 218: Project analysis memory for hierarchical context accumulation
Line 220: Whether to use insights-only mode for ultra token-efficient analysis
Line 225: Create a new FSM instance
Line 248: Get current state
Line 253: Add event listener for GUI/CLI integration
Line 261: Process an event and transition state
Line 279: From Ready state
Line 285: Reset project context
Line 287: Stay in Ready state until project is selected
Line 290: File picker mode
Line 296: Start async file processing
Line 300: Project selection - start with hierarchical crate discovery
Line 302: First, transition to crate grouping state
Line 307: Start async crate discovery
Line 311: File processing completion
Line 319: Will be updated by actual processing
Line 326: Project file completion
Line 332: Update project context
Line 343: All files processed, generate project summary
Line 349: Continue with next file
Line 361: Project summary completion
Line 369: Will be updated by actual processing
Line 378: Hierarchical processing state transitions
Line 380: Crate discovery completion
Line 388: Processing is now handled directly in start_crate_discovery
Line 389: This event handler is no longer needed but kept for compatibility
Line 393: Single crate summary completion
Line 406: All crates processed, move to final summary generation state
Line 409: This will be collected properly
Line 413: Process next crate
Line 421: This is now handled directly in start_crate_discovery
Line 425: All crate summaries complete - generate final summary
Line 434: Release the borrow before async call
Line 445: Reset to ready
Line 451: Invalid transitions - ignore or log
Line 460: Process a single file scan
Line 467: Generate LLM summary
Line 475: Directly update state instead of calling process_event to avoid recursion
Line 481: TODO: Track actual duration
Line 498: Start project scan with proper two-phase architecture
Line 501: Discover all supported files in the project
Line 511: PHASE 1: BULK COMMENT EXTRACTION (Tree-sitter only)
Line 518: Real-time progress bar for extraction
Line 532: Extract comments using tree-sitter (fast, no LLM calls)
Line 542: Continue with other files
Line 547: Clear progress bar and show Phase 1 completion
Line 555: Save extracted comments to JSON for potential reuse/debugging
Line 570: PHASE 2: BATCH LLM ANALYSIS WITH ENHANCED CONTEXT
Line 575: FINAL PHASE: Generate comprehensive project summary
Line 580: Save the results to files
Line 581: Save comprehensive summary
Line 586: Save individual file summaries as JSON
Line 592: Save project metadata
Line 626: Process a single project file without FSM recursion
Line 634: Get accumulated context for this file
Line 642: Generate LLM summary with context
Line 650: Add to project context
Line 656: Process a single file in project context (legacy recursive version)
Line 662: Get accumulated context for this file
Line 671: Generate LLM summary with context
Line 685: Handle project file completion directly
Line 688: Check if more files need processing by examining current state
Line 701: All files processed, move to summary generation
Line 705: Release the lock before calling generate_project_summary
Line 710: Continue with next file
Line 719: Don't recurse - just update state and let the caller continue
Line 734: Add file results to project context
Line 744: Create file summary with context
Line 756: Update accumulated knowledge
Line 765: Keep context manageable (limit to ~8000 characters)
Line 775: Generate final project summary
Line 780: Create comprehensive prompt for project summary
Line 788: Generate project summary using LLM
Line 793: TODO: Parse from LLM response
Line 794: TODO: Parse from LLM response
Line 795: TODO: Parse from LLM response
Line 805: Directly update state for project completion
Line 812: TODO: Track actual duration
Line 829: Generate LLM summary for a single file
Line 850: Generate LLM summary for a file with project context
Line 871: Generate comprehensive LLM analysis of all project comments at once
Line 904: Generate comprehensive project summary from individual file summaries
Line 930: Phase 2: Analyze all extractions with enhanced context and batching
Line 937: Group files into smart batches based on similarity or module structure
Line 943: Build enhanced context for this batch
Line 946: Process files in this batch with shared context
Line 962: Analyze this file with enhanced context and higher token limits
Line 969: Continue with other files
Line 975: Clear progress bar and show completion
Line 984: Ultra token-efficient insights-only file analysis for budget-constrained mode
Line 1006: Generate ultra-compact summary using only structural insights
Line 1013: Continue with other files
Line 1018: Clear progress bar and show completion
Line 1028: Generate ultra-compact file summary using only structural insights (token-efficient)
Line 1030: Build ultra-compact prompt using only structural insights
Line 1036: Add structural insights if available
Line 1052: Add only essential comments (limit to ~10 most important)
Line 1054: Filter out very short comments
Line 1055: Limit to 10 comments max
Line 1068: Debug: Show prompt length to verify it's compact
Line 1071: Generate summary using the LLM
Line 1075: Convert full file path to relative path for token efficiency
Line 1077: For now, just return the file name - this can be enhanced later with project-relative paths
Line 1085: Generate enhanced comprehensive project summary with increased token limits
Line 1114: Use enhanced token limits for comprehensive analysis
Line 1118: Group extractions into smart batches based on file structure and dependencies
Line 1121: Process 5 files at a time for better context sharing
Line 1123: Simple batching for now - can be enhanced with more sophisticated grouping
Line 1131: Build enhanced context for a batch of files
Line 1139: Include recent analyses for context
Line 1154: Generate enhanced file summary with better prompting and higher token limits
Line 1166: Add structural insights if available
Line 1177: If no structural insights, extract basic file context from file path and language
Line 1184: Extract filename which often indicates purpose
Line 1192: Filter out garbage comments (regex patterns, single words, etc.)
Line 1196: Skip single words, regex patterns, and other garbage
Line 1200: Skip common regex comment patterns
Line 1217: Debug: Log the actual prompt being sent to LLM
Line 1227: Discover supported files in a project directory
Line 1240: Only include Rust files for now (can expand later)
Line 1252: ================== HIERARCHICAL PROCESSING METHODS ==================
Line 1254: Static helper for discovering project files without borrowing self
Line 1281: Start crate discovery for hierarchical processing
Line 1286: Initialize crate grouper
Line 1289: Discover all crates in the project
Line 1292: If no crates found, create a virtual crate
Line 1303: Will be populated during processing
Line 1313: Start hierarchical crate processing directly
Line 1316: Clear output files from previous runs to prevent accumulation
Line 1325: Clear from multiple possible locations since working directory can vary
Line 1335: Create if doesn't exist, ignore errors
Line 1346: Initialize progress monitor (popup window if running in background)
Line 1347: Total steps: 3 phases per crate + 1 final summary
Line 1354: ===== PHASE 1: Extract comments and generate file summaries for ALL crates =====
Line 1382: ===== PHASE 2: Detect subcrates and generate subcrate summaries for ALL crates =====
Line 1409: ===== PHASE 3: Generate crate summaries for ALL crates =====
Line 1436: Generate final hierarchical summary
Line 1446: Mark as completed
Line 1452: Note: generate_final_summary() already sets the FSM state to ScanComplete
Line 1458: Generate hierarchical project summary from crate summaries
Line 1462: Apply dual-stage denoising to crate summaries for 12K budget
Line 1465: Build hierarchical summary prompt with 12K token budget
Line 1505: Enforce 12K token budget
Line 1509: Generate final summary via LLM with extended output tokens (1024 for 600-1000 words)
Line 1512: Create project summary
Line 1519: TODO: Could aggregate from crate summaries
Line 1522: Save the hierarchical summary to output
Line 1532: Update state to completed
Line 1548: Get project analysis memory for context-aware processing
Line 1553: Apply intelligent denoising that preserves technical content
Line 1557: Skip denoising for single crate scenarios to preserve content
Line 1566: Apply single-stage intelligent denoising (40% reduction, keeping 60%)
Line 1571: Rough token estimate
Line 1584: Apply intelligent denoising that preserves technical content (40% reduction)
Line 1589: Don't denoise very short summaries
Line 1594: Split into sentences and rank by importance
Line 1599: Keep very short summaries intact
Line 1612: Sort by importance score (descending)
Line 1615: Keep top 60% of sentences (40% reduction)
Line 1624: Sort by original order to maintain flow
Line 1636: Calculate importance score for a sentence (higher = more important)
Line 1641: Technical keywords boost
Line 1667: Penalize filler content
Line 1679: Boost sentences with concrete details
Line 1684: Length consideration (medium-length sentences often more informative)
Line 1695: Enforce token budget by truncating if necessary
Line 1697: Rough estimate: 4 chars per token
Line 1716: PHASE 1: Extract comments and generate file summaries for a single crate
Line 1720: Only discover files within this specific crate directory
Line 1731: Extract comments only from files in this crate
Line 1750: ===== SAVE STRUCTURED JSON DATA =====
Line 1758: Append extracted comments to cumulative JSON file
Line 1767: Add current crate's extractions
Line 1770: Save updated cumulative file
Line 1776: PHASE 2: BATCH LLM ANALYSIS WITH ENHANCED CONTEXT
Line 1780: Use ultra token-efficient insights-only file analysis
Line 1783: Use full enhanced context analysis
Line 1787: Append file summaries to cumulative JSON file
Line 1796: Add current crate's summaries
Line 1799: Save updated cumulative file
Line 1804: Update cumulative analysis metadata
Line 1819: Add current crate info
Line 1842: PHASE 2: Detect subcrates and generate subcrate summaries for a single crate
Line 1844: Skip if insights-only mode
Line 1852: Initialize crate summarizer
Line 1856: Load file summaries for this crate
Line 1859: Need to load comment extractions to pass to load_file_summaries_for_crate
Line 1870: Filter to just this crate's extractions (canonicalize both paths for comparison)
Line 1878: Convert file path to absolute by canonicalizing relative to project root
Line 1899: Generate subcrate summaries (bottom-up hierarchical summarization)
Line 1905: Save subcrate summaries to a JSON file for Phase 3 to load
Line 1918: PHASE 3: Generate crate summary for a single crate
Line 1920: Initialize crate summarizer
Line 1924: Get project memory for context-aware analysis
Line 1927: Determine output directory
Line 1934: Load comment extractions
Line 1945: Filter to just this crate's extractions (canonicalize both paths for comparison)
Line 1953: Convert file path to absolute by canonicalizing relative to project root
Line 1972: Generate crate summary using insights-only or full method based on configuration
Line 1974: Use ultra token-efficient insights-only analysis
Line 1980: Load file summaries for crate summary generation
Line 1983: Load pre-existing subcrate summaries (already generated in Phase 2)
Line 1996: Use full context-aware analysis with subcrate summaries
Line 2010: Save crate summary to cumulative JSON file
Line 2025: Add current crate summary
Line 2028: Save updated crate summaries
Line 2033: Update project memory with this crate's insights
Line 2042: Generate final hierarchical summary from all processed crates
Line 2046: Load real crate summaries from the generated file (use correct directory based on insights_only mode)
Line 2064: Apply dual-stage denoising to crate summaries for 12K budget
Line 2067: Build hierarchical summary prompt with 12K token budget
Line 2070: PUT FORMAT INSTRUCTIONS FIRST so they don't get truncated by enforce_token_budget
Line 2102: Enforce 12K token budget
Line 2106: Generate final summary via LLM using PROJECT-LEVEL function (1000 tokens, ~500 words)
Line 2109: Save the hierarchical summary to output (use correct directory based on insights_only mode)
Line 2123: Update state to completed
Line 2142: CLI interface for the FSM
Line 2152: Execute "scan file" command
Line 2156: Direct file path provided
Line 2160: Enter file picker mode
Line 2163: In a real CLI, this would show a file picker or prompt for input
Line 2169: Execute "scan project" command
Line 2178: In a real CLI, this would show a directory picker or prompt for input
Line 2184: Get current scan results
Line 2192: Reset FSM to ready state
Line 2198: GUI integration points
Line 2200: Show file picker dialog
Line 2202: Show project directory picker
Line 2204: Update progress display
Line 2206: Display scan results
Line 2208: Show error message

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 23326 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (24/30) - critical.rs...🔍 DEBUG PROMPT for critical.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr
- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/critical.rs
Language: rust
Comments found: 163

STRUCTURAL CONTEXT:
imports: Imports: use std::collections::HashMap;., use crate::{LlmResult, LlmError, ffi::PythonLlmBridge};., Imports: use super::*;., Imports: use std::time::Instant;., Imports: use crate::{LlmResult, LlmError, ffi::PythonLlmBridge};., Imports: use serde::{Deserialize, Serialize};., use super::*;.
structure: detect_security_vulnerabilities is a wrapper for Ok.Some.mistake_type.MistakeType.SecurityVulnerability.severity.description.format.description.location.Some.line.line_num.column.length.Some.mat.len.suggested_fix.Some.to_string.confidence.context.Some.to_string (lines 541)., detect_performance_issues is a wrapper for Ok.Some.mistake_type.MistakeType.PerformanceIssue.severity.rule.severity.description.format.description.location.Some.line.line_num.column.length.Some.mat.len.suggested_fix.rule.correction_template.clone.confidence.context.Some.to_string (lines 585)., detect_resource_leaks is a wrapper for Ok.Some.mistake_type.MistakeType.ResourceLeak.severity.description.format.description.location.Some.line.line_num.column.length.Some.mat.len.suggested_fix.Some.to_string.confidence.context.Some.to_string (lines 671)., generate_correction_for_mistake is a wrapper for Ok.Some.mistake_id.mistake_id.to_string.suggested_fix.suggested_fix.clone.method.CorrectionMethod.Template.confidence.explanation.format.mistake.description.location.mistake.location.clone.unwrap_or.line.column.length.None (lines 759)., calls Self::load_default_rules., calls CriticalMistakeDetector::load_default_rules., detect_logic_errors is a wrapper for Ok.Some.mistake_type.MistakeType.LogicError.severity.rule.severity.description.format.rule.description.description.location.Some.line.line_num.column.length.Some.mat.len.suggested_fix.rule.correction_template.clone.confidence.context.Some.to_string (lines 495)., calls regex::Regex::new., detect_type_mismatches is a wrapper for Ok.Some.mistake_type.MistakeType.TypeMismatch.severity.rule.severity.description.format.description.location.Some.line.line_num.column.length.Some.mat.len.suggested_fix.rule.correction_template.clone.confidence.context.Some.to_string (lines 628)., calls DetectionStats::default., calls Instant::now., calls Self::new., calls DetectorConfig::default., calls CriticalMistakeDetector::new., calls f64::from., detect_infinite_execution is a wrapper for Ok.Some.mistake_type.MistakeType.InfiniteExecution.severity.description.format.description.location.Some.line.line_num.column.length.Some.mat.len.suggested_fix.Some.to_string.confidence.context.Some.to_string (lines 714)., detect_syntax_errors is a wrapper for Ok.Some.mistake_type.MistakeType.SyntaxError.severity.rule.severity.description.rule.description.clone.location.Some.line.line_num.column.length.Some.mat.len.suggested_fix.rule.correction_template.clone.confidence.context.Some.to_string (lines 452).

COMMENTS TO ANALYZE:
Line 1: ! Critical Mistake Detection and Self-Correction System
Line 3: ! This module implements advanced mistake detection with automatic correction
Line 4: ! capabilities, preserving the Python implementation's 97%+ bug fix success rate
Line 5: ! during Phase 5a through FFI bridge integration.
Line 12: Types of critical mistakes that can be detected
Line 27: Infinite loops or recursion
Line 31: Location in code where a mistake was detected
Line 34: Line number (1-indexed)
Line 36: Column number (1-indexed)
Line 38: Length of the problematic code
Line 42: A detected critical mistake with correction information
Line 45: Type of mistake detected
Line 47: Severity level (1-10)
Line 49: Description of the mistake
Line 51: Location in the generated code
Line 55: Confidence in the detection (0.0-1.0)
Line 57: Context around the mistake
Line 61: Critical mistake detector with self-correction capabilities
Line 63: During Phase 5a, this delegates to the Python implementation for guaranteed
Line 64: compatibility while building the Rust analysis infrastructure.
Line 68: Analysis rules for different mistake types
Line 70: Python FFI bridge (Phase 5a)
Line 78: Configuration for mistake detection
Line 81: Enable syntax error detection
Line 83: Enable logic error detection
Line 85: Enable security vulnerability detection
Line 87: Enable performance issue detection
Line 89: Enable type mismatch detection
Line 91: Enable resource leak detection
Line 93: Enable infinite execution detection
Line 95: Maximum correction attempts
Line 97: Severity threshold for automatic correction
Line 99: Enable learning from corrections
Line 114: High severity and above
Line 120: Detection rule for specific mistake patterns
Line 125: Mistake type this rule detects
Line 129: Pattern to match (regex or code pattern)
Line 131: Rule severity (1-10)
Line 133: Language this rule applies to
Line 135: Suggested correction template
Line 137: Whether this rule is enabled
Line 144: Total code samples analyzed
Line 146: Total mistakes detected
Line 148: Mistakes by type
Line 150: Mistakes by severity
Line 156: Average detection time (milliseconds)
Line 158: False positive rate
Line 162: Record of a correction attempt
Line 165: Original code with mistake
Line 169: Mistakes that were corrected
Line 175: Correction method used
Line 177: Validation results after correction
Line 181: Methods used for correction
Line 192: Manual correction (human-provided)
Line 196: Validation result after correction
Line 201: Whether validation passed
Line 205: Time taken for validation (milliseconds)
Line 209: Types of validation performed
Line 226: Detection result with metadata
Line 235: Confidence in detections
Line 242: Time taken for detection (milliseconds)
Line 244: Number of rules applied
Line 246: Analysis depth level
Line 250: Code complexity score
Line 254: Analysis depth levels
Line 257: Surface-level pattern matching
Line 259: Syntax tree analysis
Line 269: Suggested correction for a detected mistake
Line 272: Mistake being corrected
Line 278: Confidence in the correction
Line 280: Explanation of the correction
Line 282: Location where correction should be applied
Line 287: Create a new critical mistake detector
Line 300: Create with Python FFI bridge for Phase 5a compatibility
Line 310: Detect critical mistakes in code
Line 315: Phase 5a: Use Python bridge for guaranteed compatibility
Line 320: Native Rust implementation (Phase 5b)
Line 324: Detect via Python bridge (Phase 5a)
Line 330: Call Python critical mistake detector directly
Line 345: Generate suggested corrections using Rust logic
Line 348: Update average detection time
Line 358: Python uses semantic analysis
Line 363: High confidence from Python implementation
Line 367: Native detection implementation (Phase 5b)
Line 374: Apply all enabled detection rules
Line 401: Generate suggested corrections
Line 414: Lower confidence for native implementation initially
Line 418: Apply a single detection rule
Line 424: Pattern matching based on rule type
Line 436: Detect syntax errors
Line 446: Use regex pattern matching for now
Line 471: Detect logic errors
Line 481: Common logic error patterns
Line 515: Detect security vulnerabilities
Line 525: Common security vulnerability patterns
Line 543: Security issues are high severity
Line 561: Detect performance issues
Line 571: Common performance issue patterns
Line 605: Detect type mismatches
Line 615: Basic type mismatch detection (would be enhanced with proper type inference)
Line 648: Detect resource leaks
Line 658: Resource leak patterns
Line 673: Resource leaks are serious
Line 691: Detect infinite execution patterns
Line 701: Infinite execution patterns
Line 716: Infinite execution is critical
Line 734: Generate suggested corrections for detected mistakes
Line 751: Generate correction for a specific mistake
Line 773: Generate correction based on mistake type
Line 805: Generate syntax correction
Line 817: Generate security correction
Line 834: Generate performance correction
Line 846: Detect programming language
Line 859: Calculate code complexity score
Line 866: Simple complexity calculation
Line 870: Load default detection rules
Line 916: Get current detection statistics
Line 921: Get correction history
Line 931: Add custom detection rule
Line 936: Remove detection rule by ID

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 10959 characters
🤖 Analyzing: [█████████████████████████████████████████░░░░░░░░░]  83% (25/30) - equivalence.rs...🔍 DEBUG PROMPT for equivalence.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- utility_class.rs: This Rust file, `./codehud-llm/src/narrator/detectors/utility_class.rs`, is a part of the code analysis and reporting system designed for static code inspection. It implements a feature that detects '
- render.rs: This file, `./codehud-llm/src/narrator/render.rs` in the Rust language, is designed for rendering code documentation and results into a format suitable for consumption by Language Model (LLM) like GPT
- constitutional.rs: This Rust file, `./codehud-llm/src/constitutional.rs`, is the main module of the codehud-llm system and it provides an interface for interacting with a local Language Model (LLM) inference engine usin
- lib.rs: This Rust file, `lib.rs` in the root directory of the project, serves as a central hub for all LLM (Large Language Model) operations within CodeHUD. It provides full integration with Python-based LLMs
- progress_monitor.rs: The file ./codehud-llm/src/progress_monitor.rs serves as the Progress Monitor for Background Execution in a code analysis system designed for static code analysis. It is responsible for managing progr
- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/equivalence.rs
Language: rust
Comments found: 49

STRUCTURAL CONTEXT:
structure: calls PythonLlmBridge::new., calls pyo3::PyErr::new::<pyo3::exceptions::PyRuntimeError, _>., calls crate::constitutional::ConstitutionalConfig::default., calls Self::load_bug_fix_test_cases., calls LlmError::Python., calls Utc::now., calls crate::validation::ValidationConfig::default.
imports: use crate::{LlmError, LlmResult, PythonLlmBridge};., Imports: use serde::{Deserialize, Serialize};., Imports: use std::collections::HashMap;., Imports: use chrono::{DateTime, Utc};., Imports: use std::path::Path;., Imports: use crate::{LlmError, LlmResult, PythonLlmBridge};.

COMMENTS TO ANALYZE:
Line 1: ! Zero-Degradation Equivalence Testing
Line 3: ! This module implements comprehensive testing to ensure the Rust FFI bridge
Line 4: ! produces identical results to direct Python calls, maintaining 97%+ bug fix
Line 5: ! success rate as required by the plan.
Line 31: Rust/Python execution time ratio
Line 42: Patterns that should be in the fix
Line 52: Create a new equivalence tester with Python bridge
Line 56: Load predefined test cases
Line 65: Run comprehensive equivalence tests
Line 69: Test 1: Structured Code Generation Equivalence
Line 72: Test 2: Critical Mistake Detection Equivalence
Line 75: Test 3: Constitutional AI Assessment Equivalence
Line 78: Test 4: Conversation Tracking Equivalence
Line 81: Test 5: Validation System Equivalence
Line 84: Test 6: Bug Fix Generation Equivalence (97% success rate test)
Line 110: Test structured code generation equivalence
Line 130: Call through Rust FFI bridge - convert constraints
Line 145: Direct Python call (would need to be implemented)
Line 151: 95% similarity threshold
Line 170: Test critical mistake detection equivalence
Line 179: Call through Rust FFI bridge
Line 188: Direct Python call
Line 194: Should detect at least one mistake
Line 213: Test constitutional AI assessment equivalence
Line 220: Call through Rust FFI bridge
Line 228: Direct Python call
Line 234: Should fail due to security issues
Line 253: Test conversation tracking equivalence
Line 259: Test conversation through Rust FFI bridge
Line 275: Direct Python call
Line 300: Test validation system equivalence
Line 311: Call through Rust FFI bridge
Line 319: Direct Python call
Line 325: Should detect security issues
Line 344: Test bug fix generation equivalence (97% success rate requirement)
Line 351: Generate bug fix through Rust FFI bridge
Line 362: Direct Python call
Line 369: Check if fix contains expected patterns
Line 395: Calculate text similarity between two outputs
Line 397: Simple similarity calculation based on common words and structure
Line 411: Calculate performance ratio (Rust/Python execution time)
Line 427: Direct Python call for comparison (simplified implementation)
Line 429: This would make direct Python calls without going through the bridge
Line 430: For now, return a placeholder that simulates Python output
Line 442: Load predefined bug fix test cases
Line 483: Generate comprehensive equivalence report

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5769 characters
📦 Processing batch 6/6 (5 files)...
🤖 Analyzing: [███████████████████████████████████████████░░░░░░░]  86% (26/30) - native_stub.rs...🔍 DEBUG PROMPT for native_stub.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 
- comment_extractor.rs: This file, `./codehud-llm/src/comment_extractor.rs` in Rust language, serves a vital role in the code analysis and reporting system CodeHUD. It's designed as an exhaustive comment extraction engine le
- conversation.rs: This file, `./codehud-llm/src/conversation.rs` in the Rust language, is designed for managing and tracking conversations related to code analysis using Large Language Model (LLM) inferences. It provid
- extraction_fsm.rs: This file is an implementation of a Finite State Machine (FSM) designed for code analysis and security vulnerability detection in various programming languages, including Python, Java, JavaScript, and
- critical.rs: This Rust file, `./codehud-llm/src/critical.rs`, is a critical mistake detection and self-correction system that implements advanced bug detection with automatic correction capabilities. It maintains 
- equivalence.rs: This file, `equivalence.rs` in the Rust codebase of CodeHud-LLM project, is designed for comprehensive testing and equivalence checking between Rust FFI bridge and direct Python calls, particularly fo

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/native_stub.rs
Language: rust
Comments found: 5

STRUCTURAL CONTEXT:
imports: use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError};., Imports: use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError};., Imports: use std::collections::HashMap;., Imports: use serde::{Deserialize, Serialize};., Imports: use log;., Imports: use tokio::sync::RwLock;., Imports: use std::path::PathBuf;., Imports: use std::sync::Arc;.

COMMENTS TO ANALYZE:
Line 1: ! Native Rust LLM Engine - Phase 5b Stub Implementation
Line 3: ! This is a stub implementation that provides the interface without candle dependencies
Line 4: ! for GUI integration testing. The full implementation will be enabled with candle feature.
Line 14: Native Rust LLM Engine stub
Line 58: Always loaded in stub mode

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3507 characters
🤖 Analyzing: [█████████████████████████████████████████████░░░░░]  90% (27/30) - native.rs...🔍 DEBUG PROMPT for native.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 
- comment_extractor.rs: This file, `./codehud-llm/src/comment_extractor.rs` in Rust language, serves a vital role in the code analysis and reporting system CodeHUD. It's designed as an exhaustive comment extraction engine le
- conversation.rs: This file, `./codehud-llm/src/conversation.rs` in the Rust language, is designed for managing and tracking conversations related to code analysis using Large Language Model (LLM) inferences. It provid
- extraction_fsm.rs: This file is an implementation of a Finite State Machine (FSM) designed for code analysis and security vulnerability detection in various programming languages, including Python, Java, JavaScript, and
- critical.rs: This Rust file, `./codehud-llm/src/critical.rs`, is a critical mistake detection and self-correction system that implements advanced bug detection with automatic correction capabilities. It maintains 
- equivalence.rs: This file, `equivalence.rs` in the Rust codebase of CodeHud-LLM project, is designed for comprehensive testing and equivalence checking between Rust FFI bridge and direct Python calls, particularly fo

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/native.rs
Language: rust
Comments found: 93

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via self.model_manager.write() (lines 313)., this scope performs file I/O via self.inference_engine.write() (lines 325, 342).
imports: use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError};., Imports: use candle_transformers::models::llama::LlamaConfig;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::path::PathBuf;., Imports: use candle_nn::{VarBuilder, Module};., Imports: use std::sync::Arc;., Imports: use hf_hub::api::tokio::Api;., Imports: use std::collections::HashMap;., Imports: use crate::{LlmConfig, ModelType, GpuType, LlmResult, LlmError};., Imports: use tokio::sync::RwLock;., Imports: use candle_core::{Device, Tensor, DType};., Imports: use tokenizers::Tokenizer;.
structure: calls ModelManager::new., calls Device::new_metal., calls HashMap::new., calls Tensor::zeros., calls jsonschema::JSONSchema::compile., calls Tokenizer::from_file., calls RwLock::new., validate_python_syntax is a wrapper for Err.LlmError.ValidationError.to_string (lines 470)., validate_bug_fix is a wrapper for Err.LlmError.ValidationError.to_string (lines 537)., calls ModelConfig::default., validate_generated_output is a wrapper for Err.LlmError.ValidationError.format.errors.collect.Vec (lines 423)., calls GenerationConfig::from_llm_config., calls candle_core::Device::cuda_if_available., calls Arc::new., calls LlmError::Inference., calls LlmError::Tokenization., calls Tensor::new., calls serde_json::from_str::<serde_json::Value>., calls LlmError::ValidationError., calls Self::initialize_device., calls Device::new_cuda., calls PathBuf::from., calls Self::load_tokenizer., calls InferenceEngine::new., calls Api::new., calls candle_core::Device::new_metal., calls chrono::Utc::now., calls ConstraintSystem::new.

COMMENTS TO ANALYZE:
Line 1: ! Native Rust LLM Engine - Phase 5b Implementation
Line 3: ! This module implements the native Rust LLM engine using candle-core,
Line 4: ! replacing the FFI bridge from Phase 5a while maintaining 97%+ bug fix
Line 5: ! success rate and zero-degradation compatibility.
Line 19: Placeholder types when candle is not available
Line 34: Native Rust LLM Engine using candle-core
Line 36: Model management and loading
Line 38: Tokenizer for input/output processing
Line 40: Inference engine for model execution
Line 42: Constraint system for structured generation
Line 46: Device for computation (CPU/CUDA/Metal)
Line 50: Model Manager for handling multiple model types
Line 52: Loaded models cache
Line 54: HuggingFace API for model downloading
Line 56: Model cache directory
Line 60: Loaded model with metadata
Line 63: Model weights and architecture
Line 69: Device the model is loaded on
Line 73: Model configuration matching Python implementation
Line 97: Native inference engine
Line 99: Current active model
Line 103: KV cache for conversation context
Line 107: Generation configuration matching Python behavior
Line 121: KV Cache for efficient conversation handling
Line 124: Cached key-value pairs
Line 128: Max cache length
Line 132: Constraint system for structured generation
Line 134: JSON schema validators
Line 136: Grammar rules for code generation
Line 138: Constraint enforcement strategies
Line 142: Grammar rule for structured generation
Line 151: Constraint enforcement strategy
Line 161: Create a new native LLM engine
Line 163: Initialize device based on GPU configuration
Line 166: Initialize model manager
Line 169: Load tokenizer for the specified model
Line 172: Initialize inference engine
Line 177: Initialize constraint system
Line 190: Initialize device for computation
Line 213: Load tokenizer for the specified model
Line 222: Download tokenizer from HuggingFace
Line 233: Generate structured code with constraints (native implementation)
Line 242: Load model if not already loaded
Line 245: Apply constraints and generate
Line 248: Validate and post-process output
Line 252: Detect critical mistakes (native implementation)
Line 258: Analyze code for potential issues
Line 261: Generate analysis using the model
Line 265: Parse analysis into structured mistake format
Line 269: Generate bug fix with 97%+ success rate (core requirement)
Line 276: Build comprehensive fix prompt
Line 279: Generate fix with constraints to ensure correctness
Line 286: Validate fix quality and correctness
Line 290: Assess constitutional AI compliance (native implementation)
Line 304: === Private Helper Methods ===
Line 327: Convert tokens to tensor
Line 330: Generate with constraint guidance
Line 416: Validate against JSON schema if provided
Line 430: Validate output format
Line 439: Other formats would be validated here
Line 446: Use Python AST validation through tokenizer or external tool
Line 447: For now, basic validation
Line 452: Check for common syntax issues
Line 481: Parse LLM analysis into structured mistake format
Line 484: Simple parsing logic (would be more sophisticated in practice)
Line 507: Additional mistake detection patterns would be implemented here
Line 513: Find division operators in code
Line 532: Validate that the fix addresses the reported error
Line 535: Check that fix is different from original
Line 540: Validate fix addresses the specific error
Line 554: Parse LLM assessment into structured format
Line 562: Would be parsed from analysis
Line 565: Would be extracted from analysis
Line 570: === Implementation of supporting structures ===
Line 592: Download model files
Line 599: For now, create a placeholder loaded model
Line 600: In a real implementation, this would load the actual model weights
Line 635: Real implementation would use candle-core for inference with constraints
Line 636: Dummy token sequence
Line 641: Dummy token sequence
Line 687: Placeholder model implementation
Line 692: Placeholder - would implement actual forward pass

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8602 characters
🤖 Analyzing: [██████████████████████████████████████████████░░░░]  93% (28/30) - monitoring.rs...🔍 DEBUG PROMPT for monitoring.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 
- comment_extractor.rs: This file, `./codehud-llm/src/comment_extractor.rs` in Rust language, serves a vital role in the code analysis and reporting system CodeHUD. It's designed as an exhaustive comment extraction engine le
- conversation.rs: This file, `./codehud-llm/src/conversation.rs` in the Rust language, is designed for managing and tracking conversations related to code analysis using Large Language Model (LLM) inferences. It provid
- extraction_fsm.rs: This file is an implementation of a Finite State Machine (FSM) designed for code analysis and security vulnerability detection in various programming languages, including Python, Java, JavaScript, and
- critical.rs: This Rust file, `./codehud-llm/src/critical.rs`, is a critical mistake detection and self-correction system that implements advanced bug detection with automatic correction capabilities. It maintains 
- equivalence.rs: This file, `equivalence.rs` in the Rust codebase of CodeHud-LLM project, is designed for comprehensive testing and equivalence checking between Rust FFI bridge and direct Python calls, particularly fo

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/src/monitoring.rs
Language: rust
Comments found: 18

STRUCTURAL CONTEXT:
imports: use crate::{LlmError, LlmResult};., Imports: use tokio::time::{interval, Instant};., Imports: use crate::ffi::PythonLlmBridge;., Imports: use serde::{Deserialize, Serialize};., use crate::ffi::PythonLlmBridge;., Imports: use crate::{LlmError, LlmResult};., Imports: use std::collections::HashMap;., Imports: use chrono::{DateTime, Utc, Duration};.
structure: calls tokio::time::Duration::from_secs., calls HashMap::new., calls uuid::Uuid::new_v4., calls Duration::hours., calls serde_json::Value::Number., calls serde_json::Number::from., calls Duration::days., calls serde_json::to_value., calls Utc::now., calls AlertThresholds::default., calls Instant::now.

COMMENTS TO ANALYZE:
Line 165: Run health checks
Line 225: Would be implemented based on actual queue
Line 226: Would track active requests
Line 238: Would be calculated from validation results
Line 239: Would be calculated from user feedback
Line 240: Would be calculated from content analysis
Line 243: Would be collected from user feedback
Line 252: Would be calculated from actual usage
Line 253: Would track maximum concurrent users
Line 254: Would track actual bandwidth
Line 391: Simplified memory usage calculation
Line 392: Would use actual system metrics
Line 396: Simplified CPU usage calculation
Line 397: Would use actual system metrics
Line 401: Would query actual GPU metrics
Line 406: Would calculate from actual request history
Line 411: Would calculate tokens per second

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4249 characters
🤖 Analyzing: [████████████████████████████████████████████████░░]  96% (29/30) - phase_5b_validation.rs...🔍 DEBUG PROMPT for phase_5b_validation.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 
- comment_extractor.rs: This file, `./codehud-llm/src/comment_extractor.rs` in Rust language, serves a vital role in the code analysis and reporting system CodeHUD. It's designed as an exhaustive comment extraction engine le
- conversation.rs: This file, `./codehud-llm/src/conversation.rs` in the Rust language, is designed for managing and tracking conversations related to code analysis using Large Language Model (LLM) inferences. It provid
- extraction_fsm.rs: This file is an implementation of a Finite State Machine (FSM) designed for code analysis and security vulnerability detection in various programming languages, including Python, Java, JavaScript, and
- critical.rs: This Rust file, `./codehud-llm/src/critical.rs`, is a critical mistake detection and self-correction system that implements advanced bug detection with automatic correction capabilities. It maintains 
- equivalence.rs: This file, `equivalence.rs` in the Rust codebase of CodeHud-LLM project, is designed for comprehensive testing and equivalence checking between Rust FFI bridge and direct Python calls, particularly fo

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/tests/phase_5b_validation.rs
Language: rust
Comments found: 27

STRUCTURAL CONTEXT:
imports: Imports: use std::path::PathBuf;., Imports: use codehud_llm::{
structure: calls codehud_llm::ollama::ModelParameters::default., calls LlmConfig::default., calls OllamaPipeline::with_native_engine., calls NativeLlmEngine::new., calls codehud_llm::constitutional::ConstitutionalConfig::default.

COMMENTS TO ANALYZE:
Line 1: ! Phase 5b Native LLM Implementation Validation Tests
Line 3: ! These tests validate that the native Rust LLM engine maintains 97%+ bug fix
Line 4: ! success rate and zero-degradation compatibility while eliminating Python dependencies.
Line 18: Use CPU for testing
Line 31: Test basic functionality
Line 68: Create pipeline with native engine
Line 71: Test basic text generation
Line 112: Validate fix quality
Line 131: Phase 5b requirement: maintain 97%+ success rate
Line 276: Test native engine performance
Line 281: Validate output quality
Line 289: Performance should be reasonable (less than 30 seconds for simple generation)
Line 303: Test 1: Native engine initialization
Line 308: Test 2: Model management (4+ model types)
Line 318: Test 3: GPU acceleration types
Line 322: Test 4: Core LLM capabilities
Line 336: Critical mistake detection
Line 340: Bug fix generation
Line 363: Helper function to simulate model availability check
Line 365: In a real implementation, this would check if the model is downloaded
Line 374: Helper function to simulate GPU availability check
Line 377: CPU always available
Line 379: Would check for CUDA installation
Line 383: Would check for Metal support (macOS)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4338 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (30/30) - equivalence_tests.rs...🔍 DEBUG PROMPT for equivalence_tests.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- ffi.rs: The file `ffi.rs` in the CodeHud-LLM project serves as a Foreign Function Interface (FFI) bridge between Rust and Python. It provides direct calls to over 120+ Python LLM implementations, allowing for
- structured.rs: This file, `structured.rs` in the Rust language, serves a crucial role in the codehud-llm system. It provides structured code generation capabilities that employ JSON schema validation, grammar-based 
- denoiser.rs: This file, `denoiser.rs` in the Rust language, serves as a denoising module for Large Language Model (LLM) context preparation. It focuses on reducing redundant information and verbose content within 
- file_processor.rs: This Rust file, `./codehud-llm/src/file_processor.rs`, is a key component of the code analysis system CodeHUD and serves as the primary module for processing source code files. It implements a three-p
- crate_summarizer.rs: This file, `crate_summarizer.rs` in the Rust codebase, is designed specifically for generating summaries of crates (Rust's equivalent of a module) and sub-crates within a project. It provides various 
- comment_extractor.rs: This file, `./codehud-llm/src/comment_extractor.rs` in Rust language, serves a vital role in the code analysis and reporting system CodeHUD. It's designed as an exhaustive comment extraction engine le
- conversation.rs: This file, `./codehud-llm/src/conversation.rs` in the Rust language, is designed for managing and tracking conversations related to code analysis using Large Language Model (LLM) inferences. It provid
- extraction_fsm.rs: This file is an implementation of a Finite State Machine (FSM) designed for code analysis and security vulnerability detection in various programming languages, including Python, Java, JavaScript, and
- critical.rs: This Rust file, `./codehud-llm/src/critical.rs`, is a critical mistake detection and self-correction system that implements advanced bug detection with automatic correction capabilities. It maintains 
- equivalence.rs: This file, `equivalence.rs` in the Rust codebase of CodeHud-LLM project, is designed for comprehensive testing and equivalence checking between Rust FFI bridge and direct Python calls, particularly fo

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-llm/tests/equivalence_tests.rs
Language: rust
Comments found: 39

STRUCTURAL CONTEXT:
structure: calls tokio::spawn., calls futures::future::try_join_all., calls fs::read_to_string., calls PathBuf::from., calls value.parse::<u64>., calls EquivalenceTester::new., calls Utc::now.
file_i/o: this scope performs file I/O via fs::read_to_string("/proc/self/status") (lines 260)., this scope performs file I/O via std::fs::write("target/equivalence_report.md", (lines 183).
imports: Imports: use std::path::PathBuf;., Imports: use codehud_llm::EquivalenceTester;., Imports: use tokio_test;., Imports: use codehud_llm::equivalence::{BugFixTestCase, EquivalenceTestResult};., Imports: use std::fs;., Imports: use codehud_llm::{EquivalenceTester, LlmResult};., Imports: use chrono::Utc;.

COMMENTS TO ANALYZE:
Line 1: ! Comprehensive Equivalence Tests for Zero-Degradation Validation
Line 3: ! These tests ensure the Rust FFI bridge maintains 97%+ bug fix success rate
Line 4: ! and produces equivalent results to the Python implementation.
Line 11: Requires Python environment setup
Line 13: Set up the equivalence tester
Line 14: Adjust path as needed
Line 17: Run the full equivalence test suite
Line 20: Generate and print report
Line 24: Assert critical requirements
Line 37: Performance should not degrade significantly (allow up to 2x slower for FFI overhead)
Line 49: Requires Python environment setup
Line 64: Requires Python environment setup
Line 79: Requires Python environment setup
Line 112: Test that we can create the equivalence testing structures
Line 149: Create a mock tester for testing similarity calculation
Line 150: Note: This would need the actual Python environment in practice
Line 153: Test similarity calculation logic
Line 157: Perfect match should be 1.0 similarity
Line 158: This would need to be implemented as a standalone function for testing
Line 162: Integration test that validates the complete zero-degradation pipeline
Line 164: Requires full Python environment and test data
Line 168: Step 1: Initialize the equivalence tester
Line 171: Step 2: Run comprehensive equivalence tests
Line 174: Step 3: Validate all zero-degradation requirements
Line 179: Step 4: Generate comprehensive report
Line 182: Write report to file for review
Line 192: Stress test for concurrent FFI bridge usage
Line 194: Requires Python environment setup
Line 199: Create multiple concurrent tasks
Line 208: Wait for all tasks to complete
Line 223: Memory leak detection test for long-running FFI usage
Line 225: Requires Python environment setup
Line 232: Run many iterations to detect potential memory leaks
Line 237: Check memory every 100 iterations
Line 242: Allow reasonable memory growth but detect leaks
Line 255: Helper function to get current memory usage
Line 264: Convert KB to bytes
Line 270: Fallback for unsupported platforms

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5562 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (30/30) - Complete!
✅ Phase 2 complete: 30 files analyzed with enhanced context
📄 File summaries updated: 113 total files (30 from codehud-llm)
📄 Analysis metadata updated: 5 crates processed
🔍 DEBUG: Crate path for codehud-realtime: ./codehud-realtime
🔍 Processing 1 files from crate codehud-realtime
🔍 DEBUG: First 5 files discovered for crate codehud-realtime:
  1. ./codehud-realtime/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-realtime/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-realtime/src/lib.rs
💾 Comments JSON updated: 114 total files (1 from codehud-realtime)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-realtime...
🤖 Analyzing 1 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (1 files)...
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (1/1) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-realtime/src/lib.rs
Language: rust
Comments found: 51

STRUCTURAL CONTEXT:
imports: Imports: use chrono::{DateTime, Utc};., Imports: use std::{, Imports: use tokio::{, Imports: use std::collections::hash_map::DefaultHasher;., Imports: use tokio_stream::{wrappers::ReceiverStream, StreamExt};., Imports: use anyhow::{Context, Result};., Imports: use codehud_core::{, Imports: use notify::{Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher};., Imports: use std::hash::{Hash, Hasher};., Imports: use serde::{Deserialize, Serialize};., Imports: use codehud_utils::logging::get_logger;.
file_i/o: this scope performs file I/O via cache.read() (lines 445)., this scope performs file I/O via std::fs::read_to_string(file_path) (lines 472)., this scope performs file I/O via cache.write() (lines 461).
structure: calls AnalysisCache::default., calls Self::analyze_single_file., calls Self::process_events., calls QualityExtractor::new., calls Self::should_skip_file., calls Self::calculate_file_hash., calls MonitorConfig::default., calls mpsc::channel., calls SecurityExtractor::new., calls serde_json::to_value., calls Self::update_cache., new is a wrapper for Err.anyhow.anyhow.codebase_path.display (lines 136)., calls HashSet::new., calls DefaultHasher::new., calls RwLock::new., calls Utc::now., calls TopologyExtractor::new., calls Arc::new., calls Duration::from_secs., calls Duration::from_millis.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Real-time - Real-time analysis and file watching
Line 3: ! This crate provides real-time file system monitoring and incremental
Line 4: ! analysis capabilities matching the Python implementation.
Line 30: Real-time file monitoring and analysis system
Line 39: Configuration for real-time monitoring
Line 42: Debounce delay for file changes (milliseconds)
Line 44: Maximum files to analyze in a single batch
Line 46: Analysis timeout per file (seconds)
Line 48: Enable incremental analysis (only changed files)
Line 50: File patterns to watch
Line 52: File patterns to ignore
Line 80: Cache for analysis results
Line 88: Result of analyzing a single file
Line 100: Events emitted by the real-time monitor
Line 103: File was modified
Line 108: Analysis started for a batch of files
Line 113: Analysis completed for a file
Line 117: Batch analysis completed
Line 123: Error occurred during monitoring
Line 131: Create a new real-time monitor
Line 151: Configure the monitor
Line 157: Start real-time monitoring
Line 163: Set up file watcher
Line 178: Watch the codebase directory
Line 184: Start the event processing loop
Line 214: Process file system events
Line 229: Handle file system events
Line 248: Handle debounced batch processing
Line 279: Extract relevant files from a file system event
Line 289: Check if a file should be analyzed
Line 291: Must be within codebase
Line 296: Check ignore patterns
Line 306: Check watch patterns
Line 316: Analyze a batch of files
Line 328: Notify analysis started
Line 337: Check if we need to analyze this file (incremental analysis)
Line 346: Analyze the file with timeout
Line 376: Notify batch completed
Line 385: Analyze a single file
Line 402: Run topology analysis
Line 410: Run quality analysis
Line 418: Run security analysis
Line 439: Check if file should be skipped (for incremental analysis)
Line 454: Update analysis cache
Line 467: Calculate hash of file contents
Line 479: Simple glob pattern matching
Line 481: Simple implementation - in production would use glob crate

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3887 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (1/1) - Complete!
✅ Phase 2 complete: 1 files analyzed with enhanced context
📄 File summaries updated: 114 total files (1 from codehud-realtime)
📄 Analysis metadata updated: 6 crates processed
🔍 DEBUG: Crate path for codehud-transform: ./codehud-transform
🔍 Processing 15 files from crate codehud-transform
🔍 DEBUG: First 5 files discovered for crate codehud-transform:
  1. ./codehud-transform/src/types.rs
  2. ./codehud-transform/src/lib.rs
  3. ./codehud-transform/src/engine.rs
  4. ./codehud-transform/src/rollback.rs
  5. ./codehud-transform/src/libcst.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/types.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/types.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/engine.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/engine.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/rollback.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/rollback.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/libcst.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/libcst.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/test_generation.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/test_generation.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/multi_language.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/multi_language.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/magic_numbers.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/magic_numbers.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/unused_args.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/unused_args.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/multi_language_old.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/multi_language_old.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/batch.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/batch.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/test_generation_old.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/test_generation_old.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/unused_args_old.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/unused_args_old.rs
🔍 DEBUG: Generating structural insights for ./codehud-transform/src/transformers/architectural.rs
✅ DEBUG: Narrator method succeeded for ./codehud-transform/src/transformers/architectural.rs
💾 Comments JSON updated: 129 total files (15 from codehud-transform)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-transform...
🤖 Analyzing 15 files with enhanced context and improved token limits...
📦 Processing batch 1/3 (5 files)...
🤖 Analyzing: [███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]   6% (1/15) - types.rs...🔍 DEBUG PROMPT for types.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-transform/src/types.rs
Language: rust
Comments found: 114

STRUCTURAL CONTEXT:
imports: Imports: use serde::{Serialize, Deserialize};., Imports: use std::collections::HashMap;., Imports: use codehud_core::models::AnalysisResult;., Imports: use chrono::{DateTime, Utc};., Imports: use super::*;., use super::*;.
structure: calls HashMap::new., calls TransformationType::all., calls TransformConfig::default.

COMMENTS TO ANALYZE:
Line 1: ! Transformation Types and Core Data Structures
Line 3: ! This module defines all transformation types and supporting data structures
Line 4: ! exactly matching the Python implementation for zero degradation.
Line 11: All transformation types implemented exactly as in Python
Line 14: Extract magic numbers to constants
Line 16: Large-scale architectural changes
Line 18: Batch transformations with formatting
Line 20: Cross-language transformations via Comby
Line 22: Property-based and search-based test creation
Line 24: Code cleanup and dead code elimination
Line 29: Get all transformation types
Line 41: Get string representation matching Python
Line 53: Get display name for UI
Line 65: Check if transformation supports dry run
Line 72: Creates new files
Line 77: Check if transformation supports rollback
Line 79: All transformations support rollback via Git integration
Line 84: Status of a transformation operation - matching Python exactly
Line 87: Transformation is pending execution
Line 89: Transformation is currently in progress
Line 91: Transformation completed successfully
Line 95: Transformation was rolled back
Line 100: Get string representation matching Python
Line 112: A suggested transformation operation - matching Python dataclass exactly
Line 115: Type of transformation suggested
Line 117: Human-readable description of the transformation
Line 119: List of files that would be affected
Line 121: Confidence level (0.0 to 1.0)
Line 123: Estimated impact description
Line 125: Prerequisites that must be met
Line 127: Additional metadata for the transformation
Line 153: Complexity estimate for transformations
Line 156: Estimated execution time in seconds
Line 158: Number of files that will be modified
Line 160: Number of individual transformations
Line 162: Risk level for the transformation
Line 164: Confidence in the estimate (0.0 to 1.0)
Line 166: Estimated lines of code affected
Line 168: Whether manual review is recommended
Line 172: Risk levels for transformations
Line 175: Safe transformation with minimal risk
Line 177: Moderate risk, should be reviewed
Line 179: High risk, requires careful review
Line 181: Critical risk, expert review required
Line 186: Get display color for UI
Line 196: Get risk description
Line 207: Input data for transformations
Line 210: Source code to transform
Line 212: File path for context
Line 214: Language of the source code
Line 218: Analysis context from CodeHUD
Line 222: Configuration for transformations
Line 225: Whether to perform dry run only
Line 227: Whether to create backup before transformation
Line 229: Custom transformation parameters
Line 231: Target style guide (e.g., "pep8", "google", "microsoft")
Line 233: Maximum complexity allowed after transformation
Line 235: Whether to preserve comments
Line 237: Whether to preserve formatting
Line 255: Analysis context from CodeHUD core
Line 258: Function signatures in the file
Line 260: Class definitions in the file
Line 272: Function information for transformation context
Line 277: Line number where function starts
Line 279: Line number where function ends
Line 283: Return type annotation if available
Line 287: Whether function is used elsewhere
Line 291: Class information for transformation context
Line 296: Line number where class starts
Line 298: Line number where class ends
Line 304: Number of lines of code
Line 308: Issue information for transformation context
Line 311: Issue type (e.g., "magic_number", "unused_variable")
Line 321: Suggested fix if available
Line 325: Result of a transformation operation - matching Python dataclass exactly
Line 328: Type of transformation that was applied
Line 330: Current status of the transformation
Line 332: List of files that were modified
Line 334: Git commit hash for backup
Line 336: Validation results with details
Line 338: Error message if transformation failed
Line 340: Whether rollback is available for this transformation
Line 344: Backup information for rollback
Line 349: Git commit hash if using Git
Line 351: Backup directory path
Line 353: Timestamp of backup
Line 355: Files included in backup
Line 359: Statistics about transformation execution
Line 362: Total lines processed
Line 370: Number of transformations applied
Line 372: Complexity before transformation
Line 374: Complexity after transformation
Line 378: New issues introduced

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5205 characters
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  13% (2/15) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-transform/src/lib.rs
Language: rust
Comments found: 26

STRUCTURAL CONTEXT:
structure: calls TransformError::Language., calls TransformError::Query.
imports: Imports: pub use engine::{TransformationEngine, TransformationHistory};., Imports: pub use transformers::Transformer;., Imports: pub use rollback::{RollbackSystem, GitBackupIntegration};., Imports: pub use types::{TransformationType, TransformationResult, TransformationSuggestion};.
exports: pub use transformers::Transformer;., pub use rollback::{RollbackSystem, GitBackupIntegration};., pub use engine::{TransformationEngine, TransformationHistory};., pub use types::{TransformationType, TransformationResult, TransformationSuggestion};.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Transform - Code Transformation and Refactoring Engine
Line 3: ! This crate provides comprehensive code transformation capabilities, implementing
Line 4: ! all transformation types from the Python codebase with zero degradation.
Line 6: ! Key features:
Line 7: ! - LibCST-equivalent concrete syntax tree transformations
Line 8: ! - Magic number extraction and architectural refactoring
Line 9: ! - Property-based and search-based test generation
Line 10: ! - Git-integrated rollback system
Line 11: ! - Batch transformations with formatting preservation
Line 21: Re-export main types for convenience
Line 27: Result type for transformation operations
Line 30: Error types for transformation operations
Line 33: I/O operation failed
Line 45: Git operation error
Line 49: External tool error
Line 65: CodeHUD core error
Line 73: Tree-sitter language error
Line 77: Tree-sitter query error
Line 81: UTF-8 encoding error

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2066 characters
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (3/15) - engine.rs...🔍 DEBUG PROMPT for engine.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-transform/src/engine.rs
Language: rust
Comments found: 85

STRUCTURAL CONTEXT:
structure: calls GitBackupIntegration::new., calls UnusedArgumentRemover::new., calls TransformError::Transform., calls HashMap::new., calls RollbackSystem::new., calls TransformError::Config., calls EngineConfig::default., calls TransformationEngine::new., calls Box::new., calls HistoryStatistics::default., start_session is a wrapper for Err.TransformError.Config.to_string (lines 153)., calls MagicNumberTransformer::new., calls TestGenerationTransformer::new., rollback_transformation is a wrapper for Err.TransformError.Rollback.to_string (lines 338)., calls Utc::now., find_transformation_record is a wrapper for Some.record (lines 431)., calls BatchTransformer::new., apply_transformations_batch is a wrapper for Err.e (lines 301)., calls MultiLanguageTransformer::new., calls TransformError::Validation., validate_transformation is a wrapper for Err.TransformError.Transform.result.error_message.as_ref.unwrap.clone (lines 448)., calls TransformError::Rollback., calls Uuid::new_v4., apply_transformation is a wrapper for Err.TransformError.Validation.to_string (lines 265)., calls ArchitecturalRefactorer::new.
imports: Imports: use std::collections::HashMap;., Imports: use std::path::{Path, PathBuf};., use super::*;., Imports: use crate::{, Imports: use uuid::Uuid;., use crate::{, Imports: use crate::transformers::{, Imports: use codehud_core::models::AnalysisResult;., Imports: use crate::types::TransformConfig;., Imports: use super::*;., Imports: use serde::{Serialize, Deserialize};., use crate::transformers::{, Imports: use chrono::{DateTime, Utc};., use crate::types::TransformConfig;.

COMMENTS TO ANALYZE:
Line 1: ! Central Transformation Engine
Line 3: ! This module implements the main transformation orchestrator that coordinates
Line 4: ! all transformation types, history tracking, and rollback functionality.
Line 19: Central transformation orchestrator matching Python exactly
Line 21: All available transformers
Line 27: Git integration for backups
Line 33: Configuration for the transformation engine
Line 36: Maximum number of concurrent transformations
Line 38: Whether to create Git backups by default
Line 40: Default timeout for transformations (seconds)
Line 42: Whether to validate transformations after applying
Line 44: Whether to run tests after transformations
Line 46: Directory for storing backups
Line 63: Transformation history tracking
Line 66: All transformation sessions
Line 68: Current session if active
Line 72: A single transformation session
Line 75: Unique session identifier
Line 77: Session start time
Line 79: Session end time
Line 81: Transformations applied in this session
Line 85: Git commit hash for this session
Line 91: Status of a transformation session
Line 94: Session is currently active
Line 96: Session completed successfully
Line 100: Session was rolled back
Line 104: Record of a single transformation
Line 107: Unique transformation identifier
Line 109: Type of transformation
Line 111: Input file path
Line 113: Timestamp of transformation
Line 117: Whether this transformation was rolled back
Line 122: Create a new transformation engine
Line 135: Register all default transformers
Line 141: Register a transformer for a specific type
Line 150: Start a new transformation session
Line 171: Create Git backup if enabled
Line 182: End the current transformation session
Line 198: Analyze codebase and get transformation opportunities
Line 219: Apply a transformation suggestion
Line 225: Ensure we have an active session
Line 230: Get the appropriate transformer
Line 236: Create backup if enabled
Line 253: Add backup commit to result
Line 258: Validate result if enabled
Line 269: Record transformation in history
Line 287: Apply multiple transformation suggestions in batch
Line 299: On error, rollback all successful transformations in this batch
Line 309: Rollback the current session
Line 312: Mark all transformations as rolled back
Line 326: Rollback a specific transformation
Line 328: Find the transformation record
Line 334: Use backup commit to restore
Line 346: Get transformation history
Line 351: Get current session
Line 356: Check if a transformer is available
Line 361: Get list of available transformation types
Line 366: Register all default transformers - matching Python exactly
Line 368: Import and register transformers exactly as Python does
Line 378: Magic Number Extractor -> MAGIC_NUMBERS
Line 384: Architectural Refactorer -> ARCHITECTURAL_REFACTOR
Line 390: Batch Transformer (includes Bowler-based large-scale refactoring) -> BATCH_TRANSFORM
Line 396: Multi-Language Transformer -> MULTI_LANGUAGE
Line 402: Test Generator -> TEST_GENERATION
Line 408: Code Cleanup (unused arguments, imports, etc.) -> CODE_CLEANUP
Line 417: Find transformation record by ID
Line 419: Search in current session
Line 427: Search in completed sessions
Line 438: Validate transformation result
Line 440: Basic validation - check status
Line 456: Run post-transformation tests
Line 458: TODO: Implement test execution
Line 459: This would run relevant tests after transformation to ensure nothing broke
Line 465: Get statistics about transformation history
Line 493: Update transformation type counts
Line 504: Statistics about transformation history

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5725 characters
🤖 Analyzing: [█████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  26% (4/15) - rollback.rs...🔍 DEBUG PROMPT for rollback.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-transform/src/rollback.rs
Language: rust
Comments found: 78

STRUCTURAL CONTEXT:
imports: Imports: use crate::{Result, TransformError};., Imports: use std::collections::HashMap;., Imports: use std::path::{Path, PathBuf};., Imports: use uuid::Uuid;., Imports: use chrono::{DateTime, Utc};., use crate::{Result, TransformError};., Imports: use serde::{Serialize, Deserialize};., Imports: use super::*;., use super::*;., Imports: use std::process::{Command, Stdio};., Imports: use tempfile::TempDir;., Imports: use std::fs;.
structure: calls TransformError::Config., calls Default::default., calls HashMap::new., calls chrono::Duration::days., calls Utc::now., restore_to_commit is a wrapper for Err.TransformError.Git.format.String.from_utf8_lossy.reset_output.stderr (lines 397)., calls Self::check_git_availability., calls RollbackSystem::new., restore_from_backup is a wrapper for Err.TransformError.Rollback.format.backup_file (lines 209)., calls TransformError::Git., calls GitBackupConfig::default., calls GitBackupIntegration::check_git_availability., calls PathBuf::from., calls TransformError::Io., calls fs::metadata., calls fs::copy., calls Command::new., calls Stdio::null., calls fs::remove_dir_all., calls fs::write., create_session_backup is a wrapper for Err.TransformError.Git.to_string (lines 357)., get_repo_status is a wrapper for Ok.is_clean.current_branch.None.uncommitted_changes.untracked_files (lines 432)., calls Path::new., check_git_availability is a wrapper for Ok (lines 415)., create_backup is a wrapper for Err.TransformError.Io.std.io.Error.new.std.io.ErrorKind.NotFound.format.file_path (lines 145)., calls fs::create_dir_all., calls crate::engine::EngineConfig::default., calls Uuid::new_v4., calls TransformError::Rollback., calls TempDir::new.
file_i/o: this scope performs file I/O via fs::write(&test_file, (lines 525).

COMMENTS TO ANALYZE:
Line 1: ! Rollback System with Git Integration
Line 3: ! This module provides comprehensive rollback functionality with Git backup
Line 4: ! integration, matching Python's behavior exactly for zero degradation.
Line 15: Rollback system managing backups and restoration
Line 18: Configuration for rollback system
Line 20: Active backups by ID
Line 22: Backup storage directory
Line 26: Configuration for rollback system
Line 29: Maximum number of backups to keep
Line 31: Whether to use Git for backups
Line 33: Backup directory path
Line 35: Whether to compress backups
Line 37: Retention policy in days
Line 53: Entry for a single backup
Line 56: Unique backup identifier
Line 58: Files included in backup
Line 60: Timestamp when backup was created
Line 62: Git commit hash if using Git
Line 64: Backup directory path
Line 66: Description of what was backed up
Line 68: Size of backup in bytes
Line 72: Git backup integration system
Line 75: Git repository path
Line 77: Whether Git is available
Line 83: Configuration for Git backup integration
Line 86: Whether to auto-commit backups
Line 88: Branch prefix for backup branches
Line 90: Whether to create tags for backups
Line 92: Tag prefix for backup tags
Line 108: Create new rollback system
Line 126: Create backup directory if it doesn't exist
Line 138: Create a backup of the specified file
Line 151: Create backup subdirectory
Line 155: Copy file to backup location
Line 163: Calculate file size
Line 166: Create backup entry
Line 179: Create backup info for return
Line 188: Clean old backups if needed
Line 194: Restore from backup
Line 201: Restore each file
Line 214: Create parent directories if needed
Line 226: List all available backups
Line 233: Remove a specific backup
Line 236: Remove backup directory
Line 244: Clean up old backups based on retention policy
Line 249: Find backups to remove
Line 257: Also enforce max backup limit
Line 268: Remove old backups
Line 276: Get backup statistics
Line 300: Create new Git backup integration
Line 312: Create a session backup using Git
Line 318: Create commit for current state
Line 321: Add all changes
Line 349: Get commit hash
Line 364: Create tag if enabled
Line 374: Tag creation failure is not critical
Line 382: Restore to a specific Git commit
Line 388: Reset to specified commit
Line 405: Check if Git is available and repo is initialized
Line 407: Check if git command is available
Line 418: Check if current directory is a git repository
Line 429: Get Git repository status
Line 440: Get current branch
Line 483: Backup system statistics
Line 486: Total number of backups
Line 488: Total size of all backups in bytes
Line 490: Timestamp of oldest backup
Line 492: Timestamp of newest backup
Line 496: Git repository status
Line 499: Whether the repository is clean (no uncommitted changes)
Line 501: Current branch name
Line 503: Number of uncommitted changes
Line 505: Number of untracked files
Line 541: This will return false since temp directory is not a git repo

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 5284 characters
🤖 Analyzing: [████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  33% (5/15) - libcst.rs...🔍 DEBUG PROMPT for libcst.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-transform/src/libcst.rs
Language: rust
Comments found: 64

STRUCTURAL CONTEXT:
imports: Imports: use crate::{Result, TransformError};., use super::*;., Imports: use std::collections::HashMap;., Imports: use tree_sitter::{Node, Parser, Tree, TreeCursor};., use crate::{Result, TransformError};., Imports: use rowan::{ast::AstNode, GreenNode, GreenNodeBuilder, Language, NodeOrToken, SyntaxNode, TextRange, TextSize};., Imports: use super::*;.
structure: calls CstSyntaxKind::from_raw., calls FormattingConfig::default., calls rowan::SyntaxKind., calls TextSize::from., calls tree_sitter_python::language., calls CstSyntaxNode::new_root., calls HashMap::new., calls tree_sitter_java::language., new is a wrapper for Err.TransformError.Config.format.language (lines 231)., calls GreenNodeBuilder::new., calls tree_sitter_typescript::language_typescript., calls Parser::new., calls LibCstTransformer::new., calls TransformError::Config., calls tree_sitter_rust::language., calls TransformError::Parse., calls TextRange::new., calls tree_sitter_javascript::language.

COMMENTS TO ANALYZE:
Line 1: ! LibCST-equivalent Concrete Syntax Tree Implementation
Line 3: ! This module provides concrete syntax tree transformations preserving
Line 4: ! formatting and comments exactly like Python LibCST
Line 11: Language definition for our CST
Line 27: Syntax kinds for our CST
Line 129: Type aliases for our CST
Line 133: CST Node wrapper preserving all metadata
Line 136: Underlying syntax node
Line 138: Original source text
Line 140: Metadata about formatting and comments
Line 144: Metadata preserved with each node
Line 151: Original text range
Line 153: Whether this node was modified
Line 157: Trivia (whitespace, comments, etc.)
Line 171: LibCST-equivalent transformer for concrete syntax trees
Line 173: Parser for the target language
Line 181: Parser that preserves all formatting information
Line 187: Code formatter that preserves original formatting
Line 214: Comment preservation system
Line 220: Create new LibCST transformer
Line 224: Set language based on input
Line 252: Parse source with metadata preservation (matching Python LibCST behavior)
Line 254: Parse with tree-sitter
Line 258: Extract comments and whitespace
Line 261: Build CST with metadata
Line 267: Transform preserving formatting (matching Python LibCST behavior)
Line 273: Apply transformation while preserving metadata
Line 279: Generate code from CST (matching Python LibCST behavior)
Line 286: Extract trivia (comments, whitespace) from source
Line 293: Recursively extract trivia
Line 297: Check if this is a comment or whitespace
Line 324: Associate trivia with nearby nodes
Line 331: Recurse to children
Line 345: Check if node represents trivia
Line 350: Build CST with preserved metadata
Line 354: Convert tree-sitter tree to rowan green tree
Line 375: Convert tree-sitter node to rowan node
Line 385: Leaf node - add as token
Line 389: Internal node - add children
Line 408: Map tree-sitter node kind to our CST kind
Line 447: Generate code recursively
Line 454: Add leading trivia
Line 459: Process node content
Line 463: Recursively process child nodes
Line 473: Add token text
Line 479: Add trailing trivia
Line 488: Trait for CST transformations
Line 490: Visit and potentially modify a CST node
Line 494: Example transformation that preserves formatting
Line 499: Mark as modified but don't change structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3803 characters
📦 Processing batch 2/3 (5 files)...
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (6/15) - test_generation.rs...🔍 DEBUG PROMPT for test_generation.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/test_generation.rs
Language: rust
Comments found: 36

STRUCTURAL CONTEXT:
structure: calls TestGenerationConfig::default., calls HashMap::new.
file_i/o: this scope performs file I/O via validation_results.insert("test_files_readable".to_string(), (lines 288)., this scope performs file I/O via std::fs::read_to_string(&full_path).is_err() (lines 281)., this scope performs file I/O via std::fs::read_to_string(&full_path) (lines 223, 281)., this scope performs file I/O via "test_files_readable".to_string() (lines 288)., this scope performs file I/O via std::fs::write(&test_file_path, (lines 237).
imports: Imports: use crate::{, use crate::{, Imports: use async_trait::async_trait;., Imports: use codehud_core::models::AnalysisResult;., Imports: use serde::{Serialize, Deserialize};., Imports: use std::collections::HashMap;.

COMMENTS TO ANALYZE:
Line 1: ! Test Generation Transformer
Line 3: ! This module implements automatic test generation using property-based testing
Line 4: ! and search-based test generation techniques, matching Python TestGenerator.
Line 16: Configuration for test generation
Line 19: Maximum number of tests to generate per function
Line 21: Whether to generate property-based tests
Line 23: Whether to generate unit tests
Line 25: Test framework to use
Line 40: Generated test information
Line 47: Test type (unit, property, integration)
Line 49: Function being tested
Line 51: Test file path
Line 55: Test generation transformer matching Python TestGenerator
Line 63: Create new test generation transformer
Line 70: Create with custom configuration
Line 75: Detect functions that need tests
Line 108: Generate test for a specific function
Line 140: Detect language from file path
Line 154: Analyze code and suggest test generation opportunities
Line 161: Look for functions that lack test coverage
Line 169: Skip test files
Line 185: Create suggestion if we found functions needing tests
Line 211: Apply test generation transformation
Line 220: Generate tests for each affected file
Line 231: Create tests directory if it doesn't exist
Line 236: Write test file
Line 248: New test files created
Line 261: Validate test generation transformation
Line 265: Validate transformation status
Line 269: Check if test files were created and are accessible
Line 280: Try to read the test file
Line 291: Overall validation success

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3968 characters
🤖 Analyzing: [███████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░]  46% (7/15) - multi_language.rs...🔍 DEBUG PROMPT for multi_language.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/multi_language.rs
Language: rust
Comments found: 40

STRUCTURAL CONTEXT:
imports: Imports: use crate::{, Imports: use codehud_core::models::AnalysisResult;., Imports: use async_trait::async_trait;., Imports: use regex::Regex;., use crate::{, Imports: use std::collections::HashMap;., Imports: use serde::{Serialize, Deserialize};.
structure: calls Self::create_default_patterns., calls HashMap::new., calls MultiLanguageConfig::default., detect_language is a wrapper for to_string (lines 115).
file_i/o: this scope performs file I/O via std::fs::write(&full_path, (lines 229)., this scope performs file I/O via validation_results.insert("files_readable".to_string(), (lines 277)., this scope performs file I/O via std::fs::read_to_string(&full_path) (lines 224, 270)., this scope performs file I/O via std::fs::read_to_string(&full_path).is_err() (lines 270)., this scope performs file I/O via "files_readable".to_string() (lines 277).

COMMENTS TO ANALYZE:
Line 1: ! Multi-Language Transformer
Line 3: ! This module implements cross-language transformations using Comby-style
Line 4: ! pattern matching and replacement, enabling transformations across different
Line 5: ! programming languages with consistent patterns.
Line 18: Multi-language transformation pattern
Line 23: Comby-style pattern string
Line 25: Example before transformation
Line 27: Example after transformation
Line 29: Languages this pattern supports
Line 31: Confidence in this pattern (0.0 to 1.0)
Line 35: Configuration for multi-language transformations
Line 38: Whether to preserve formatting
Line 40: Maximum number of replacements per file
Line 42: Whether to apply language-specific rules
Line 56: Multi-language transformer for cross-language transformations
Line 66: Create new multi-language transformer
Line 74: Create with custom patterns
Line 82: Create default transformation patterns
Line 104: Detect language from source code and file path
Line 107: Detect by file extension
Line 119: Detect by code patterns
Line 131: Apply a language-specific pattern to source code
Line 135: Simple TODO enhancement
Line 140: Basic naming convention adjustments - would be more sophisticated in real implementation
Line 141: No change for now
Line 150: Analyze code for multi-language transformation opportunities
Line 157: Look for cross-language patterns and opportunities
Line 168: Look for cross-language transformation opportunities
Line 173: Look for naming convention patterns
Line 181: Create suggestions for patterns found across languages
Line 183: Only suggest if found in multiple files
Line 209: Apply multi-language transformation
Line 221: Apply transformation to affected files
Line 251: Validate multi-language transformation
Line 255: Validate transformation status
Line 259: Validate files were actually modified
Line 280: Overall validation success

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4457 characters
🤖 Analyzing: [██████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░]  53% (8/15) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/mod.rs
Language: rust
Comments found: 19

STRUCTURAL CONTEXT:
exports: pub use magic_numbers::MagicNumberTransformer;., pub use architectural::ArchitecturalRefactorer;., pub use test_generation::TestGenerationTransformer;., pub use batch::BatchTransformer;., pub use unused_args::UnusedArgumentRemover;., pub use multi_language::MultiLanguageTransformer;.
imports: Imports: pub use multi_language::MultiLanguageTransformer;., Imports: pub use batch::BatchTransformer;., use crate::{, Imports: pub use unused_args::UnusedArgumentRemover;., Imports: use crate::{, Imports: use codehud_core::models::AnalysisResult;., Imports: use std::collections::HashMap;., Imports: pub use architectural::ArchitecturalRefactorer;., Imports: pub use test_generation::TestGenerationTransformer;., Imports: use crate::engine::EngineConfig;., use crate::engine::EngineConfig;., Imports: pub use magic_numbers::MagicNumberTransformer;., Imports: use async_trait::async_trait;., Imports: use crate::rollback::GitBackupIntegration;., use crate::rollback::GitBackupIntegration;.
structure: calls EngineConfig::default., calls GitBackupIntegration::new.

COMMENTS TO ANALYZE:
Line 1: ! Transformer implementations
Line 3: ! This module contains all transformer implementations matching Python behavior
Line 20: Re-export all transformers - matching Python exactly
Line 28: Base transformer trait - matching Python BaseTransformer ABC exactly
Line 29: Only abstract methods are required; concrete methods are provided as default implementations
Line 32: Analyze code and suggest transformation opportunities
Line 33: Matches Python: analyze_transformation_opportunities(self, analysis_result: AnalysisResult) -> list[TransformationSuggestion]
Line 39: Apply a specific transformation
Line 40: Matches Python: apply_transformation(self, suggestion: TransformationSuggestion, codebase_path: Path) -> TransformationResult
Line 47: Validate that transformation was successful
Line 48: Matches Python: validate_transformation(self, result: TransformationResult, codebase_path: Path) -> dict[str, Any]
Line 55: Concrete methods with default implementations (matching Python BaseTransformer)
Line 57: Create a git commit backup before transformation
Line 58: Matches Python: create_backup(self, codebase_path: Path) -> Optional[str]
Line 60: Default implementation - delegates to GitBackupIntegration
Line 67: Create backup using session ID similar to Python
Line 75: Rollback transformation using git
Line 76: Matches Python: rollback_transformation(self, backup_commit: str, codebase_path: Path) -> bool
Line 82: Default implementation - delegates to GitBackupIntegration

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4255 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  60% (9/15) - magic_numbers.rs...🔍 DEBUG PROMPT for magic_numbers.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/magic_numbers.rs
Language: rust
Comments found: 114

STRUCTURAL CONTEXT:
imports: Imports: use async_trait::async_trait;., Imports: use regex::Regex;., use crate::{, Imports: use crate::{, use super::*;., Imports: use crate::types::TransformConfig;., use crate::types::TransformConfig;., Imports: use codehud_core::models::AnalysisResult;., Imports: use std::collections::HashMap;., Imports: use serde_json::json;., Imports: use std::collections::{HashMap, HashSet};., Imports: use super::*;.
structure: calls value.parse::<f64>., calls MagicNumberContext::new., calls HashMap::new., calls TransformConfig::default., calls tokio::runtime::Runtime::new., calls HashSet::new., calls Regex::new., calls value.parse::<i64>., calls MagicNumberTransformer::new., calls LibCstTransformer::new., calls MagicNumberConfig::default.
file_i/o: this scope performs file I/O via std::fs::write(codebase_path, (lines 671)., this scope performs file I/O via std::fs::read_to_string(codebase_path) (lines 657).

COMMENTS TO ANALYZE:
Line 1: ! Magic Number Transformer
Line 3: ! Extracts magic numbers to named constants, matching Python behavior exactly
Line 18: Represents the context around a magic number for intelligent extraction
Line 19: Matches Python MagicNumberContext exactly
Line 22: The numeric value found
Line 24: Line number where found (1-based)
Line 26: Column number where found (1-based)
Line 28: Surrounding code context
Line 30: AI-suggested constant name
Line 32: Suggested grouping class for organization
Line 34: Confidence in the suggestion (0.0 to 1.0)
Line 39: Create new context for a magic number
Line 52: Analyze surrounding code to determine appropriate constant name
Line 53: Matches Python analyze_context method exactly
Line 57: God Class pattern detection
Line 61: Health score pattern detection
Line 65: Complexity pattern detection
Line 69: HTTP status code detection
Line 73: Threshold pattern detection
Line 77: Configuration pattern detection
Line 81: Default pattern analysis
Line 87: Analyze God Class specific patterns
Line 100: Analyze health score patterns
Line 113: Analyze complexity patterns
Line 126: Analyze HTTP status codes
Line 148: Analyze threshold patterns
Line 161: Analyze configuration patterns
Line 168: Generic context analysis fallback
Line 170: Generate a reasonable constant name based on the number
Line 181: Magic number transformer - extracts magic numbers to constants
Line 183: CST transformer for preserving formatting
Line 185: Configuration for magic number detection
Line 189: Configuration for magic number detection
Line 192: Numbers to ignore (common constants)
Line 194: Minimum value to consider as magic number
Line 196: Maximum value to consider as magic number
Line 198: Whether to extract floating point numbers
Line 200: Whether to extract numbers in strings
Line 202: Prefix for generated constant names
Line 204: Where to place constants (top of file, separate constants file)
Line 208: Strategy for placing extracted constants
Line 211: At the top of the same file
Line 213: In a separate constants file
Line 215: Near first usage
Line 222: Common numbers that are usually not magic
Line 239: Information about a detected magic number
Line 242: The numeric value
Line 244: Line number where it appears
Line 248: Context around the number
Line 250: Suggested constant name
Line 252: How many times this number appears
Line 257: Create new magic number transformer
Line 265: Create with custom configuration
Line 273: Find all magic numbers in the source code
Line 278: Regex patterns for different number types
Line 289: Find integer literals
Line 299: Find float literals if enabled
Line 311: Find hex literals
Line 319: Find binary literals
Line 327: Process numbers found in this line
Line 340: Will be updated later
Line 345: Update usage counts
Line 353: Check if a number should be extracted as a magic number
Line 355: Skip ignored numbers
Line 360: Parse the number to check range
Line 380: Generate a constant name for a magic number
Line 382: Try to infer meaning from context
Line 415: Extract context around a magic number
Line 421: Clean up the context
Line 425: Generate the replacement code with constants
Line 433: Generate constants section
Line 438: Add constants at the top after imports
Line 442: Find end of import statements
Line 470: Add rest of the code with replacements
Line 481: Just replace magic numbers with constant references
Line 490: Place constants near their first usage
Line 495: Check if any magic numbers appear in this line for the first time
Line 499: Add constant definition before this line
Line 506: Add the line with replacements
Line 517: Generate constants section
Line 524: Group by value to avoid duplicates
Line 541: Replace magic numbers in a single line with constant references
Line 545: Sort by column position (descending) to avoid position shifts
Line 548: Check if this magic number appears in this line
Line 555: Group by value to get the suggested name
Line 561: Replace each unique value
Line 563: Use word boundaries to avoid partial replacements
Line 573: Extract magic numbers from analysis result
Line 577: For now, create a simple implementation
Line 578: In a real implementation, this would parse the analysis result
Line 579: and extract actual magic numbers from the code
Line 581: This is a placeholder that would be replaced with actual analysis
Line 594: Apply magic number extraction to source code
Line 596: Simple regex-based replacement for now
Line 597: In a real implementation, this would use LibCST for precise transformation
Line 613: Analyze code and suggest magic number extraction opportunities
Line 620: Extract magic numbers from analysis result
Line 650: Apply magic number extraction transformation
Line 656: Read the source file
Line 659: Extract transformation parameters from metadata
Line 667: Apply the transformation
Line 670: Write transformed code back
Line 677: Will be set by engine
Line 684: Validate that transformation was successful
Line 685: Returns detailed validation results as dict[str, Any] matching Python
Line 696: Basic validation - check if transformation completed successfully
Line 705: Validate files were actually modified if claimed
Line 743: Should find: 100, 50, 0.15, 0.05, 25
Line 744: Should NOT find: 1 (ignored)

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 7918 characters
🤖 Analyzing: [█████████████████████████████████░░░░░░░░░░░░░░░░░]  66% (10/15) - unused_args.rs...🔍 DEBUG PROMPT for unused_args.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/unused_args.rs
Language: rust
Comments found: 42

STRUCTURAL CONTEXT:
structure: calls HashMap::new., calls CodeCleanupConfig::default.
file_i/o: this scope performs file I/O via std::fs::write(&full_path, (lines 288)., this scope performs file I/O via "files_readable".to_string() (lines 346)., this scope performs file I/O via validation_results.insert("files_readable".to_string(), (lines 346)., this scope performs file I/O via std::fs::read_to_string(&full_path) (lines 280, 334).
imports: Imports: use crate::{, Imports: use codehud_core::models::AnalysisResult;., Imports: use regex::Regex;., Imports: use async_trait::async_trait;., Imports: use std::collections::{HashMap, HashSet};., use crate::{

COMMENTS TO ANALYZE:
Line 1: ! Unused Argument Remover Transformer
Line 3: ! This module implements dead code elimination, focusing on unused function
Line 4: ! arguments, imports, and variables, matching Python UnusedArgumentRemover.
Line 16: Configuration for unused code removal
Line 19: Remove unused function arguments
Line 21: Remove unused imports
Line 23: Remove unused variables
Line 25: Preserve public API elements
Line 40: Information about detected unused code
Line 43: Name of the unused item
Line 45: Type of unused item (argument, import, variable)
Line 47: Line number where it appears
Line 49: Function/scope containing the item
Line 53: Unused argument remover transformer matching Python UnusedArgumentRemover
Line 61: Create new unused argument remover
Line 68: Create with custom configuration
Line 73: Detect unused arguments in source code
Line 90: Find unused arguments in Python code
Line 96: Extract function definition
Line 105: Check if arguments are used in function body
Line 124: Find unused arguments in Rust code
Line 130: Extract function definition
Line 139: Check if arguments are used in function body
Line 158: Check if an argument is used in the function body
Line 171: End of function
Line 175: Simple check if argument name appears in line
Line 184: Remove unused arguments from source code
Line 188: Simple removal - in real implementation would use proper AST manipulation
Line 191: Simple pattern-based removal (would be more sophisticated in real implementation)
Line 203: Detect language from file path
Line 217: Analyze code and suggest unused code removal opportunities
Line 224: Look for unused code elements
Line 243: Create suggestion if we found unused code
Line 269: Apply unused code removal transformation
Line 277: Remove unused code from each affected file
Line 313: Validate unused code removal transformation
Line 317: Validate transformation status
Line 321: Basic validation - check that modified files are syntactically valid
Line 333: Try to read the modified file
Line 350: Overall validation success

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4388 characters
📦 Processing batch 3/3 (5 files)...
🤖 Analyzing: [████████████████████████████████████░░░░░░░░░░░░░░]  73% (11/15) - multi_language_old.rs...🔍 DEBUG PROMPT for multi_language_old.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio
- test_generation.rs: This file, test_generation.rs, implements a comprehensive suite of automated test generation functionalities using both property-based testing and search-based techniques similar to those used in Pyth
- multi_language.rs: The file ./codehud-transform/src/transformers/multi_language.rs in the CodeHUD project implements multi-language transformations using Comby-style pattern matching and replacement, enabling transforma
- mod.rs: This file, `mod.rs` in the codehud-transform/src/transformers directory, provides implementations for different transformations related to codebase transformation and refactoring. These transformation
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a magic number transformer for code analysis and transformation in Rust. It specifically extracts "magic numbers" to named constants in the source code for be
- unused_args.rs: This file (./codehud-transform/src/transformers/unused_args.rs) is a Rust implementation of a transformer that focuses on eliminating unused code elements, such as function arguments, imports, and var

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/multi_language_old.rs
Language: rust
Comments found: 120

STRUCTURAL CONTEXT:
structure: calls HashMap::new., validate_syntax is a wrapper for Err.TransformError.Transform.format.error_msg (lines 413)., find_pattern is a wrapper for Some.pattern (lines 512)., calls PatternLibrary::new., apply_default_transformations is a wrapper for Ok.applied.matches_found.replacements_made.transformed_code.source_code.to_string.warnings.vec.format.language.errors.vec (lines 682)., calls MultiLanguageConfig::default., calls LanguageDetector::new., detect is a wrapper for language.clone (lines 566)., calls TransformError::Config., calls Regex::new., calls regex::escape., calls IndentStyle::Spaces., calls TransformError::Transform., calls MultiLanguageTransformer::new., calls Command::new.
imports: Imports: use crate::{, Imports: use std::collections::HashMap;., Imports: use super::*;., Imports: use codehud_core::models::AnalysisResult;., Imports: use serde::{Serialize, Deserialize};., Imports: use std::process::{Command, Stdio};., use super::*;., Imports: use regex::Regex;., Imports: use async_trait::async_trait;., use crate::{
file_i/o: this scope performs file I/O via std::fs::write(&temp_file, (lines 395)., this scope performs file I/O via std::fs::write(&input_file, (lines 271)., this scope performs file I/O via std::fs::write(&pattern_file, (lines 272).

COMMENTS TO ANALYZE:
Line 1: ! Multi-Language Transformer
Line 3: ! This module implements cross-language transformations using Comby-style
Line 4: ! pattern matching and replacement, enabling transformations across different
Line 5: ! programming languages with consistent patterns.
Line 19: Multi-language transformer using Comby-style patterns
Line 21: Configuration for multi-language transformations
Line 23: Pattern library for different languages
Line 25: Language detection engine
Line 29: Configuration for multi-language transformations
Line 32: Whether to use external Comby tool
Line 34: Path to Comby executable
Line 36: Maximum file size to process
Line 38: Whether to validate syntax after transformation
Line 40: Whether to preserve formatting
Line 69: Default to internal implementation
Line 84: Line ending style
Line 86: Maximum line length
Line 88: Whether to preserve comments
Line 90: Command to check syntax
Line 97: Spaces with specified count
Line 103: Line ending style
Line 106: Unix style (\n)
Line 108: Windows style (\r\n)
Line 110: Mac style (\r)
Line 114: Pattern library for cross-language transformations
Line 117: Patterns organized by category
Line 121: Cross-language transformation pattern
Line 126: Description of what this pattern does
Line 128: Languages this pattern applies to
Line 130: Source pattern to match
Line 134: Pattern type (structural, syntactic, semantic)
Line 136: Examples of transformations
Line 138: Constraints for when pattern should apply
Line 142: Type of transformation pattern
Line 145: Structural code patterns (loops, conditionals)
Line 147: Syntactic patterns (naming, formatting)
Line 149: Semantic patterns (logic, algorithms)
Line 151: Cross-language migration patterns
Line 155: Example of pattern transformation
Line 158: Example input code
Line 160: Expected output code
Line 162: Language for this example
Line 166: Constraint for pattern application
Line 169: Only apply in specific contexts
Line 171: Only apply if certain conditions are met
Line 173: Only apply to specific language versions
Line 175: Only apply if dependencies are present
Line 179: Language detection engine
Line 182: File extension mappings
Line 184: Content-based detection patterns
Line 188: Result of applying a pattern
Line 191: Whether pattern was applied successfully
Line 193: Number of matches found
Line 195: Number of replacements made
Line 206: Create new multi-language transformer
Line 215: Create with custom configuration
Line 224: Apply cross-language transformation
Line 232: Find appropriate pattern
Line 243: Apply a specific pattern to code
Line 257: Apply pattern using external Comby tool
Line 266: Create temporary files for input and pattern
Line 283: Clean up temporary files
Line 312: Apply pattern using internal implementation
Line 319: Convert Comby-style pattern to regex
Line 332: Process replacement pattern with captured groups
Line 335: Replace captured variables (:[var] -> $var)
Line 347: Validate result if configured
Line 364: Convert Comby-style pattern to regex
Line 368: Replace Comby holes with regex groups
Line 369: :[var] -> (.+?) for any identifier
Line 370: :[var:e] -> (.+?) for expressions
Line 371: :[var:s] -> (.+?) for statements
Line 375: Escape special regex characters except our groups
Line 382: Count pattern matches in source code
Line 389: Validate syntax of transformed code
Line 393: Create temporary file
Line 397: Run syntax checker
Line 421: Detect language of source code
Line 426: List available patterns
Line 431: Add custom pattern
Line 438: Create new pattern library with default patterns
Line 448: Load default transformation patterns
Line 450: Add common cross-language patterns
Line 491: Add a pattern to the library
Line 505: Find pattern by name and languages
Line 519: List all patterns
Line 528: Create new language detector
Line 550: Detect language from source code and file path
Line 552: Try file extension first
Line 563: Fall back to content-based detection
Line 576: Analyze code for multi-language transformation opportunities
Line 581: Detect source language if not specified
Line 588: Get transformation parameters
Line 599: Apply default transformations for the language
Line 602: Apply specific pattern
Line 643: Will be set by engine
Line 657: 0.02 seconds per line
Line 663: Cross-language transformations have moderate risk
Line 665: Estimate 20% of lines affected
Line 666: Cross-language changes should be reviewed
Line 672: Apply default transformations for a language
Line 674: Find applicable patterns for this language
Line 692: Apply first applicable pattern as default

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8692 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (12/15) - batch.rs...🔍 DEBUG PROMPT for batch.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio
- test_generation.rs: This file, test_generation.rs, implements a comprehensive suite of automated test generation functionalities using both property-based testing and search-based techniques similar to those used in Pyth
- multi_language.rs: The file ./codehud-transform/src/transformers/multi_language.rs in the CodeHUD project implements multi-language transformations using Comby-style pattern matching and replacement, enabling transforma
- mod.rs: This file, `mod.rs` in the codehud-transform/src/transformers directory, provides implementations for different transformations related to codebase transformation and refactoring. These transformation
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a magic number transformer for code analysis and transformation in Rust. It specifically extracts "magic numbers" to named constants in the source code for be
- unused_args.rs: This file (./codehud-transform/src/transformers/unused_args.rs) is a Rust implementation of a transformer that focuses on eliminating unused code elements, such as function arguments, imports, and var

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/batch.rs
Language: rust
Comments found: 131

STRUCTURAL CONTEXT:
structure: scan_directory is a wrapper for Err.TransformError.Config.format.directory.display (lines 454)., calls BatchConfig::default., calls crate::types::TransformConfig::default., calls uuid::Uuid::new_v4., calls TransformError::Config., calls BatchTransformer::new., calls HashMap::new., calls BatchStatistics::default., calls regex::Regex::new., calls chrono::Utc::now.
file_i/o: this scope performs file I/O via std::fs::read_dir(dir) (lines 464)., this scope performs file I/O via std::fs::read_to_string(&file.path) (lines 275)., this scope performs file I/O via inaccessible_files.push(format!("Cannot (lines 742)., this scope performs file I/O via std::fs::read_to_string(&full_path) (lines 681, 740)., this scope performs file I/O via std::fs::write(&full_path, (lines 686)., this scope performs file I/O via std::fs::write(&file.path, (lines 350)., this scope performs file I/O via std::fs::read_to_string(&full_path).is_err() (lines 740).
imports: Imports: use async_trait::async_trait;., Imports: use serde_json::Value;., use crate::{, Imports: use std::collections::HashMap;., Imports: use std::path::{Path, PathBuf};., Imports: use serde_json::json;., Imports: use codehud_core::models::AnalysisResult;., Imports: use super::*;., Imports: use crate::{, use super::*;.

COMMENTS TO ANALYZE:
Line 1: ! Batch Transformer
Line 3: ! This module implements batch transformation capabilities for processing
Line 4: ! multiple files with consistent formatting and style preservation.
Line 17: Batch transformer for processing multiple files
Line 19: Configuration for batch processing
Line 21: Statistics from batch operations
Line 25: Configuration for batch transformations
Line 28: Maximum number of files to process concurrently
Line 30: Whether to stop on first error
Line 32: Whether to create backup of all files before processing
Line 34: Whether to validate all files after transformation
Line 36: Maximum file size to process (in bytes)
Line 38: File patterns to include
Line 40: File patterns to exclude
Line 42: Whether to preserve directory structure
Line 61: Statistics for batch operations
Line 64: Total files processed
Line 66: Files successfully transformed
Line 68: Files that failed transformation
Line 70: Files skipped due to filters
Line 72: Total processing time in milliseconds
Line 74: Average time per file in milliseconds
Line 76: Total lines processed
Line 78: Total lines modified
Line 86: Batch processing error
Line 89: File path where error occurred
Line 95: Line number if applicable
Line 99: Batch operation specification
Line 102: Files to process
Line 104: Transformations to apply
Line 106: Configuration for this batch
Line 110: File in a batch operation
Line 113: Path to the file
Line 115: Language of the file (detected or specified)
Line 117: File size in bytes
Line 119: Last modified timestamp
Line 121: Whether this file should be processed
Line 123: Reason for skipping if not processed
Line 127: Transformation to apply in batch
Line 130: Type of transformation
Line 132: Parameters for this transformation
Line 134: Whether this transformation should be applied to all files
Line 136: File patterns this transformation applies to
Line 140: Result of batch processing
Line 143: Overall success status
Line 145: Results for individual files
Line 149: Files that were created during batch processing
Line 151: Files that were modified
Line 157: Backup information for batch operations
Line 164: Files included in backup
Line 166: Timestamp of backup
Line 171: Create new batch transformer
Line 179: Create with custom configuration
Line 187: Process a batch of files (DEPRECATED - not part of Python-matching interface)
Line 197: Create backup if configured
Line 220: Update overall statistics
Line 224: Track created and modified files
Line 246: Calculate timing statistics
Line 267: Process a single file with specified transformations (DEPRECATED)
Line 274: Read file content
Line 277: Create transform input
Line 286: Apply each transformation sequentially
Line 311: Check if transformation applies to this file
Line 316: Apply transformation parameters
Line 319: Get appropriate transformer and apply
Line 335: Merge file lists
Line 347: Write transformed content back to file if not dry run
Line 358: Check if transformation applies to a file
Line 364: Check file patterns
Line 374: Check if file path matches a pattern
Line 376: Simplified pattern matching - in a real implementation would use glob crate
Line 387: Apply a transformation to input (DEPRECATED)
Line 394: This would delegate to the appropriate transformer based on transformation type
Line 395: For now, return a placeholder result
Line 412: Create backup for batch operation
Line 418: Create backup directory
Line 430: Create parent directories if needed
Line 435: Copy file to backup location
Line 449: Scan directory for files to process
Line 462: Recursively scan directory
Line 479: Analyze a file to determine if it should be processed
Line 485: Detect language from file extension
Line 488: Check if file should be processed
Line 501: Detect programming language from file extension
Line 521: Check if file should be processed
Line 523: Check file size
Line 528: Check language support
Line 533: Check include patterns
Line 541: Check exclude patterns
Line 551: Get processing statistics
Line 561: Apply a specific pattern transformation to source code
Line 563: Simple pattern-based transformations
Line 564: In a real implementation, this would use more sophisticated AST manipulation
Line 567: Example: improve format! usage consistency
Line 572: Example: organize use statements (very basic)
Line 573: No change for now - would need proper parsing
Line 576: Example: suggest alternatives to unwrap() (very basic)
Line 581: Unknown pattern - return unchanged
Line 590: Analyze code and suggest batch transformation opportunities
Line 597: Look for patterns that could benefit from large-scale batch transformations
Line 598: This matches the Python BatchTransformer which looks for deprecated patterns
Line 603: Count patterns across all files
Line 609: Look for deprecated string formatting patterns (like Python %)
Line 614: Look for import reorganization opportunities
Line 619: Look for code consistency patterns
Line 627: Create suggestions for patterns found in multiple files (batch-worthy)
Line 629: Only suggest if found in multiple files
Line 666: Apply batch transformation
Line 678: Apply the batch transformation pattern to all affected files
Line 684: Only write if the code actually changed
Line 697: Will be set by engine if backup is created
Line 710: Validate batch transformation results
Line 711: Returns detailed validation results as dict[str, Any] matching Python
Line 722: Basic validation - check if transformation completed successfully
Line 727: Validate that all modified files exist and are accessible
Line 739: Try to read the file to ensure it's accessible
Line 753: Additional validation: check that batch operation didn't introduce syntax errors
Line 754: This could be enhanced with language-specific parsing
Line 766: Don't clone statistics

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 9888 characters
🤖 Analyzing: [███████████████████████████████████████████░░░░░░░]  86% (13/15) - test_generation_old.rs...🔍 DEBUG PROMPT for test_generation_old.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio
- test_generation.rs: This file, test_generation.rs, implements a comprehensive suite of automated test generation functionalities using both property-based testing and search-based techniques similar to those used in Pyth
- multi_language.rs: The file ./codehud-transform/src/transformers/multi_language.rs in the CodeHUD project implements multi-language transformations using Comby-style pattern matching and replacement, enabling transforma
- mod.rs: This file, `mod.rs` in the codehud-transform/src/transformers directory, provides implementations for different transformations related to codebase transformation and refactoring. These transformation
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a magic number transformer for code analysis and transformation in Rust. It specifically extracts "magic numbers" to named constants in the source code for be
- unused_args.rs: This file (./codehud-transform/src/transformers/unused_args.rs) is a Rust implementation of a transformer that focuses on eliminating unused code elements, such as function arguments, imports, and var

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/test_generation_old.rs
Language: rust
Comments found: 171

STRUCTURAL CONTEXT:
structure: calls Box::new., calls TestGenerationConfig::default., calls JavaScriptTestGenerator::new., calls tree_sitter_python::language., calls TransformError::Config., calls Parser::new., calls TransformError::Parse., calls Self::new., calls tree_sitter_javascript::language., calls TestGenerationTransformer::new., generate_test_file is a wrapper for Err.TransformError.Config.format.language (lines 955)., extract_function_name is a wrapper for Ok.cursor.node.utf8_text.source.as_bytes.to_string (lines 457)., transform is a wrapper for Err.TransformError.Config.format.input.language (lines 864)., calls HashMap::new., calls PythonTestGenerator::new., extract_function_body is a wrapper for Ok.cursor.node.utf8_text.source.as_bytes.to_string (lines 528).
imports: Imports: use regex::Regex;., Imports: use crate::{, Imports: use tree_sitter::{Parser, Node, TreeCursor};., use super::*;., Imports: use super::*;., Imports: use async_trait::async_trait;., Imports: use std::collections::HashMap;., use crate::{, Imports: use serde::{Serialize, Deserialize};.
file_i/o: this scope performs file I/O via body.contains("open") (lines 581).

COMMENTS TO ANALYZE:
Line 1: ! Test Generation Transformer
Line 3: ! This module implements automated test generation using property-based testing
Line 4: ! and search-based techniques, matching Python's Hypothesis and similar tools.
Line 17: Test generation transformer
Line 19: Parser for syntax analysis
Line 21: Configuration for test generation
Line 23: Test generators for different languages
Line 27: Configuration for test generation
Line 30: Type of tests to generate
Line 32: Whether to use property-based testing
Line 34: Whether to use mutation testing
Line 36: Maximum number of test cases per function
Line 38: Whether to generate edge case tests
Line 40: Whether to generate performance tests
Line 42: Test framework to target
Line 63: Types of tests to generate
Line 80: Test generator trait
Line 82: Generate tests for a function
Line 85: Generate tests for a class
Line 88: Generate property-based tests
Line 92: Information about a function for test generation
Line 99: Parameter types and names
Line 103: Function body (for analysis)
Line 107: Line numbers (start, end)
Line 115: Information about a class for test generation
Line 122: Methods in the class
Line 141: Whether parameter is optional
Line 143: Constraints on parameter values
Line 156: Whether attribute is public
Line 160: Constraints on parameter values
Line 163: Range constraint for numbers
Line 165: Length constraint for strings/collections
Line 169: Regex pattern for strings
Line 175: Detected function patterns
Line 178: Pure function (no side effects)
Line 180: Function with side effects
Line 182: Function that throws exceptions
Line 184: Function with loops
Line 186: Function with conditionals
Line 190: Function with I/O operations
Line 194: Generated test case
Line 207: Setup code (if needed)
Line 209: Teardown code (if needed)
Line 222: Actual value expression
Line 228: Types of assertions
Line 241: Not None assertion
Line 255: Test data for parameterized tests
Line 264: Test case description
Line 268: Python test generator
Line 270: Hypothesis strategy mappings
Line 274: JavaScript test generator
Line 276: Test framework specific settings
Line 281: Create new test generation transformer
Line 297: Generate tests for source code
Line 299: Parse source code
Line 303: Extract functions and classes
Line 307: Get appropriate generator
Line 315: Generate tests for functions
Line 320: Generate property-based tests if enabled
Line 327: Generate tests for classes
Line 336: Extract function information from syntax tree
Line 343: Recursively extract functions
Line 363: Extract class information from syntax tree
Line 370: Recursively extract classes
Line 390: Analyze function node
Line 395: Extract function name
Line 398: Extract function signature
Line 404: Extract return type (if available)
Line 407: Extract function body
Line 432: Analyze class node
Line 451: Extract function name
Line 467: Extract class name
Line 469: Similar to extract_function_name but for classes
Line 473: Extract function parameters
Line 493: Extract parameters from parameters node
Line 502: Would need type annotation analysis
Line 503: Would need default value analysis
Line 516: Extract return type
Line 518: Simplified - would need full type annotation parsing
Line 522: Extract function body
Line 540: Simplified - would need docstring extraction
Line 544: Calculate function complexity
Line 551: Count complexity contributing nodes
Line 574: Detect function patterns
Line 580: Check for various patterns
Line 602: Extract base classes
Line 608: Extract class methods
Line 615: Extract class attributes
Line 645: Generate basic unit test
Line 663: Generate edge case tests if enabled
Line 669: Limit number of tests
Line 678: Generate constructor test
Line 692: Generate tests for each method
Line 726: Generate test parameters
Line 761: Generate hypothesis decorators
Line 777: Generate property assertion
Line 849: JavaScript property-based testing would use libraries like fast-check
Line 860: Set parser for input language
Line 871: Generate test file content
Line 874: Determine test file name
Line 891: Original file unchanged
Line 907: Test generation always creates files
Line 916: 0.5 seconds per line, minimum 2 seconds
Line 922: Test generation is safe
Line 924: Original file not modified
Line 925: Generated tests should be reviewed
Line 931: Generate test file content from tests
Line 963: Generate test file name
Line 995: Would need actual test with tree-sitter parsing

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8411 characters
🤖 Analyzing: [██████████████████████████████████████████████░░░░]  93% (14/15) - unused_args_old.rs...🔍 DEBUG PROMPT for unused_args_old.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio
- test_generation.rs: This file, test_generation.rs, implements a comprehensive suite of automated test generation functionalities using both property-based testing and search-based techniques similar to those used in Pyth
- multi_language.rs: The file ./codehud-transform/src/transformers/multi_language.rs in the CodeHUD project implements multi-language transformations using Comby-style pattern matching and replacement, enabling transforma
- mod.rs: This file, `mod.rs` in the codehud-transform/src/transformers directory, provides implementations for different transformations related to codebase transformation and refactoring. These transformation
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a magic number transformer for code analysis and transformation in Rust. It specifically extracts "magic numbers" to named constants in the source code for be
- unused_args.rs: This file (./codehud-transform/src/transformers/unused_args.rs) is a Rust implementation of a transformer that focuses on eliminating unused code elements, such as function arguments, imports, and var

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/unused_args_old.rs
Language: rust
Comments found: 183

STRUCTURAL CONTEXT:
imports: Imports: use async_trait::async_trait;., use super::*;., Imports: use regex::Regex;., Imports: use crate::{, Imports: use std::collections::{HashMap, HashSet};., Imports: use super::*;., Imports: use tree_sitter::{Parser, Node, TreeCursor};., use crate::{
structure: calls tree_sitter_javascript::language., calls tree_sitter_python::language., calls Parser::new., calls DeadCodeConfig::default., calls HashMap::new., extract_function_name is a wrapper for Ok.cursor.node.utf8_text.source.as_bytes.to_string (lines 437)., analyze_usage is a wrapper for Ok.cached.clone (lines 312)., calls Regex::new., calls TransformError::Config., calls UnusedArgumentRemover::new., transform is a wrapper for Err.TransformError.Config.format.input.language (lines 825)., calls Self::new., calls TransformError::Parse.

COMMENTS TO ANALYZE:
Line 1: ! Unused Argument Removal Transformer
Line 3: ! This module implements dead code elimination focusing on unused function
Line 4: ! arguments, variables, and imports, matching Python's capabilities exactly.
Line 16: Unused argument removal transformer
Line 18: Parser for syntax analysis
Line 20: Configuration for dead code removal
Line 26: Configuration for dead code elimination
Line 29: Whether to remove unused function arguments
Line 31: Whether to remove unused local variables
Line 33: Whether to remove unused imports
Line 35: Whether to remove unused class attributes
Line 37: Whether to remove unreachable code
Line 39: Patterns to ignore (e.g., "self", "_*")
Line 41: Whether to be conservative (keep potentially used items)
Line 43: Minimum confidence threshold for removal
Line 67: Analysis of code usage patterns
Line 70: Functions and their argument usage
Line 72: Variables and their usage
Line 74: Imports and their usage
Line 76: Class attributes and their usage
Line 78: Unreachable code blocks
Line 82: Function usage information
Line 89: Parameter usage information
Line 91: Whether function is called externally
Line 99: Parameter usage information
Line 104: Whether parameter is used in function body
Line 108: Confidence in usage analysis
Line 110: Whether parameter might be used dynamically
Line 114: Variable usage information
Line 119: Where variable is defined
Line 121: Where variable is used
Line 125: Whether variable is assigned but never read
Line 127: Confidence in usage analysis
Line 131: Import usage information
Line 138: Usage sites for each name
Line 142: Whether import is used
Line 146: Attribute usage information
Line 157: Whether attribute is accessed externally
Line 161: Call site information
Line 164: Location of call
Line 166: Arguments passed to call
Line 168: Whether call uses all parameters
Line 175: Line number (1-based)
Line 177: Column number (1-based)
Line 179: Length of the element
Line 183: Code block information
Line 192: Reason why block is unreachable
Line 201: Parameter type (if available)
Line 203: Default value (if any)
Line 205: Whether parameter is variadic (*args, **kwargs)
Line 227: If statement block
Line 243: Transformation result for dead code removal
Line 246: Modified source code
Line 248: Removed unused arguments
Line 250: Removed unused variables
Line 252: Removed unused imports
Line 254: Removed unreachable code
Line 256: Warnings about potentially incorrect removals
Line 260: Information about a removed item
Line 267: Location where item was removed
Line 269: Confidence in removal decision
Line 273: Type of removed item
Line 284: Unreachable code block
Line 289: Create new unused argument remover
Line 301: Create with custom configuration
Line 308: Analyze code for unused elements
Line 310: Check cache first
Line 315: Parse source code
Line 327: Analyze different types of usage
Line 340: Remove dead code based on analysis
Line 351: Remove unused imports first (affects other removals)
Line 356: Remove unused function arguments
Line 361: Remove unused variables
Line 366: Remove unreachable code
Line 374: Analyze function usage
Line 380: Recursively analyze functions
Line 400: Analyze a single function node
Line 410: Analyze parameter usage within function body
Line 417: Find call sites (simplified - would need full cross-reference analysis)
Line 431: Extract function name
Line 447: Extract function parameters
Line 467: Extract parameters from parameters node
Line 475: Skip if matches ignore patterns
Line 479: Would need type annotation analysis
Line 480: Would need default value analysis
Line 481: Would need variadic detection
Line 493: Check if parameter should be ignored
Line 503: Analyze parameter usage within function
Line 508: Find all identifier nodes in function body that match parameter name
Line 511: High confidence in static analysis
Line 518: Would need more sophisticated analysis
Line 522: Find identifier usage in node
Line 536: Recursively search children
Line 550: Find function call sites
Line 554: Simple regex-based search for function calls
Line 566: Would need proper argument parsing
Line 567: Would need argument analysis
Line 575: Analyze variable usage
Line 577: Simplified implementation - would need comprehensive variable analysis
Line 581: Analyze import usage
Line 587: Recursively analyze imports
Line 609: Analyze import node
Line 619: Check if imports are used (simplified)
Line 638: Extract imported names from import node
Line 658: Find import usage sites
Line 662: Simple regex-based search
Line 676: Remove the import statement itself
Line 678: Simple heuristic: if it's on a line starting with import, it's the import statement
Line 689: Analyze attribute usage
Line 691: Simplified implementation - would need comprehensive attribute analysis
Line 695: Analyze unreachable code
Line 697: Simplified implementation - would need control flow analysis
Line 701: Remove unused imports
Line 707: Remove the import line
Line 719: Remove empty lines and rebuild
Line 728: Remove unused function arguments
Line 733: Remove parameter from function signature
Line 753: Remove unused variables
Line 757: Remove variable assignment
Line 776: Remove unreachable code
Line 779: Remove unreachable code block
Line 793: Remove parameter from function signature
Line 795: Simplified implementation using regex
Line 799: This is a simplified implementation - a real implementation would need proper AST manipulation
Line 803: Remove variable assignment
Line 809: Remove code block
Line 821: Set parser for input language
Line 833: Count potentially removable items
Line 844: For dry run, just report what would be removed
Line 851: Apply dead code removal
Line 889: Will be set by engine
Line 903: 0.1 seconds per line
Line 905: Count potential functions to analyze
Line 913: Dead code removal has moderate risk
Line 915: Estimate 10% of lines affected
Line 916: Should review what was removed

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 9560 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (15/15) - architectural.rs...🔍 DEBUG PROMPT for architectural.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- types.rs: This Rust file, `types.rs`, defines a comprehensive set of data structures and enums related to code transformations. It provides detailed information about different transformation types, their confi
- lib.rs: This Rust file is a library for code transformation and refactoring in various programming languages, aiming to provide comprehensive transformations of any codebase with zero degradation. It features
- engine.rs: This file, engine.rs in the codehud-transform/src directory, serves as a central transformation engine for a variety of functionalities such as transforming codes, tracking transformations history, ro
- rollback.rs: This file implements a Rollback system with Git integration, providing comprehensive rollback functionalities with Git backups. It manages backups and restoration, offering configuration for the rollb
- libcst.rs: This Rust file implements a Concrete Syntax Tree (CST) equivalent for LibCST, preserving formatting and comments exactly like Python LibCST. It defines syntax kinds, type aliases, metadata preservatio
- test_generation.rs: This file, test_generation.rs, implements a comprehensive suite of automated test generation functionalities using both property-based testing and search-based techniques similar to those used in Pyth
- multi_language.rs: The file ./codehud-transform/src/transformers/multi_language.rs in the CodeHUD project implements multi-language transformations using Comby-style pattern matching and replacement, enabling transforma
- mod.rs: This file, `mod.rs` in the codehud-transform/src/transformers directory, provides implementations for different transformations related to codebase transformation and refactoring. These transformation
- magic_numbers.rs: This file, `magic_numbers.rs`, implements a magic number transformer for code analysis and transformation in Rust. It specifically extracts "magic numbers" to named constants in the source code for be
- unused_args.rs: This file (./codehud-transform/src/transformers/unused_args.rs) is a Rust implementation of a transformer that focuses on eliminating unused code elements, such as function arguments, imports, and var

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-transform/src/transformers/architectural.rs
Language: rust
Comments found: 155

STRUCTURAL CONTEXT:
structure: calls HashMap::new., calls Parser::new., calls TransformError::Transform., calls ArchitecturalRefactorer::new., count_function_parameters is a wrapper for Ok.cursor.node.child_count (lines 458)., extract_class_name is a wrapper for Ok.name_text.to_string (lines 403)., calls ArchitecturalConfig::default., calls Self::create_default_patterns., apply_transformation is a wrapper for Err.TransformError.Config.format.language (lines 801)., calls tree_sitter_typescript::language_typescript., extract_function_name is a wrapper for Ok.name_text.to_string (lines 420)., calls TransformError::Parse., calls tree_sitter_javascript::language., calls TransformError::Config., calls Self::new., calls ArchitecturalRefactorer::create_default_patterns., calls tree_sitter_python::language.
imports: use super::*;., Imports: use tree_sitter::{Parser, Language, Node, TreeCursor};., Imports: use regex::Regex;., Imports: use super::*;., Imports: use codehud_core::models::AnalysisResult;., Imports: use crate::{, use crate::{, Imports: use std::collections::HashMap;., Imports: use serde_json::{json, Value};., Imports: use serde_json::json;., Imports: use async_trait::async_trait;.
file_i/o: this scope performs file I/O via invalid_files.push(format!("Cannot (lines 879)., this scope performs file I/O via std::fs::read_to_string(&full_path) (lines 792, 871)., this scope performs file I/O via std::fs::write(&full_path, (lines 813).

COMMENTS TO ANALYZE:
Line 1: ! Architectural Refactoring Transformer
Line 3: ! This module implements large-scale architectural transformations including:
Line 4: ! - Class hierarchy restructuring
Line 5: ! - Design pattern implementation
Line 6: ! - Module organization improvements
Line 7: ! - Dependency injection patterns
Line 21: Architectural refactoring transformer
Line 23: Parser for syntax analysis
Line 25: Language being processed
Line 27: Refactoring patterns to apply
Line 29: Configuration for architectural changes
Line 33: Configuration for architectural refactoring
Line 36: Maximum class size before splitting
Line 38: Maximum function complexity before refactoring
Line 40: Whether to apply design patterns
Line 42: Whether to extract interfaces
Line 44: Whether to apply dependency injection
Line 46: Whether to restructure inheritance hierarchies
Line 63: Refactoring pattern definition
Line 70: Conditions that trigger this pattern
Line 72: Transformations to apply
Line 74: Risk level of applying this pattern
Line 78: Condition for pattern application
Line 81: Class has too many methods
Line 83: Function is too complex
Line 85: Duplicate code detected
Line 87: Poor cohesion detected
Line 89: Tight coupling detected
Line 91: God class anti-pattern
Line 95: Transformation to apply for a pattern
Line 98: Extract method from large function
Line 100: Split large class into multiple classes
Line 102: Extract interface from class
Line 104: Apply strategy pattern
Line 106: Apply factory pattern
Line 108: Apply dependency injection
Line 112: Strategy for splitting classes
Line 115: Split by functionality
Line 117: Split by data cohesion
Line 119: Split by method groups
Line 123: Analysis result for architectural assessment
Line 126: Classes found in the code
Line 128: Functions found in the code
Line 130: Detected architectural issues
Line 132: Suggested refactoring patterns
Line 134: Overall architectural health score
Line 138: Analysis of a single class
Line 143: Line numbers (start, end)
Line 145: Number of methods
Line 147: Number of attributes
Line 149: Lines of code
Line 151: Cohesion score (0.0 to 1.0)
Line 153: Coupling score (0.0 to 1.0)
Line 159: Analysis of a single function
Line 164: Line numbers (start, end)
Line 166: Number of parameters
Line 168: Lines of code
Line 174: Whether function has side effects
Line 178: Architectural issue detected
Line 185: Description of the issue
Line 187: Location in code
Line 194: Create new architectural refactorer
Line 198: Default to Python - will be set based on input
Line 210: Detect language from file extension
Line 221: Create default refactoring patterns
Line 285: Analyze architectural structure
Line 287: Parse the source code
Line 299: Analyze classes and functions
Line 302: Calculate health score
Line 305: Suggest refactoring patterns
Line 311: Analyze a syntax tree node recursively
Line 325: Recursively analyze child nodes
Line 339: Analyze a class definition
Line 345: Extract class name
Line 348: Count methods and attributes
Line 351: Calculate cohesion and coupling (simplified metrics)
Line 368: Analyze a function definition
Line 374: Extract function name
Line 380: Calculate complexity metrics
Line 396: Extract class name from node
Line 413: Extract function name from node
Line 430: Count class members (methods and attributes)
Line 452: Count function parameters
Line 468: Calculate class cohesion (simplified LCOM metric)
Line 470: Simplified implementation - in a real system this would analyze
Line 472: Default moderate cohesion
Line 475: Calculate class coupling (simplified metric)
Line 477: Simplified implementation - in a real system this would analyze
Line 479: Default low coupling
Line 482: Calculate class complexity
Line 484: Sum complexity of all methods
Line 502: Calculate cyclomatic complexity
Line 512: Count nodes that contribute to complexity
Line 540: Calculate cognitive complexity
Line 542: Simplified cognitive complexity calculation
Line 546: Check if function has side effects
Line 548: Simplified implementation - would analyze for global variable access,
Line 549: I/O operations, etc.
Line 553: Calculate overall architectural health score
Line 557: Penalize large classes
Line 570: Penalize complex functions
Line 580: Suggest refactoring patterns based on analysis
Line 584: Check for god classes
Line 603: Check for complex functions
Line 622: Apply architectural refactoring
Line 633: Apply a specific refactoring pattern
Line 644: Apply a specific transformation
Line 668: Extract method refactoring
Line 670: Simplified implementation - would extract complex logic into separate methods
Line 674: Split class refactoring
Line 676: Simplified implementation - would split large classes
Line 680: Extract interface refactoring
Line 682: Simplified implementation - would extract interface from class
Line 686: Apply strategy pattern
Line 688: Simplified implementation - would apply strategy pattern
Line 692: Apply factory pattern
Line 694: Simplified implementation - would apply factory pattern
Line 698: Apply dependency injection
Line 700: Simplified implementation - would apply dependency injection
Line 707: Analyze code and suggest architectural refactoring opportunities
Line 714: For each analyzed file, check for architectural issues
Line 721: Set up parser for analysis
Line 727: Skip unsupported languages
Line 731: Analyze architectural structure
Line 734: Create suggestions based on analysis
Line 776: Apply architectural refactoring transformation
Line 782: Extract metadata from suggestion
Line 787: Get the target file path
Line 794: Set up parser for the language
Line 808: Analyze and apply refactoring
Line 812: Write the transformed code back to file
Line 815: Calculate transformation details
Line 823: Will be set by engine if backup is created
Line 837: Validate that architectural refactoring transformation was successful
Line 838: Returns detailed validation results as dict[str, Any] matching Python
Line 849: Basic validation - check if transformation completed successfully
Line 858: Validate that files exist and are syntactically correct
Line 870: Try to read and parse the file to ensure it's valid
Line 876: Additional language-specific validation could be added here
Line 908: Basic test - would need actual tree-sitter nodes for full testing

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 10555 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (15/15) - Complete!
✅ Phase 2 complete: 15 files analyzed with enhanced context
📄 File summaries updated: 129 total files (15 from codehud-transform)
📄 Analysis metadata updated: 7 crates processed
🔍 DEBUG: Crate path for codehud-tui: ./codehud-tui
🔍 Processing 2 files from crate codehud-tui
🔍 DEBUG: First 5 files discovered for crate codehud-tui:
  1. ./codehud-tui/src/main.rs
  2. ./codehud-tui/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-tui/src/main.rs
✅ DEBUG: Narrator method succeeded for ./codehud-tui/src/main.rs
🔍 DEBUG: Generating structural insights for ./codehud-tui/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-tui/src/lib.rs
💾 Comments JSON updated: 131 total files (2 from codehud-tui)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-tui...
🤖 Analyzing 2 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (2 files)...
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (1/2) - main.rs...🔍 DEBUG PROMPT for main.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-tui/src/main.rs
Language: rust
Comments found: 48

STRUCTURAL CONTEXT:
entrypoint: Entrypoint script (lines 77).
file_i/o: this scope performs file I/O via std::fs::write(&text_file, (lines 284)., this scope performs file I/O via std::fs::write(file_path, (lines 366)., this scope performs file I/O via writeln!(output, (lines 315, 317, 319, 321, 325–326, 328, 330, 332, 336–338, 340, 344–345)., this scope performs file I/O via std::fs::write(&json_file, (lines 281).
structure: calls Cli::parse., calls crossterm::terminal::size., calls codehud_viz::VisualizationEngine::new., calls serde_json::to_string_pretty., calls codehud_core::models::AnalysisResult::new., calls CodeHudTui::new_headless., calls serde_json::to_value., calls atty::is.
imports: Imports: use clap::{Parser, Subcommand};., Imports: use anyhow::Result;., Imports: use codehud_tui::{run_tui, export_structured_data, CodeHudTui};., Imports: use std::path::PathBuf;., Imports: use std::fmt::Write;.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD TUI CLI entry point
Line 3: ! Command-line interface for the CodeHUD Terminal User Interface
Line 4: ! optimized for Claude Code consumption.
Line 20: Path to the codebase to analyze
Line 24: Export analysis data to JSON instead of running TUI
Line 28: Output file for exported data
Line 32: Maximum number of issues to display
Line 36: Show only critical issues
Line 40: Use relative file paths
Line 44: Force TUI mode (skip terminal check)
Line 48: Show text preview of TUI output (no interactive terminal)
Line 52: Show visualizations directly in terminal (no interactive mode)
Line 59: Run the interactive TUI
Line 61: Path to the codebase to analyze
Line 64: Export analysis data as structured JSON
Line 66: Path to the codebase to analyze
Line 68: Output file path
Line 72: Validate TUI configuration
Line 94: Handle legacy CLI interface
Line 117: Run the interactive TUI
Line 122: Run the interactive TUI with options
Line 124: Check if we're in a terminal first (unless forced)
Line 150: Show text preview of TUI output (no interactive terminal required)
Line 155: Create headless TUI instance and load analysis
Line 160: Display TUI-formatted output as text
Line 174: Show critical issues (TUI Priority View)
Line 192: Show security summary (TUI Security View)
Line 206: Show quality metrics (TUI Quality View)
Line 214: Show navigation hint
Line 232: Show visualizations directly in terminal without interactive mode
Line 237: Create headless TUI instance and load analysis
Line 242: Create viz engine
Line 245: Convert analysis data to AnalysisResult
Line 251: Convert the analysis data to JSON and store in view data
Line 255: Create output directory for visualization exports
Line 258: Generate and display different view types
Line 275: Export as files
Line 286: Display summary in terminal
Line 308: Convert visualization view to readable text format (standalone version)
Line 352: Export analysis data as structured JSON
Line 356: Create headless TUI instance and load analysis
Line 360: Get analysis data and export
Line 388: Validate TUI configuration
Line 392: Check terminal capabilities
Line 402: Check color support

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3562 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (2/2) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-tui/src/lib.rs
Language: rust
Comments found: 138

STRUCTURAL CONTEXT:
imports: Imports: use std::{, Imports: use syntect::{, Imports: use std::fs;., Imports: use serde_json::Value;., Imports: use chrono::{DateTime, Utc};., Imports: use ratatui::{, Imports: use crossterm::{, Imports: use anyhow::{Context, Result};., Imports: use serde::{Deserialize, Serialize};., Imports: use codehud_analysis::pipeline::{DirectAnalysisPipeline, AnalysisResult as PipelineAnalysisResult};., Imports: use codehud_viz::{VisualizationEngine, VizConfig, ColorScheme as VizColorScheme};., Imports: use std::fmt::Write;., Imports: use codehud_core::{
structure: calls Self::render_placeholder_view_static., calls Duration::from_millis., calls Tabs::new., calls CodeHudTui::render_footer_static., calls SyntaxSet::load_defaults_newlines., calls io::stdout., calls Path::new., calls Self::export_visualization., calls Self::render_no_data_view_static., calls Self::render_view_as_text., calls TuiConfig::default., calls Self::render_issues_view_static., calls fs::write., calls CrosstermBackend::new., calls Constraint::Length., calls CodeHudTui::render_main_content_static., calls Style::default., calls DirectAnalysisPipeline::new., calls fs::create_dir_all., calls ThemeSet::load_defaults., calls atty::is., calls codehud_core::CoreConfig::default., calls Constraint::Percentage., calls List::new., calls Self::convert_to_analysis_result., calls ListItem::new., calls serde_json::to_value., calls crossterm::event::poll., calls ListState::default., new is a wrapper for Err.anyhow.anyhow (lines 242)., calls Terminal::new., calls Line::from., calls Self::render_quality_view_static., calls CodeHudTui::new., calls serde_json::to_string_pretty., calls event::read., calls Self::render_security_view_static., calls Paragraph::new., calls Instant::now., calls HashMap::new., calls AnalysisResult::new., calls view_name.parse::<ViewType>., calls CodeHudTui::render_header_static., calls Constraint::Min., calls Duration::from_secs., calls VisualizationEngine::new., calls Layout::default., calls Block::default.
file_i/o: this scope performs file I/O via event::read() (lines 679)., this scope performs file I/O via writeln!(output, (lines 1502–1506, 1510–1511, 1513, 1515, 1517, 1521–1523, 1525, 1527, 1529, 1533–1536, 1538, 1542–1543)., this scope performs file I/O via fs::write(&json_file, (lines 1486)., this scope performs file I/O via fs::write(&text_file, (lines 1491).

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD TUI - Terminal User Interface optimized for Claude Code consumption
Line 3: ! This crate provides a terminal-based interface using ratatui that presents
Line 4: ! CodeHUD analysis results in a structured, actionable format optimized for
Line 5: ! AI agents and command-line integration.
Line 49: Claude Code optimized TUI application
Line 60: Application state for navigation and display
Line 63: Current view being displayed
Line 65: List of available views
Line 67: Current selection index in lists
Line 71: Filter applied to current view
Line 73: Show only critical items
Line 75: Sort order (ascending/descending)
Line 77: Currently focused panel
Line 81: Panels that can receive focus
Line 90: Aggregated analysis data optimized for TUI display
Line 93: Overall health score (0-100)
Line 95: Total files analyzed
Line 97: Critical issues requiring immediate attention
Line 99: Quality metrics summary
Line 103: Top problematic files
Line 109: Raw analysis results for detailed views
Line 115: Critical issue requiring immediate attention
Line 127: Quality metrics summary
Line 137: Security assessment summary
Line 147: Problematic file with actionable metrics
Line 158: Dependency analysis insights
Line 168: Performance bottleneck identification
Line 178: Severity levels for issues
Line 188: Risk assessment levels
Line 201: Maximum items to display in lists
Line 203: Show file paths relative or absolute
Line 207: Auto-refresh interval in seconds
Line 209: Default view on startup
Line 211: Enable syntax highlighting in code views
Line 228: Color schemes for TUI
Line 234: Optimized for Claude Code consumption
Line 238: Create a new TUI instance for interactive use
Line 240: Check if we're in a proper terminal environment
Line 291: Create a new TUI instance for headless data processing (no terminal)
Line 328: Load analysis data from a codebase path
Line 333: Run comprehensive analysis
Line 336: Process and aggregate data into TUI-optimized format
Line 342: Process analysis result into TUI-optimized format
Line 347: Extract data from views
Line 353: Extract critical issues across all analyses
Line 356: Use existing health score from analysis
Line 359: Process quality summary
Line 362: Process security summary
Line 365: Identify problematic files
Line 368: Process dependency insights
Line 371: Extract performance bottlenecks
Line 397: Extract critical issues that need immediate attention
Line 401: Extract critical quality issues
Line 409: Critical threshold for maintainability
Line 425: Extract critical security issues
Line 448: Sort by impact score (highest first)
Line 454: Calculate overall health score from multiple analyses
Line 459: Quality score (40% weight)
Line 470: Security score (35% weight)
Line 477: Default to average if we have partial data
Line 481: Default neutral score
Line 485: Process quality data into summary format
Line 514: Sort worst files by maintainability score
Line 516: Top 10 worst files
Line 524: Mock complexity distribution for now
Line 540: Process security data into summary format
Line 580: TODO: Extract from data
Line 584: Identify most problematic files across all analyses
Line 603: Calculate priority rank based on multiple factors
Line 624: Will be set after sorting
Line 631: Sort by priority score and assign ranks
Line 642: Return top 20 most problematic files
Line 648: Process dependency analysis into insights
Line 650: Mock implementation - would need actual dependency data structure
Line 660: Extract performance bottlenecks from analysis data
Line 662: Mock implementation - would extract from actual performance analysis
Line 666: Run the main TUI event loop
Line 715: Draw the TUI interface
Line 725: Main layout: Header + Body + Footer
Line 735: Render components with captured data
Line 744: Render header with view tabs
Line 782: Render main content area based on current view
Line 801: Render quality analysis view
Line 811: Worst files list
Line 855: Quality metrics summary
Line 869: Render security analysis view
Line 924: Security issues list (filtered to security issues only)
Line 986: Render topology view
Line 994: Render dependencies view
Line 1007: Render performance view
Line 1018: Render issues view
Line 1020: Show all critical issues in a detailed list
Line 1092: Render placeholder for unimplemented views
Line 1100: Render view when no analysis data is available
Line 1115: Render footer with help information
Line 1142: Get color style based on health score
Line 1223: TODO: Implement detail view for selected item
Line 1227: TODO: Implement filtering
Line 1239: TODO: Implement data refresh
Line 1243: Get the current analysis data (for export functionality)
Line 1248: Static render methods for use in closures
Line 1290: Create visualization engine for rendering
Line 1293: Convert data and use viz engine
Line 1296: Export visualization to file for inspection
Line 1304: Fallback to old static methods if viz engine fails
Line 1351: Worst files list
Line 1391: Quality metrics summary
Line 1417: Render visualization charts using the viz engine
Line 1419: Use the visualization engine to generate a view
Line 1422: Render the visualization view in the TUI
Line 1427: Get visualization engine reference
Line 1432: Convert AnalysisData to AnalysisResult for viz engine
Line 1439: Convert the analysis data to JSON and store in view data
Line 1446: Fallback rendering when viz engine fails
Line 1465: Export visualization to file for inspection
Line 1469: Create output directory
Line 1472: Convert view to displayable format
Line 1483: Export as JSON for inspection
Line 1488: Export as text summary
Line 1497: Convert visualization view to readable text format
Line 1553: Limit for static view
Line 1631: Create and run TUI for a given codebase
Line 1639: Export analysis data in structured format for programmatic consumption

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 8753 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (2/2) - Complete!
✅ Phase 2 complete: 2 files analyzed with enhanced context
📄 File summaries updated: 131 total files (2 from codehud-tui)
📄 Analysis metadata updated: 8 crates processed
🔍 DEBUG: Crate path for codehud-utils: ./codehud-utils
🔍 Processing 5 files from crate codehud-utils
🔍 DEBUG: First 5 files discovered for crate codehud-utils:
  1. ./codehud-utils/src/config/mod.rs
  2. ./codehud-utils/src/lib.rs
  3. ./codehud-utils/src/logging/mod.rs
  4. ./codehud-utils/src/file/mod.rs
  5. ./codehud-utils/src/string/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-utils/src/config/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-utils/src/config/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-utils/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-utils/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-utils/src/logging/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-utils/src/logging/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-utils/src/file/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-utils/src/file/mod.rs
🔍 DEBUG: Generating structural insights for ./codehud-utils/src/string/mod.rs
✅ DEBUG: Narrator method succeeded for ./codehud-utils/src/string/mod.rs
💾 Comments JSON updated: 136 total files (5 from codehud-utils)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-utils...
🤖 Analyzing 5 files with enhanced context and improved token limits...
📦 Processing batch 1/1 (5 files)...
🤖 Analyzing: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  20% (1/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-utils/src/config/mod.rs
Language: rust
Comments found: 26

STRUCTURAL CONTEXT:
imports: Imports: use std::path::Path;., Imports: use std::collections::HashMap;., Imports: use serde::{Deserialize, Serialize};., use super::*;., Imports: use tempfile::tempdir;., Imports: use super::*;.
file_i/o: this scope performs file I/O via std::fs::write(&config_path, (lines 288, 312, 364)., this scope performs file I/O via std::fs::read_to_string(path) (lines 31, 157).
structure: calls T::deserialize., calls serde_json::to_value., calls serde_json::from_str., calls serde_yaml::from_str., load_file is a wrapper for Err.UtilError.Config.format.extension (lines 49)., calls Self::new., calls serde_json::from_value., calls ConfigBuilder::new., load_config is a wrapper for Err.UtilError.Config.format.extension (lines 175)., calls HashMap::new., calls crate::UtilError::Serialization., calls toml::from_str., calls crate::UtilError::Config., calls ConfigLoader::new., calls T::default.

COMMENTS TO ANALYZE:
Line 1: ! Configuration utilities with Python configparser compatibility
Line 3: ! This module provides configuration loading and management that
Line 4: ! behaves identically to Python's configparser and related utilities.
Line 10: Configuration loader that supports TOML, JSON, and YAML
Line 17: Create a new configuration loader
Line 24: Load configuration from file (auto-detects format)
Line 64: Get configuration value by key path (supports dot notation)
Line 70: Get string value
Line 75: Get integer value
Line 80: Get float value
Line 85: Get boolean value
Line 90: Get array value
Line 95: Helper to navigate nested JSON values using dot notation
Line 107: Merge configurations (second config overrides first)
Line 117: Get all config names
Line 129: Merge two JSON values (second overrides first)
Line 147: Load configuration from file (convenience function)
Line 184: Merge two configurations (second overrides first)
Line 203: Validate configuration against schema (basic validation)
Line 208: Convert to JSON to perform validation
Line 212: TODO: Add more sophisticated validation if needed
Line 216: Configuration builder for fluent API
Line 226: Create new config builder with defaults
Line 233: Load from file and merge
Line 240: Merge with another config
Line 246: Validate and build final config

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2724 characters
🤖 Analyzing: [████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  40% (2/5) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-utils/src/lib.rs
Language: rust
Comments found: 25

STRUCTURAL CONTEXT:
exports: pub use file::{, pub use string::{, pub use config::{load_config, merge_configs, validate_config};.
imports: Imports: pub use config::{load_config, merge_configs, validate_config};., Imports: pub use string::{, use super::*;., Imports: pub use file::{, Imports: use std::path::PathBuf;., Imports: use super::*;.
structure: detect_language is a wrapper for Some.language (lines 146).

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Utilities - Python-Compatible Utility Functions
Line 3: ! This crate provides utility functions that match Python behavior exactly
Line 4: ! to ensure zero degradation in file operations, string processing,
Line 5: ! configuration handling, and logging.
Line 15: Re-export commonly used utilities
Line 26: Result type used throughout CodeHUD utilities
Line 29: Error types for utility operations
Line 32: I/O operation failed
Line 40: String processing error
Line 44: Path operation error
Line 53: Common exclusion patterns that match Python behavior exactly
Line 75: IDE and editor files
Line 99: File extensions for different programming languages (matches Python logic)
Line 139: Detect programming language from file extension
Line 153: Check if a path should be excluded based on patterns
Line 159: Handle glob patterns like *.pyc

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1750 characters
🤖 Analyzing: [██████████████████████████████░░░░░░░░░░░░░░░░░░░░]  60% (3/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-utils/src/logging/mod.rs
Language: rust
Comments found: 35

STRUCTURAL CONTEXT:
structure: calls Level::from., calls fmt::layer., calls Default::default., calls RotatingFileHandler::new., calls FileHandler::new., calls chrono::Utc::now., calls tracing_subscriber::registry., calls Logger::new., calls crate::UtilError::Config., calls EnvFilter::builder.
imports: Imports: use std::io::{self, Write};., use super::*;., Imports: use tracing_subscriber::{, Imports: use tracing::Level;., Imports: use tracing::Subscriber;., Imports: use tempfile::tempdir;., Imports: use tracing_subscriber::{fmt::format::FmtSpan, Layer};., Imports: use super::*;.
file_i/o: this scope performs file I/O via std::fs::read_to_string(&log_path) (lines 363)., this scope performs file I/O via fmt::layer() (lines 84)., this scope performs file I/O via handler.write_record(LogLevel::Info, (lines 361, 380)., this scope performs file I/O via self.current_file.write_all(log_line.as_bytes()) (lines 288)., this scope performs file I/O via std::fs::OpenOptions::new() (lines 231, 262).

COMMENTS TO ANALYZE:
Line 1: ! Logging utilities with Python logging compatibility
Line 3: ! This module provides logging capabilities that behave similarly
Line 4: ! to Python's logging module while leveraging Rust's tracing ecosystem.
Line 19: Log levels matching Python logging levels
Line 36: Rust doesn't have CRITICAL, use ERROR
Line 54: Logger configuration matching Python logging behavior
Line 78: Initialize logging with configuration
Line 100: Initialize basic logging (equivalent to Python's basicConfig)
Line 109: Logger struct that mimics Python logger behavior
Line 117: Create a new logger with the given name
Line 125: Set the logging level
Line 130: Get the current logging level
Line 135: Check if a level is enabled
Line 140: Log a debug message
Line 147: Log an info message
Line 154: Log a warning message
Line 161: Log an error message
Line 168: Log a critical message
Line 175: Log an exception (error with extra context)
Line 181: Get a logger by name (equivalent to Python's logging.getLogger)
Line 186: Structured logging macros that work with tracing
Line 223: File handler for logging to files (equivalent to Python's FileHandler)
Line 229: Create a new file handler
Line 239: Write a log record to the file
Line 246: Rotating file handler (basic implementation)
Line 256: Create a new rotating file handler
Line 278: Write a log record, rotating if necessary
Line 283: Check if rotation is needed
Line 294: Perform log rotation
Line 296: Close current file
Line 299: Rotate backup files
Line 309: Move current log to .1
Line 315: Create new log file
Line 378: Write enough to trigger rotation
Line 383: Check that backup files were created

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 3141 characters
🤖 Analyzing: [████████████████████████████████████████░░░░░░░░░░]  80% (4/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-utils/src/file/mod.rs
Language: rust
Comments found: 36

STRUCTURAL CONTEXT:
file_i/o: this scope performs file I/O via fs::write(root.join("test.js"), (lines 332)., this scope performs file I/O via fs::write(src_dir.join("main.py"), (lines 337)., this scope performs file I/O via fs::write(&file_path, (lines 314, 358, 367)., this scope performs file I/O via fs::write(project_dir.join("pyproject.toml"), (lines 301)., this scope performs file I/O via fs::read_to_string(path) (lines 226, 245)., this scope performs file I/O via fs::read_dir(dir) (lines 184)., this scope performs file I/O via fs::read(path) (lines 249)., this scope performs file I/O via fs::write(root.join("README.md"), (lines 333)., this scope performs file I/O via fs::write(root.join("test.py"), (lines 331).
structure: calls fs::create_dir_all., find_project_root is a wrapper for Some.current.to_path_buf (lines 53)., calls DefaultHasher::new., calls fs::metadata., calls fs::read., calls FileMetadata::from_path., calls fs::write., safe_path_join is a wrapper for Err.UtilError.PathOperation.format.base.relative (lines 19)., calls path_clean::clean., calls DateTime::from., find_files_recursive is a wrapper for Ok (lines 180)., calls crate::UtilError::PathOperation., calls fs::read_to_string., calls crate::should_exclude_path., calls crate::UtilError::Io., calls Utc::now., calls Path::new., create_backup is a wrapper for Err.UtilError.Io.std.io.Error.new.std.io.ErrorKind.NotFound (lines 70)., calls fs::copy., calls fs::read_dir., ensure_dir is a wrapper for Err.UtilError.PathOperation.format.path (lines 260).
imports: Imports: use std::collections::hash_map::DefaultHasher;., Imports: use super::*;., Imports: use std::hash::{Hash, Hasher};., Imports: use std::fs;., Imports: use camino::{Utf8Path, Utf8PathBuf};., use super::*;., Imports: use tempfile::tempdir;., Imports: use chrono::{DateTime, Utc};., Imports: use std::path::{Path, PathBuf};.

COMMENTS TO ANALYZE:
Line 1: ! File system utilities with Python pathlib compatibility
Line 3: ! This module provides file system operations that behave identically
Line 4: ! to Python's pathlib and related utilities.
Line 12: Safely join paths, preventing directory traversal attacks (matches Python os.path.join behavior)
Line 14: Normalize the relative path to prevent .. traversal
Line 17: Check for absolute path or .. traversal attempts
Line 27: Normalize path (equivalent to Python pathlib.Path.resolve())
Line 32: Find project root by looking for common project markers (matches Python behavior)
Line 50: Check if any project markers exist in current directory
Line 57: Move up to parent directory
Line 67: Create a timestamped backup of a file (matches Python behavior)
Line 96: Copy file with automatic backup creation
Line 98: Create backup of destination if it exists
Line 103: Ensure destination directory exists
Line 112: Get file metadata in a Python-compatible format
Line 126: Create FileMetadata from a path
Line 131: Creation time is not reliable on all platforms (like Python's behavior)
Line 149: Recursively find files matching patterns (equivalent to Python glob/pathlib)
Line 161: Recursive helper for find_files
Line 170: Check depth limit
Line 177: Check if directory should be excluded
Line 191: Check if file should be excluded
Line 198: Check if file matches patterns
Line 221: Calculate file content hash (for caching)
Line 242: Read file with encoding detection (matches Python behavior)
Line 244: Try UTF-8 first (most common)
Line 248: Fallback to bytes and try to decode as UTF-8 with replacement
Line 255: Ensure directory exists (equivalent to pathlib.Path.mkdir(parents=True, exist_ok=True))
Line 281: Unsafe joins should fail
Line 300: Create a project marker
Line 303: Should find project root from subdirectory
Line 330: Create test files
Line 339: Find Python files
Line 363: Same file should have same hash
Line 366: Modified file should have different hash

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 4345 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (5/5) - mod.rs...🔍 DEBUG PROMPT for mod.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-utils/src/string/mod.rs
Language: rust
Comments found: 27

STRUCTURAL CONTEXT:
structure: snake_to_camel_case is a wrapper for String.new (lines 130)., dedent is a wrapper for String.new (lines 161)., safe_truncate is a wrapper for text.to_string (lines 13)., extract_function_names is a wrapper for Vec.new (lines 66)., calls Regex::new.
imports: Imports: use regex::Regex;., use super::*;., Imports: use super::*;., Imports: use unicode_normalization::UnicodeNormalization;., Imports: use unicode_segmentation::UnicodeSegmentation;.

COMMENTS TO ANALYZE:
Line 1: ! String processing utilities with Python compatibility
Line 3: ! This module provides string operations that behave identically
Line 4: ! to Python's string methods and utilities.
Line 10: Safely truncate text to maximum length (matches Python textwrap behavior)
Line 16: Find grapheme boundary at or before max_len
Line 29: Add ellipsis if truncated and there's space
Line 33: Replace last characters with ellipsis
Line 41: Normalize whitespace (matches Python string normalization)
Line 46: Replace all whitespace sequences with single spaces
Line 50: Strip leading and trailing whitespace
Line 54: Extract function names from code (Python-like regex patterns)
Line 74: Calculate string similarity (Levenshtein distance-based, 0.0 to 1.0)
Line 90: Calculate Levenshtein distance between two strings
Line 99: Initialize first row and column
Line 107: Fill the matrix
Line 120: Convert camelCase to snake_case (Python convention)
Line 126: Convert snake_case to camelCase
Line 143: Capitalize first letter of a string
Line 152: Split text into lines preserving line endings (matches Python splitlines)
Line 157: Remove common leading whitespace from lines (like Python textwrap.dedent)
Line 164: Find minimum indentation (excluding empty lines)
Line 171: Remove common indentation
Line 184: Check if string is valid identifier (Python rules)
Line 193: First character must be letter or underscore
Line 198: Remaining characters must be alphanumeric or underscore
Line 213: Test with Unicode

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2467 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (5/5) - Complete!
✅ Phase 2 complete: 5 files analyzed with enhanced context
📄 File summaries updated: 136 total files (5 from codehud-utils)
📄 Analysis metadata updated: 9 crates processed
🔍 DEBUG: Crate path for codehud-viz: ./codehud-viz
🔍 Processing 8 files from crate codehud-viz
🔍 DEBUG: First 5 files discovered for crate codehud-viz:
  1. ./codehud-viz/src/call_graph.rs
  2. ./codehud-viz/src/lib.rs
  3. ./codehud-viz/tests/topology_test.rs
  4. ./codehud-viz/tests/summary_test.rs
  5. ./codehud-viz/tests/quality_test.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/src/call_graph.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/src/call_graph.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/src/lib.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/src/lib.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/tests/topology_test.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/tests/topology_test.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/tests/summary_test.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/tests/summary_test.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/tests/quality_test.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/tests/quality_test.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/tests/flow_test.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/tests/flow_test.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/tests/dependencies_test.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/tests/dependencies_test.rs
🔍 DEBUG: Generating structural insights for ./codehud-viz/tests/security_test.rs
✅ DEBUG: Narrator method succeeded for ./codehud-viz/tests/security_test.rs
💾 Comments JSON updated: 144 total files (8 from codehud-viz)
🤖 Phase 2: LLM analysis with batch processing for crate codehud-viz...
🤖 Analyzing 8 files with enhanced context and improved token limits...
📦 Processing batch 1/2 (5 files)...
🤖 Analyzing: [██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  12% (1/8) - call_graph.rs...🔍 DEBUG PROMPT for call_graph.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-viz/src/call_graph.rs
Language: rust
Comments found: 19

STRUCTURAL CONTEXT:
imports: Imports: use super::*;., Imports: use serde::{Deserialize, Serialize};., Imports: use std::collections::HashMap;., use super::*;., Imports: use ratatui::{
structure: calls BarChart::default., calls List::new., calls Constraint::Length., calls Block::default., calls CallGraph::new., calls Constraint::Min., calls ListItem::new., calls Paragraph::new., calls Layout::default., calls Style::default., calls Self::new.

COMMENTS TO ANALYZE:
Line 1: ! Call Graph Visualization Module
Line 3: ! Provides call graph analysis and visualization capabilities using ratatui widgets.
Line 44: Add nodes if they don't exist
Line 60: Add or update edge
Line 71: Update call counts
Line 78: Split area into sections
Line 83: Function analysis chart
Line 95: Function analysis as bar chart
Line 98: Call relationships list
Line 109: Convert to bar chart data
Line 282: Normalize to reasonable max

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1378 characters
🤖 Analyzing: [████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  25% (2/8) - lib.rs...🔍 DEBUG PROMPT for lib.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-viz/src/lib.rs
Language: rust
Comments found: 252

STRUCTURAL CONTEXT:
structure: calls Paragraph::new., calls Block::default., calls Constraint::Percentage., calls Gauge::default., calls List::new., calls ListItem::new., calls BarChart::default., calls ThemeSet::load_defaults., calls Constraint::Min., calls Layout::default., calls Style::default., calls Self::new., calls HashMap::new., calls SyntaxSet::load_defaults_newlines., calls VizConfig::default., calls Utc::now., calls Constraint::Length., calls PathBuf::from.
imports: Imports: use serde::{Deserialize, Serialize};., Imports: use std::{, Imports: use codehud_utils::logging::get_logger;., Imports: use codehud_core::{, Imports: use ratatui::{, Imports: pub use call_graph::{CallGraph, CallGraphNode, CallGraphEdge};., Imports: use syntect::{, Imports: use chrono::{DateTime, Utc};., Imports: use anyhow::{Context, Result};.
exports: pub use call_graph::{CallGraph, CallGraphNode, CallGraphEdge};.

COMMENTS TO ANALYZE:
Line 1: ! CodeHUD Visualization - Data visualization and export capabilities
Line 3: ! This crate provides visualization capabilities matching the Python implementation
Line 4: ! with support for various output formats and interactive visualizations.
Line 42: Main visualization system
Line 59: Configuration for visualization
Line 62: Terminal width (characters)
Line 64: Terminal height (characters)
Line 68: Enable syntax highlighting
Line 70: Maximum items to show in lists
Line 72: Chart data point limit
Line 89: Color schemes for visualization
Line 97: Renderable view that can be displayed in terminal
Line 106: Content types for different visualizations
Line 109: Summary dashboard with key metrics
Line 117: Code topology visualization
Line 124: Quality analysis visualization
Line 132: Security analysis visualization
Line 148: Performance analysis visualization
Line 175: Code flow visualization
Line 182: Tree-sitter enhanced semantic analysis
Line 192: File tree structure for topology visualization
Line 250: Tree-sitter import analysis summary
Line 262: Tree-sitter symbol information
Line 272: Tree-sitter semantic highlights summary
Line 282: Language feature detected by tree-sitter
Line 292: Create a new visualization engine
Line 301: Configure the visualization engine
Line 307: Generate a renderable view from analysis results
Line 334: Render a view to terminal
Line 348: Render content based on view type
Line 367: Generate summary view content
Line 372: Core analysis metrics
Line 378: Extract additional metrics from various view data sources
Line 411: Count security vulnerabilities
Line 481: Add general recommendations based on analysis
Line 498: Generate topology view content
Line 500: Extract topology data from analysis result
Line 520: Extract language distribution from summary
Line 532: Extract file and directory counts from structure
Line 545: Extract complexity data from files
Line 549: Extract file path and complexity
Line 562: Extract coupling metrics from coupling analysis
Line 582: Build real file tree structure from project structure
Line 590: Build hierarchical file tree from files data
Line 605: Extract filename from full path for display
Line 614: Build file tree structure from files data
Line 617: Limit for performance
Line 637: Generate quality view content
Line 647: Extract issues by severity from quality_issues
Line 658: Extract file metrics for analysis
Line 669: Sort by lowest maintainability (most problematic)
Line 673: Extract complexity and maintainability trends with better file handling
Line 690: Extract additional metrics from summary if available
Line 692: Add overall statistics to issues if available
Line 696: If no specific severity breakdown, add general category
Line 704: Normalize health score to 0-1 range if needed
Line 716: Generate security view content
Line 727: Extract from all_vulnerabilities (comprehensive security issues)
Line 735: Create security issue object with enhanced data
Line 753: Extract from all_security_issues (additional security analysis)
Line 780: Extract from dangerous function usage
Line 805: Calculate risk level and security score based on vulnerabilities
Line 824: Extract from summary if available
Line 839: Remove duplicates from files_with_issues
Line 852: Generate dependencies view content
Line 867: Extract summary info
Line 874: Extract circular dependencies
Line 893: Extract coupling analysis
Line 908: Extract external dependencies
Line 925: Extract graph structure
Line 927: Extract nodes from file dependencies
Line 934: Extract edges from coupling analysis
Line 949: Extract circular cycles for graph
Line 978: Extract average performance score
Line 983: Extract performance hotspots
Line 1014: Extract slow functions from optimization opportunities
Line 1046: Extract commit activity patterns
Line 1060: Extract author contributions from author_metrics
Line 1074: Extract file stability from file_evolutions
Line 1082: Get just the filename for display
Line 1090: Extract churn metrics (files with high change frequency)
Line 1098: Get just the filename for display
Line 1106: Sort by value (highest first)
Line 1129: Extract issues by tool type from issue_summary
Line 1143: Extract recent issues from all tools
Line 1195: Generate mock resolution trends based on issue types
Line 1197: Simulate trend data - in production this would come from historical analysis
Line 1201: Sort by severity (critical, high, medium, low)
Line 1230: Extract overall test coverage from metrics
Line 1233: Convert to 0-1 range
Line 1236: Extract files without tests as uncovered files
Line 1249: Extract test file names from test_files array
Line 1261: Generate test trends from coverage data
Line 1270: Convert to 0-1 range
Line 1276: If no coverage data, generate trends from test files and their test counts
Line 1286: Convert test count to a relative score (normalize to 0-1)
Line 1287: Assume 20+ tests = 100%
Line 1295: Sort trends by coverage (highest first)
Line 1316: Extract data flow nodes and edges
Line 1320: Process data flow edges
Line 1356: Calculate flow complexity based on patterns
Line 1370: Extract bottlenecks from patterns
Line 1390: Extract additional bottlenecks from variable lifecycles
Line 1409: Normalize complexity to 0-1 range
Line 1421: Generate tree-sitter analysis view content
Line 1446: Extract import analysis
Line 1466: Extract language features
Line 1481: TODO: extract files list
Line 1513: Extract highlight summary
Line 1532: Group symbols by type
Line 1544: TODO: calculate actual complexity
Line 1549: Calculate complexity for a flow edge type
Line 1560: Render header section
Line 1568: Render footer section
Line 1575: Render summary content
Line 1578: Create 4-panel layout
Line 1594: Top Left: Health Score Overview
Line 1597: Top Right: Core Metrics
Line 1600: Bottom Left: Quality & Security Metrics
Line 1603: Bottom Right: Recommendations
Line 1608: Render health score overview panel
Line 1644: Render overview text
Line 1659: Render core metrics panel
Line 1697: Render quality and security metrics panel
Line 1744: Render recommendations panel
Line 1775: Render topology content
Line 1778: Create 4-panel layout
Line 1794: Top Left: Language Distribution
Line 1797: Top Right: File Structure Overview
Line 1800: Bottom Left: Complexity Distribution
Line 1803: Bottom Right: Coupling Metrics
Line 1808: Render language distribution panel
Line 1817: Limit for display
Line 1831: Render file structure overview panel
Line 1838: Add sample files if available
Line 1865: Render complexity distribution panel
Line 1894: Render coupling metrics panel
Line 1923: Render quality content
Line 1926: Create 4-panel layout
Line 1942: Top Left: Health Score Gauge
Line 1945: Top Right: Issues by Severity
Line 1948: Bottom Left: Complexity Trend
Line 1951: Bottom Right: Maintainability Scores
Line 1956: Render health score gauge
Line 1988: Render text on top
Line 2003: Render issues by severity panel
Line 2025: Render complexity trend panel
Line 2054: Render maintainability scores panel
Line 2056: Prefer problematic files if available, otherwise show maintainability scores
Line 2096: Render security content
Line 2099: Create 4-panel layout
Line 2115: Top Left: Security Score Gauge
Line 2118: Top Right: Vulnerabilities by Severity
Line 2121: Bottom Left: Top Security Issues
Line 2124: Bottom Right: Files with Issues
Line 2129: Render security score gauge
Line 2156: Render text on top
Line 2171: Render vulnerabilities by severity panel
Line 2193: Render top security issues panel
Line 2224: Render files with security issues panel
Line 2248: Show count of additional files
Line 2264: Render dependencies content
Line 2278: Left side - Summary and circular dependencies
Line 2305: Truncate long cycle paths for display
Line 2326: Right side - Coupling analysis and external dependencies
Line 2391: Left side - Performance score and hotspots
Line 2397: Performance score gauge
Line 2435: Right side - Bottlenecks and slow functions
Line 2459: Slow functions (optimization opportunities)
Line 2499: Left side - Commit activity and author contributions
Line 2505: Commit activity patterns
Line 2574: Right side - File stability and churn metrics
Line 2613: Churn metrics (change frequency)
Line 2619: Very high churn
Line 2659: Left side - Issues by type and summary
Line 2665: Issues by type/tool
Line 2724: Right side - Recent issues
Line 2785: Left side - Coverage and test files
Line 2791: Test coverage gauge
Line 2800: Test files list
Line 2821: Right side - Uncovered files and test trends
Line 2848: Test trends (coverage by file or test counts)
Line 2886: Create 4-panel layout
Line 2902: Top Left: Flow Complexity Gauge
Line 2905: Top Right: Data Flows
Line 2908: Bottom Left: Control Flows
Line 2911: Bottom Right: Bottlenecks
Line 2916: Render tree-sitter analysis content
Line 2919: Create 4-panel layout
Line 2935: Top Left: Import Summary
Line 2938: Top Right: Highlight Summary
Line 2941: Bottom Left: Language Features
Line 2944: Bottom Right: Symbols
Line 2949: Render import summary
Line 2972: Render highlight summary
Line 3007: Render language features
Line 3017: Simple icon for now
Line 3045: Render symbols list
Line 3103: Render flow complexity gauge
Line 3105: Create gauge visualization
Line 3143: Render text on top
Line 3158: Render data flows list
Line 3196: Render control flows list
Line 3234: Render flow bottlenecks
Line 3266: Truncate a name to specified length with ellipsis
Line 3275: Get color for health score visualization
Line 3291: Get color for risk level
Line 3308: Get color for performance score visualization
Line 3324: Get color for test coverage visualization
Line 3340: Get header style
Line 3349: Get footer style
Line 3358: Get content style
Line 3367: Get chart style

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 11176 characters
🤖 Analyzing: [██████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]  37% (3/8) - topology_test.rs...🔍 DEBUG PROMPT for topology_test.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-viz/tests/topology_test.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
imports: Imports: use codehud_core::{, Imports: use codehud_viz::VisualizationEngine;., Imports: use std::path::PathBuf;.
structure: calls CodeMetrics::default., calls TopologyExtractor::new., calls AnalysisResult::new., calls PathBuf::from., calls VisualizationEngine::new., calls serde_json::to_value.

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create topology extractor
Line 19: Extract topology data
Line 24: Create analysis result with real topology data
Line 31: Store topology data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Topology view
Line 44: Check that we got the right view content
Line 86: Verify we have at least some data structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1241 characters
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (4/8) - summary_test.rs...🔍 DEBUG PROMPT for summary_test.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-viz/tests/summary_test.rs
Language: rust
Comments found: 16

STRUCTURAL CONTEXT:
structure: calls AnalysisResult::new., calls VisualizationEngine::new., calls PathBuf::from., calls CodeMetrics::default.
imports: Imports: use std::path::PathBuf;., Imports: use codehud_viz::VisualizationEngine;., Imports: use codehud_core::{, Imports: use serde_json::json;.

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create analysis result with comprehensive mock data from multiple extractors
Line 26: Add comprehensive view data from multiple extractors to test aggregation
Line 88: Create visualization engine
Line 92: Generate Summary view
Line 97: Check that we got the right view content
Line 125: Verify we have valid data structure
Line 132: Verify enhanced metrics were extracted
Line 139: Check specific values
Line 146: Verify enhanced recommendations were added
Line 147: Should have original + enhanced

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1345 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  62% (5/8) - quality_test.rs...🔍 DEBUG PROMPT for quality_test.rs:
=====================================
CONCISE FILE SUMMARY

File: ./codehud-viz/tests/quality_test.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
structure: calls VisualizationEngine::new., calls CodeMetrics::default., calls PathBuf::from., calls serde_json::to_value., calls AnalysisResult::new., calls QualityExtractor::new.
imports: Imports: use std::path::PathBuf;., Imports: use codehud_core::{, Imports: use codehud_viz::VisualizationEngine;.

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create quality extractor
Line 19: Extract quality data
Line 24: Create analysis result with real quality data
Line 31: Store quality data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Quality view
Line 44: Check that we got the right view content
Line 88: Verify we have valid data structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 1226 characters
📦 Processing batch 2/2 (3 files)...
🤖 Analyzing: [█████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░]  50% (4/8) - flow_test.rs...🔍 DEBUG PROMPT for flow_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- call_graph.rs: This Rust file, `call_graph.rs`, is a module for visualizing call graph analysis and its related functionalities using the ratatui widgets in an interactive way. The main purpose of this module is to 
- lib.rs: This Rust file provides a comprehensive visualization system for data analysis, including code structure and performance metrics, security vulnerabilities, quality issues, and more. It supports variou
- topology_test.rs: This Rust file, `topology_test.rs`, is a test module for the codehud-viz project. It tests the functionalities of the topology extraction and visualization engine components of the system by simulatin
- summary_test.rs: This Rust file, `summary_test.rs`, serves as a test suite for the code visualization tool CodeHUD-viz. It tests various aspects of its functionalities such as creating an analysis result with comprehe
- quality_test.rs: This Rust file is a test suite for the quality_test module of CodeHUD, an open-source software analyzer. It tests various functionalities such as creating QualityExtractor and VisualizationEngine inst

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-viz/tests/flow_test.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
imports: Imports: use codehud_viz::VisualizationEngine;., Imports: use std::path::PathBuf;., Imports: use codehud_core::{
structure: calls AnalysisResult::new., calls FlowExtractor::new., calls serde_json::to_value., calls PathBuf::from., calls CodeMetrics::default., calls VisualizationEngine::new.

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create flow extractor
Line 19: Extract flow data
Line 24: Create analysis result with real flow data
Line 31: Store flow data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Flow view
Line 44: Check that we got the right view content
Line 79: Verify we have at least some data structure

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2412 characters
🤖 Analyzing: [███████████████████████████████░░░░░░░░░░░░░░░░░░░]  62% (5/8) - dependencies_test.rs...🔍 DEBUG PROMPT for dependencies_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- call_graph.rs: This Rust file, `call_graph.rs`, is a module for visualizing call graph analysis and its related functionalities using the ratatui widgets in an interactive way. The main purpose of this module is to 
- lib.rs: This Rust file provides a comprehensive visualization system for data analysis, including code structure and performance metrics, security vulnerabilities, quality issues, and more. It supports variou
- topology_test.rs: This Rust file, `topology_test.rs`, is a test module for the codehud-viz project. It tests the functionalities of the topology extraction and visualization engine components of the system by simulatin
- summary_test.rs: This Rust file, `summary_test.rs`, serves as a test suite for the code visualization tool CodeHUD-viz. It tests various aspects of its functionalities such as creating an analysis result with comprehe
- quality_test.rs: This Rust file is a test suite for the quality_test module of CodeHUD, an open-source software analyzer. It tests various functionalities such as creating QualityExtractor and VisualizationEngine inst

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-viz/tests/dependencies_test.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
imports: Imports: use codehud_core::{, Imports: use codehud_viz::VisualizationEngine;., Imports: use std::path::PathBuf;.
structure: calls serde_json::to_value., calls PathBuf::from., calls AnalysisResult::new., calls VisualizationEngine::new., calls CodeMetrics::default., calls DependenciesExtractor::new.

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create dependencies extractor
Line 19: Extract dependencies data
Line 24: Create analysis result with real dependencies data
Line 31: Store dependencies data in the extracted view data (convert HashMap to Value)
Line 35: Create visualization engine
Line 39: Generate Dependencies view
Line 44: Check that we got the right view content
Line 82: Verify we have at least some data

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2458 characters
🤖 Analyzing: [█████████████████████████████████████░░░░░░░░░░░░░]  75% (6/8) - security_test.rs...🔍 DEBUG PROMPT for security_test.rs:
=====================================
PREVIOUS PROJECT ANALYSIS:

- call_graph.rs: This Rust file, `call_graph.rs`, is a module for visualizing call graph analysis and its related functionalities using the ratatui widgets in an interactive way. The main purpose of this module is to 
- lib.rs: This Rust file provides a comprehensive visualization system for data analysis, including code structure and performance metrics, security vulnerabilities, quality issues, and more. It supports variou
- topology_test.rs: This Rust file, `topology_test.rs`, is a test module for the codehud-viz project. It tests the functionalities of the topology extraction and visualization engine components of the system by simulatin
- summary_test.rs: This Rust file, `summary_test.rs`, serves as a test suite for the code visualization tool CodeHUD-viz. It tests various aspects of its functionalities such as creating an analysis result with comprehe
- quality_test.rs: This Rust file is a test suite for the quality_test module of CodeHUD, an open-source software analyzer. It tests various functionalities such as creating QualityExtractor and VisualizationEngine inst

Use this context to understand the project structure and maintain consistency.

CONCISE FILE SUMMARY

File: ./codehud-viz/tests/security_test.rs
Language: rust
Comments found: 9

STRUCTURAL CONTEXT:
imports: Imports: use codehud_viz::VisualizationEngine;., Imports: use codehud_core::{, Imports: use serde_json::json;., Imports: use std::path::PathBuf;.
structure: calls PathBuf::from., calls AnalysisResult::new., calls CodeMetrics::default., calls VisualizationEngine::new.

COMMENTS TO ANALYZE:
Line 12: Use the current codebase as test data
Line 16: Create analysis result with mock security data to test visualization
Line 23: Create mock security data that matches what the SecurityExtractor would produce
Line 67: Store security data in the extracted view data
Line 70: Create visualization engine
Line 74: Generate Security view
Line 79: Check that we got the right view content
Line 116: Verify we have valid data structure
Line 121: Verify mock data was processed correctly

Technical Summary: In 2-3 direct sentences, explain what this file DOES for users/callers. List specific functions, features, or behaviors it implements. Use concrete examples (e.g., "detects SQL injection", "parses JSON configs", "calculates hash values"). Avoid generic phrases like "serves as", "provides functionality", "manages", or "designed to". Maximum 100 words.
=====================================
📏 Prompt length: 2475 characters
🤖 Analyzing: [██████████████████████████████████████████████████] 100% (8/8) - Complete!
✅ Phase 2 complete: 8 files analyzed with enhanced context
📄 File summaries updated: 144 total files (8 from codehud-viz)
📄 Analysis metadata updated: 10 crates processed

📝 PHASE 2: Detecting subcrates and generating subcrate summaries for all crates...

🔍 Detecting subcrates for crate: codehud-analysis
🔍 DEBUG: Filtered 3 files for crate codehud-analysis (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis)
📦 No subcrates detected for codehud-analysis (files: 3)
✅ Phase 2 complete for crate: codehud-analysis
🔍 Detecting subcrates for crate: codehud-cli
🔍 DEBUG: Filtered 4 files for crate codehud-cli (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli)
📦 No subcrates detected for codehud-cli (files: 4)
✅ Phase 2 complete for crate: codehud-cli
🔍 Detecting subcrates for crate: codehud-core
🔍 DEBUG: Filtered 52 files for crate codehud-core (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core)
📦 Detected 4 subcrates for codehud-core (including nested)
   - src (2 direct files, 3 nested, 668.5 KB)
📊 Token budget: 4 subcrates × 250 tokens/subcrate = 1000 total (max 5000)
📝 Generating summary for subcrate: src (2 files, 668.5 KB)
✅ Generated subcrate summary: src (171 tokens)
📦 Total subcrate summaries generated: 1
💾 Saved 1 subcrate summaries for crate: codehud-core
✅ Phase 2 complete for crate: codehud-core
🔍 Detecting subcrates for crate: codehud-gui
🔍 DEBUG: Filtered 24 files for crate codehud-gui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui)
📦 Detected 2 subcrates for codehud-gui (including nested)
   - src (5 direct files, 1 nested, 194.7 KB)
📊 Token budget: 2 subcrates × 250 tokens/subcrate = 500 total (max 5000)
📝 Generating summary for subcrate: src (5 files, 194.7 KB)
✅ Generated subcrate summary: src (122 tokens)
📦 Total subcrate summaries generated: 1
💾 Saved 1 subcrate summaries for crate: codehud-gui
✅ Phase 2 complete for crate: codehud-gui
🔍 Detecting subcrates for crate: codehud-llm
🔍 DEBUG: Filtered 30 files for crate codehud-llm (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm)
📦 Detected 3 subcrates for codehud-llm (including nested)
   - src (17 direct files, 1 nested, 525.9 KB)
📊 Token budget: 3 subcrates × 250 tokens/subcrate = 750 total (max 5000)
📝 Generating summary for subcrate: src (17 files, 525.9 KB)
✅ Generated subcrate summary: src (161 tokens)
📦 Total subcrate summaries generated: 1
💾 Saved 1 subcrate summaries for crate: codehud-llm
✅ Phase 2 complete for crate: codehud-llm
🔍 Detecting subcrates for crate: codehud-realtime
🔍 DEBUG: Filtered 1 files for crate codehud-realtime (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime)
📦 No subcrates detected for codehud-realtime (files: 1)
✅ Phase 2 complete for crate: codehud-realtime
🔍 Detecting subcrates for crate: codehud-transform
🔍 DEBUG: Filtered 15 files for crate codehud-transform (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform)
📦 Detected 2 subcrates for codehud-transform (including nested)
   - src (5 direct files, 1 nested, 291.5 KB)
📊 Token budget: 2 subcrates × 250 tokens/subcrate = 500 total (max 5000)
📝 Generating summary for subcrate: src (5 files, 291.5 KB)
✅ Generated subcrate summary: src (165 tokens)
📦 Total subcrate summaries generated: 1
💾 Saved 1 subcrate summaries for crate: codehud-transform
✅ Phase 2 complete for crate: codehud-transform
🔍 Detecting subcrates for crate: codehud-tui
🔍 DEBUG: Filtered 2 files for crate codehud-tui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui)
📦 No subcrates detected for codehud-tui (files: 2)
✅ Phase 2 complete for crate: codehud-tui
🔍 Detecting subcrates for crate: codehud-utils
🔍 DEBUG: Filtered 5 files for crate codehud-utils (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils)
📦 Detected 1 subcrates for codehud-utils (including nested)
   - src (1 direct files, 0 nested, 49.4 KB)
📊 Token budget: 1 subcrates × 250 tokens/subcrate = 250 total (max 5000)
📝 Generating summary for subcrate: src (1 files, 49.4 KB)
✅ Generated subcrate summary: src (163 tokens)
📦 Total subcrate summaries generated: 1
💾 Saved 1 subcrate summaries for crate: codehud-utils
✅ Phase 2 complete for crate: codehud-utils
🔍 Detecting subcrates for crate: codehud-viz
🔍 DEBUG: Filtered 8 files for crate codehud-viz (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz)
📦 Detected 1 subcrates for codehud-viz (including nested)
   - tests (6 direct files, 0 nested, 26.0 KB)
📊 Token budget: 1 subcrates × 250 tokens/subcrate = 250 total (max 5000)
📝 Generating summary for subcrate: tests (6 files, 26.0 KB)
✅ Generated subcrate summary: tests (179 tokens)
📦 Total subcrate summaries generated: 1
💾 Saved 1 subcrate summaries for crate: codehud-viz
✅ Phase 2 complete for crate: codehud-viz

📝 PHASE 3: Generating crate summaries for all crates...

🔍 DEBUG: Filtered 3 files for crate codehud-analysis (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-analysis)
⚠️  No subcrate summaries found for crate: codehud-analysis
🧠 Generating context-aware summary for crate: codehud-analysis (with 0 previous insights)
📄 No subcrates, using all 3 files individually
✅ Context-aware crate summary generated: 502 tokens
✅ Generated context-aware summary for crate 'codehud-analysis': 502 tokens
📄 Crate summaries updated: 1 total crates
🔍 DEBUG: Filtered 4 files for crate codehud-cli (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-cli)
⚠️  No subcrate summaries found for crate: codehud-cli
🧠 Generating context-aware summary for crate: codehud-cli (with 1 previous insights)
📄 No subcrates, using all 4 files individually
✅ Context-aware crate summary generated: 630 tokens
✅ Generated context-aware summary for crate 'codehud-cli': 630 tokens
📄 Crate summaries updated: 2 total crates
🔍 DEBUG: Filtered 52 files for crate codehud-core (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-core)
📂 Loaded 1 subcrate summaries for crate: codehud-core
🧠 Generating context-aware summary for crate: codehud-core (with 2 previous insights)
📦 Using subcrate summaries: 1 subcrates, 17 individual files, 35 files in subcrates
✅ Context-aware crate summary generated: 636 tokens
✅ Generated context-aware summary for crate 'codehud-core': 636 tokens
📄 Crate summaries updated: 3 total crates
🔍 DEBUG: Filtered 24 files for crate codehud-gui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-gui)
📂 Loaded 1 subcrate summaries for crate: codehud-gui
🧠 Generating context-aware summary for crate: codehud-gui (with 3 previous insights)
📦 Using subcrate summaries: 1 subcrates, 7 individual files, 17 files in subcrates
✅ Context-aware crate summary generated: 423 tokens
✅ Generated context-aware summary for crate 'codehud-gui': 423 tokens
📄 Crate summaries updated: 4 total crates
🔍 DEBUG: Filtered 30 files for crate codehud-llm (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-llm)
📂 Loaded 1 subcrate summaries for crate: codehud-llm
🧠 Generating context-aware summary for crate: codehud-llm (with 4 previous insights)
📦 Using subcrate summaries: 1 subcrates, 2 individual files, 28 files in subcrates
✅ Context-aware crate summary generated: 455 tokens
✅ Generated context-aware summary for crate 'codehud-llm': 455 tokens
📄 Crate summaries updated: 5 total crates
🔍 DEBUG: Filtered 1 files for crate codehud-realtime (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-realtime)
⚠️  No subcrate summaries found for crate: codehud-realtime
🧠 Generating context-aware summary for crate: codehud-realtime (with 5 previous insights)
📄 No subcrates, using all 1 files individually
✅ Context-aware crate summary generated: 382 tokens
✅ Generated context-aware summary for crate 'codehud-realtime': 382 tokens
📄 Crate summaries updated: 6 total crates
🔍 DEBUG: Filtered 15 files for crate codehud-transform (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-transform)
📂 Loaded 1 subcrate summaries for crate: codehud-transform
🧠 Generating context-aware summary for crate: codehud-transform (with 6 previous insights)
📦 Using subcrate summaries: 1 subcrates, 0 individual files, 15 files in subcrates
✅ Context-aware crate summary generated: 687 tokens
✅ Generated context-aware summary for crate 'codehud-transform': 687 tokens
📄 Crate summaries updated: 7 total crates
🔍 DEBUG: Filtered 2 files for crate codehud-tui (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-tui)
⚠️  No subcrate summaries found for crate: codehud-tui
🧠 Generating context-aware summary for crate: codehud-tui (with 7 previous insights)
📄 No subcrates, using all 2 files individually
✅ Context-aware crate summary generated: 591 tokens
✅ Generated context-aware summary for crate 'codehud-tui': 591 tokens
📄 Crate summaries updated: 8 total crates
🔍 DEBUG: Filtered 5 files for crate codehud-utils (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-utils)
📂 Loaded 1 subcrate summaries for crate: codehud-utils
🧠 Generating context-aware summary for crate: codehud-utils (with 8 previous insights)
📦 Using subcrate summaries: 1 subcrates, 4 individual files, 1 files in subcrates
✅ Context-aware crate summary generated: 633 tokens
✅ Generated context-aware summary for crate 'codehud-utils': 633 tokens
📄 Crate summaries updated: 9 total crates
🔍 DEBUG: Filtered 8 files for crate codehud-viz (canonical path: /home/travers/Desktop/CodeHUD (copy)/Rust_copy/codehud-viz)
📂 Loaded 1 subcrate summaries for crate: codehud-viz
🧠 Generating context-aware summary for crate: codehud-viz (with 9 previous insights)
📦 Using subcrate summaries: 1 subcrates, 2 individual files, 6 files in subcrates
✅ Context-aware crate summary generated: 461 tokens
✅ Generated context-aware summary for crate 'codehud-viz': 461 tokens
📄 Crate summaries updated: 10 total crates
📝 Generating final hierarchical summary...
📝 Generating final hierarchical summary with 12K token budget...
📊 Loaded 10 real crate summaries for hierarchical analysis
🧠 Applying intelligent denoising to 10 crate summaries
🔍 DEBUG: Denoising input: 2011 chars, 290 words
🔍 DEBUG: Found 15 sentences
🔍 DEBUG: Sentence 0: score=12.5 - ## Overall Architecture
The `codehud-analysis` crate serves as a comprehensive c
🔍 DEBUG: Sentence 1: score=2.5 -  It utilizes several design patterns like pipeline pattern and factory pattern f
🔍 DEBUG: Sentence 2: score=6.0 -  The crate has an architecture that relies heavily on modularity and composition
🔍 DEBUG: Sentence 3: score=8.5 - 

## What Does It Actually Do
The `codehud-analysis` crate provides a comprehens
🔍 DEBUG: Sentence 4: score=2.5 -  It manages different types of analyses including direct and legacy modes
🔍 DEBUG: Sentence 5: score=3.5 -  The main feature provided by this crate is its ability to perform zero-degradat
🔍 DEBUG: Sentence 6: score=5.5 -  

It uses Rust's strong type system and error handling mechanism to ensure the 
🔍 DEBUG: Sentence 7: score=4.0 -  For example, it provides a `Result` type for operations that can fail, which al
🔍 DEBUG: Sentence 8: score=4.0 -  This makes the code more readable and manageable by providing specific function
🔍 DEBUG: Sentence 9: score=7.0 - 

The crate also includes features for health score calculation and breakdown, i
🔍 DEBUG: Sentence 10: score=4.5 -  It handles complexity metrics, issue severity levels, security vulnerabilities,
🔍 DEBUG: Sentence 11: score=4.0 -  This makes the system capable of analyzing and evaluating code quality based on
🔍 DEBUG: Sentence 12: score=2.5 - 

In addition, it provides comprehensive markdown export capabilities for users 
🔍 DEBUG: Sentence 13: score=2.5 -  It also handles errors and warnings during this process and presents summaries 
🔍 DEBUG: Sentence 14: score=4.0 -  The crate is designed with a focus on extensibility and customizability, making
🔍 DEBUG: Keeping 9 out of 15 sentences
🔍 DEBUG: Denoising input: 2520 chars, 336 words
🔍 DEBUG: Found 24 sentences
🔍 DEBUG: Sentence 0: score=9.5 - ## Overall Architecture
The 'codehud-cli' crate forms a crucial part of the Code
🔍 DEBUG: Sentence 1: score=1.5 -  It is built using Rust programming language and follows modular design principl
🔍 DEBUG: Sentence 2: score=-0.5 -  `main
🔍 DEBUG: Sentence 3: score=6.0 - rs` file serves as the main entry point for CodeHUD CLI, handling user interacti
🔍 DEBUG: Sentence 4: score=-0.5 - 
2
🔍 DEBUG: Sentence 5: score=1.5 -  `llm
🔍 DEBUG: Sentence 6: score=6.5 - rs` implements an AI-powered CLI that leverages OpenLLama's models for code anal
🔍 DEBUG: Sentence 7: score=14.0 -  It provides interactive LLM interfaces, model configuration options, control ov
🔍 DEBUG: Sentence 8: score=-0.5 - 
3
🔍 DEBUG: Sentence 9: score=-0.5 -  `direct
🔍 DEBUG: Sentence 10: score=7.0 - rs` is responsible for direct extraction and legacy CLI analysis functionality s
🔍 DEBUG: Sentence 11: score=-0.5 - py script
🔍 DEBUG: Sentence 12: score=7.5 -  It allows users to specify various parameters like codebase directory, configur
🔍 DEBUG: Sentence 13: score=4.5 - , enabling interactive picker for selecting files and running direct analysis pi
🔍 DEBUG: Sentence 14: score=-0.5 - 
4
🔍 DEBUG: Sentence 15: score=-0.5 -  `data
🔍 DEBUG: Sentence 16: score=8.0 - rs` serves as a command-line interface (CLI) for data analysis operations, provi
🔍 DEBUG: Sentence 17: score=4.5 -  It handles file I/O via std::fs::write(&output_path), checks basic structures o
🔍 DEBUG: Sentence 18: score=8.0 - 

The crate is designed with a layered architecture in mind, where each Rust fil
🔍 DEBUG: Sentence 19: score=2.5 -  It has been implemented following dependency injection principles to ensure loo
🔍 DEBUG: Sentence 20: score=8.0 - 

## What Does It Actually Do
The 'codehud-cli' crate essentially provides a com
🔍 DEBUG: Sentence 21: score=1.5 -  Its primary functionalities include:

1
🔍 DEBUG: Sentence 22: score=4.0 -  **Code Analysis**: The CLI allows running various analyses on the user's codeba
🔍 DEBUG: Sentence 23: score=1.0 -  It supports different
🔍 DEBUG: Keeping 15 out of 24 sentences
🔍 DEBUG: Denoising input: 2545 chars, 342 words
🔍 DEBUG: Found 26 sentences
🔍 DEBUG: Sentence 0: score=7.0 - ## Overall Architecture
The 'codehud-core' crate is a Rust implementation of the
🔍 DEBUG: Sentence 1: score=0.5 -  It follows an architectural design pattern that emphasizes modularity, separati
🔍 DEBUG: Sentence 2: score=2.5 -  

The crate is built around three main components:
1
🔍 DEBUG: Sentence 3: score=6.5 -  Analysis Pipelines: This component manages the execution of different analysis 
🔍 DEBUG: Sentence 4: score=-0.5 - 
2
🔍 DEBUG: Sentence 5: score=0.5 -  Code Extractors: These are responsible for extracting various types of data suc
🔍 DEBUG: Sentence 6: score=1.0 -  They run in parallel to improve efficiency
🔍 DEBUG: Sentence 7: score=-0.5 - 
3
🔍 DEBUG: Sentence 8: score=0.5 -  Health Calculator: This component calculates the overall health score of a code
🔍 DEBUG: Sentence 9: score=0.0 -  It uses weighted averages for calculating scores
🔍 DEBUG: Sentence 10: score=2.5 - 

The crate has several dependencies including serde_json for JSON manipulation,
🔍 DEBUG: Sentence 11: score=1.5 - , which are managed via Rust's package manager called Cargo
🔍 DEBUG: Sentence 12: score=6.0 -  The structure of the crate is modular with separate files representing differen
🔍 DEBUG: Sentence 13: score=2.5 -  

## What Does It Actually Do
The 'codehud-core' crate performs a variety of an
🔍 DEBUG: Sentence 14: score=-0.5 -  These include:
1
🔍 DEBUG: Sentence 15: score=6.5 -  Directed and Legacy Pipeline Types: These types manage the execution of differe
🔍 DEBUG: Sentence 16: score=-0.5 -  
2
🔍 DEBUG: Sentence 17: score=2.5 -  Various Code Extractions: The crate extracts a range of data such as performanc
🔍 DEBUG: Sentence 18: score=-0.5 - 
3
🔍 DEBUG: Sentence 19: score=0.5 -  Health Score Calculation: It calculates the overall health score of a codebase 
🔍 DEBUG: Sentence 20: score=-0.5 -  
4
🔍 DEBUG: Sentence 21: score=9.5 -  Hybrid Analysis Pipeline Functionality: This feature allows combining different
🔍 DEBUG: Sentence 22: score=-0.5 -  
5
🔍 DEBUG: Sentence 23: score=6.0 -  Benchmarking: The crate also provides performance benchmarking of code analysis
🔍 DEBUG: Sentence 24: score=-0.5 - 
6
🔍 DEBUG: Sentence 25: score=2.5 -  Cache Management: It manages intelligent caching capabilities, ensuring consist
🔍 DEBUG: Keeping 16 out of 26 sentences
🔍 DEBUG: Denoising input: 1693 chars, 227 words
🔍 DEBUG: Found 8 sentences
🔍 DEBUG: Sentence 0: score=7.5 - ## Overall Architecture
The `codehud-gui` crate forms a crucial part of the Code
🔍 DEBUG: Sentence 1: score=0.5 -  It utilizes a modular design pattern with dependencies on other essential compo
🔍 DEBUG: Sentence 2: score=2.5 -  The GUI component interacts with various subsystems through the SignalBus to tr
🔍 DEBUG: Sentence 3: score=12.0 - 

## What Does It Actually Do
The `codehud-gui` Rust crate manages and analyzes 
🔍 DEBUG: Sentence 4: score=8.5 -  It provides an intuitive, user-friendly interface for such analyses through var
🔍 DEBUG: Sentence 5: score=2.5 - 

The GUI component interacts with users directly via a series of graphical inte
🔍 DEBUG: Sentence 6: score=7.0 -  These include menus to load projects and initiate LLM functionalities; project 
🔍 DEBUG: Sentence 7: score=2.0 -  All these components work together forming a cohesive system, allowing users to
🔍 DEBUG: Keeping 5 out of 8 sentences
🔍 DEBUG: Denoising input: 1822 chars, 264 words
🔍 DEBUG: Found 10 sentences
🔍 DEBUG: Sentence 0: score=10.5 - ## Overall Architecture
The `codehud-llm` crate, as a part of the CodeHud projec
🔍 DEBUG: Sentence 1: score=5.0 -  It follows a modular architecture design pattern where different components are
🔍 DEBUG: Sentence 2: score=13.0 -  

The crate has three main components: the `codehud-llm` core engine, a Rust Fo
🔍 DEBUG: Sentence 3: score=9.0 -  The FFI bridge serves as an interface for communication between Rust code and e
🔍 DEBUG: Sentence 4: score=8.5 - 

## What Does It Actually Do
The `codehud-llm` crate essentially provides a sui
🔍 DEBUG: Sentence 5: score=4.0 -  This includes potential security vulnerabilities detection through analyses on 
🔍 DEBUG: Sentence 6: score=9.0 -  

These analyses can be performed using the Rust FFI bridge, which allows the u
🔍 DEBUG: Sentence 7: score=7.0 -  The tests in `codehud-llm` crate ensure that this implementation maintains a hi
🔍 DEBUG: Sentence 8: score=10.5 - 

The crate also includes a comprehensive testing environment to validate the FF
🔍 DEBUG: Sentence 9: score=1.5 -  These tests ensure that the FFI maintains an average bug fix success rate above
🔍 DEBUG: Keeping 6 out of 10 sentences
🔍 DEBUG: Denoising input: 1528 chars, 215 words
🔍 DEBUG: Found 11 sentences
🔍 DEBUG: Sentence 0: score=8.0 - ## Overall Architecture
The `codehud-realtime` crate is designed as a component 
🔍 DEBUG: Sentence 1: score=1.0 -  It interacts with other components via Rust traits and follows layered architec
🔍 DEBUG: Sentence 2: score=6.0 -  The crate depends on `codehud-core` for core functionalities such as caching an
🔍 DEBUG: Sentence 3: score=8.0 - 

## What Does It Actually Do
The `codehud-realtime` crate serves as a real-time
🔍 DEBUG: Sentence 4: score=4.0 -  Specifically, it enables users to monitor file system events and perform increm
🔍 DEBUG: Sentence 5: score=4.5 -  The library provides configurable options for debounce delay, maximum batch siz
🔍 DEBUG: Sentence 6: score=1.0 -  Additionally, it allows ignoring specific types or extensions of files based on
🔍 DEBUG: Sentence 7: score=3.5 - 

The crate employs a caching mechanism to avoid redundant analyses of unchanged
🔍 DEBUG: Sentence 8: score=8.0 -  It includes an event processing loop that processes incoming file system events
🔍 DEBUG: Sentence 9: score=0.5 -  Files are extracted based on these events and further analyzed for specific asp
🔍 DEBUG: Sentence 10: score=8.5 -  The crate provides error management for real-time monitoring, notifying users a
🔍 DEBUG: Keeping 7 out of 11 sentences
🔍 DEBUG: Denoising input: 2750 chars, 372 words
🔍 DEBUG: Found 18 sentences
🔍 DEBUG: Sentence 0: score=3.0 - ## Overall Architecture
The `codehud-transform` crate sits at the heart of CodeH
🔍 DEBUG: Sentence 1: score=2.0 -  It utilizes layered architecture with multiple components working together to a
🔍 DEBUG: Sentence 2: score=3.5 -  The architecture is designed to be modular allowing for easy addition or remova
🔍 DEBUG: Sentence 3: score=2.5 - 

The crate depends heavily on LibCST-equivalent concrete syntax tree (CST) tran
🔍 DEBUG: Sentence 4: score=3.0 -  This allows for preserving formatting and comments exactly like Python's LibCST
🔍 DEBUG: Sentence 5: score=4.0 -  The crate also leverages tree-sitter, an industrial-strength parser toolkit for
🔍 DEBUG: Sentence 6: score=2.0 - 

The architecture is designed to support Git integration, offering comprehensiv
🔍 DEBUG: Sentence 7: score=3.5 -  This allows users to manage their codebase easily with features such as creatin
🔍 DEBUG: Sentence 8: score=6.5 -  The crate's rollback system ensures that transformations can be reverted if nec
🔍 DEBUG: Sentence 9: score=4.5 - 

## What Does It Actually Do
The `codehud-transform` crate provides a comprehen
🔍 DEBUG: Sentence 10: score=0.5 -  These transformations are modular and configurable, enabling users to customize
🔍 DEBUG: Sentence 11: score=1.0 -  For instance, it can detect potential security vulnerabilities in Python code, 
🔍 DEBUG: Sentence 12: score=8.0 - 

The transformation engine provides a variety of functionalities including CST 
🔍 DEBUG: Sentence 13: score=5.0 -  These features allow the crate to transform any codebase with zero degradation 
🔍 DEBUG: Sentence 14: score=2.0 -  The crate can parse any language supported by tree-sitter into an Abstract Synt
🔍 DEBUG: Sentence 15: score=4.0 - 

Moreover, the transformation engine supports Git integration, offering compreh
🔍 DEBUG: Sentence 16: score=4.5 -  The rollback system ensures that users can revert any transformation if necessa
🔍 DEBUG: Sentence 17: score=2.5 -  This provides an easy way to manage changes to codebases without worry
🔍 DEBUG: Keeping 11 out of 18 sentences
🔍 DEBUG: Denoising input: 2364 chars, 342 words
🔍 DEBUG: Found 18 sentences
🔍 DEBUG: Sentence 0: score=4.5 - ## Overall Architecture
The 'codehud-tui' crate is a key component of the Claude
🔍 DEBUG: Sentence 1: score=8.0 -  This crate sits atop the higher level components such as `codehud-core` for cor
🔍 DEBUG: Sentence 2: score=6.5 -  It interacts with other components like `codehud-gui` for graphical user interf
🔍 DEBUG: Sentence 3: score=6.0 - 

The crate is designed to be modular in nature, making it easy to integrate int
🔍 DEBUG: Sentence 4: score=0.0 -  It has dependencies on various external libraries such as `crossterm` and `rata
🔍 DEBUG: Sentence 5: score=2.5 -  

The crate is structured in the following way: The main file, `main
🔍 DEBUG: Sentence 6: score=2.5 - rs`, sets up and manages the TUI application including user input parsing and ma
🔍 DEBUG: Sentence 7: score=0.0 -  A library file, `lib
🔍 DEBUG: Sentence 8: score=9.0 - rs`, provides a terminal user interface specifically designed for Claude Code co
🔍 DEBUG: Sentence 9: score=10.0 - 

## What Does It Actually Do
The 'codehud-tui' crate serves as the Command Line
🔍 DEBUG: Sentence 10: score=2.0 -  

Users interact with the CLI tool by passing in options such as codebase path,
🔍 DEBUG: Sentence 11: score=2.5 -  The tool can be used with legacy CodeHUD versions through their respective CLI 
🔍 DEBUG: Sentence 12: score=2.5 - 

The CLI checks terminal capabilities before running the TUI for color support 
🔍 DEBUG: Sentence 13: score=-0.5 - <｜begin▁of▁sentence｜>g
🔍 DEBUG: Sentence 14: score=0.0 - , when run in non-terminal environments)
🔍 DEBUG: Sentence 15: score=2.5 -  

It provides different views like critical issues view (TUI Priority View), se
🔍 DEBUG: Sentence 16: score=2.5 - , to better understand the codebase analysis results
🔍 DEBUG: Sentence 17: score=2.0 -  The tool also supports exporting visualizations directly in terminal without an
🔍 DEBUG: Keeping 11 out of 18 sentences
🔍 DEBUG: Denoising input: 2533 chars, 346 words
🔍 DEBUG: Found 19 sentences
🔍 DEBUG: Sentence 0: score=10.5 - ## Overall Architecture
The 'codehud-utils' crate is a fundamental part of the C
🔍 DEBUG: Sentence 1: score=8.0 -  It follows a modular architecture where each module provides specific functiona
🔍 DEBUG: Sentence 2: score=5.0 -  The crate is divided into subcrates like 'codehud-utils/src' which offers a com
🔍 DEBUG: Sentence 3: score=6.0 - 

The crate has no dependencies on other CodeHUD crates as it does not contain a
🔍 DEBUG: Sentence 4: score=2.0 -  It is designed following layered architecture with each layer depending only on
🔍 DEBUG: Sentence 5: score=7.0 - 

## What Does It Actually Do
The 'codehud-utils' crate in Rust offers various f
🔍 DEBUG: Sentence 6: score=-0.5 -  

1
🔍 DEBUG: Sentence 7: score=11.0 -  **Configuration Management**: This module provides an interface similar to Pyth
🔍 DEBUG: Sentence 8: score=4.0 -  It supports retrieving values of different types, merging configurations, findi
🔍 DEBUG: Sentence 9: score=-0.5 -  

2
🔍 DEBUG: Sentence 10: score=5.5 -  **Logging**: The logging module provides an advanced utility for Rust applicati
🔍 DEBUG: Sentence 11: score=3.5 -  It includes features like structured logging, rotating log files with different
🔍 DEBUG: Sentence 12: score=-0.5 - )
🔍 DEBUG: Sentence 13: score=-0.5 - 

3
🔍 DEBUG: Sentence 14: score=3.5 -  **File Operations**: This module offers file and directory operations with simi
🔍 DEBUG: Sentence 15: score=1.0 -  It supports reading and writing of files, creation of directories, copying of f
🔍 DEBUG: Sentence 16: score=-0.5 - 

4
🔍 DEBUG: Sentence 17: score=9.0 -  **String Manipulation**: This module provides a set of utility functions for st
🔍 DEBUG: Sentence 18: score=3.0 -  It includes text normalization, whitespace replacement, text truncation, extrac
🔍 DEBUG: Keeping 12 out of 19 sentences
🔍 DEBUG: Denoising input: 1844 chars, 261 words
🔍 DEBUG: Found 14 sentences
🔍 DEBUG: Sentence 0: score=4.5 - ## Overall Architecture
The `codehud-viz` crate is a key component of the CodeHU
🔍 DEBUG: Sentence 1: score=0.5 -  This modular and layered architecture ensures a high level of code organization
🔍 DEBUG: Sentence 2: score=4.0 -  It adopts a modular design pattern where various functionalities are divided in
🔍 DEBUG: Sentence 3: score=7.5 -  The dependencies between these crates form a clear and logical structure that s
🔍 DEBUG: Sentence 4: score=8.0 -  

## What Does It Actually Do
The `codehud-viz` crate serves as an interactive 
🔍 DEBUG: Sentence 5: score=7.5 -  This includes call graph analysis, which provides a graphical representation of
🔍 DEBUG: Sentence 6: score=4.0 -  The system is designed to support multiple output formats including terminal an
🔍 DEBUG: Sentence 7: score=10.0 -  

In terms of functionality, the crate provides a comprehensive suite of visual
🔍 DEBUG: Sentence 8: score=2.5 -  It can generate different types of views such as code topology, security analys
🔍 DEBUG: Sentence 9: score=0.0 - , based on input data and settings
🔍 DEBUG: Sentence 10: score=7.5 -  The system supports various features for presenting structured code data like f
🔍 DEBUG: Sentence 11: score=3.5 - 

The crate is written in Rust and makes use of its strong typing and memory saf
🔍 DEBUG: Sentence 12: score=2.5 -  It uses the `ratatui` library for creating interactive visualizations, which pr
🔍 DEBUG: Sentence 13: score=8.0 -  

In essence, CodeHUD's `codehud-viz` crate is an integral part of its ecosyste
🔍 DEBUG: Keeping 9 out of 14 sentences
✅ Intelligent denoising complete: reduced from 5400 to 3989 total tokens
📊 Final hierarchical prompt: 17936 characters (target: 12K tokens)
📄 Hierarchical summary saved: ./project_scan_output/hierarchical_summary.md
✅ Hierarchical project summary generated successfully
📄 Summary preview: Title: CodeHUD - A Unified Platform for Comprehensive Code Analysis and Development Assistance 

CodeHUD is a comprehensive tool designed to provide developers with robust code analysis and effective development assistance. The system as a whole operates on a multi-layer architecture, consisting of several independent crates, each dedicated to specific functionality: CODEHUD-ANALYSIS, CODEHUD-CLI, CODEHUD-CORE, CODEHUD-GUI, CODEHUD-LLM, CODEHUD-REALTIME, CODEHUD-TRANSFORM, CODEHUD-TUI and CODEHU...
